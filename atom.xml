<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leon的博客</title>
  <icon>https://www.gravatar.com/avatar/9d151238658e9fa1d07c5b6b41f6fcbc</icon>
  <subtitle>Web Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-18T23:17:14.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李晓</name>
    <email>xiao.liunit@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim——使用NerdTree来畅快的打开文件吧</title>
    <link href="http://yoursite.com/2017/12/19/Vim%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8NerdTree%E6%9D%A5%E7%95%85%E5%BF%AB%E7%9A%84%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%90%A7/"/>
    <id>http://yoursite.com/2017/12/19/Vim——使用NerdTree来畅快的打开文件吧/</id>
    <published>2017-12-18T23:11:50.000Z</published>
    <updated>2017-12-18T23:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一章我介绍完用<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle</a>来管理Vim中所有的插件后，今天我又要强推一个Vim的文件管理插件<a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">Nerdtree</a>,相信所有使用Vim的同学都知道文件管理插件NerdTree,这个几乎是所有拥护Vim的开发人员都会使用的插件，今天就总结一下如何合理的使用NerdTree。</p><a id="more"></a><p>首先我们来看一下NerdTree的官方效果图:</p><p><img src="https://github.com/scrooloose/nerdtree/raw/master/screenshot.png" alt="Nerdtree"></p><p>安装的话就使用咱们上一篇讲的Vundle插件进行安装，至于安装这样的小细节咱们在此就不再赘述。</p><p>当安装完成后，我们会有疑惑，如何召唤神龙打开NerdTree的文件列表呢？</p><p>答案非常简单，在你的<code>.vimrc</code>文件中添加<code>map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;</code>这样一行语句，那么你便能通过<code>ctrl+n</code>来开启关闭Nerdtree了。</p><p>而如果你对Nerdtree已经到达爱不释手的地步，希望只要打开了vim，就能看到Nerdtree的可爱界面，那么你可以增加自动启动的配置语句:</p><p><code>autocmd StdinReadPre * let s:std_in=1autocmd VimEnter * if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(&quot;s:std_in&quot;) | exe &#39;NERDTree&#39; argv()[0] | wincmd p | ene | endif</code></p><p>ok，把它写入到你的<code>.vimrc</code>文件中，nerdtree就会跟着你的vim自动启动了。</p><p>在增加了自动启动之后，我们也会碰到比较烦人的事情，就是有时我们编辑完文件退出后，窗口里就留下来nerdtree，还需要自己再退出一次，除非用:qall。该怎么解决这个问题呢？</p><p><code>autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif</code></p><p>那么将上面的配置语句添加好之后，nerdtree就会在孤零零一个人的时候，悄悄地退去。</p><p>Nerdtree的基本操作，附上给你哟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">?: 快速帮助文档</span><br><span class="line">o: 打开一个目录或者打开文件，创建的是buffer，也可以用来打开书签</span><br><span class="line">go: 打开一个文件，但是光标仍然留在NERDTree，创建的是buffer</span><br><span class="line">t: 打开一个文件，创建的是Tab，对书签同样生效</span><br><span class="line">T: 打开一个文件，但是光标仍然留在NERDTree，创建的是Tab，对书签同样生效</span><br><span class="line">i: 水平分割创建文件的窗口，创建的是buffer</span><br><span class="line">gi: 水平分割创建文件的窗口，但是光标仍然留在NERDTree</span><br><span class="line">s: 垂直分割创建文件的窗口，创建的是buffer</span><br><span class="line">gs: 和gi，go类似</span><br><span class="line">x: 收起当前打开的目录</span><br><span class="line">X: 收起所有打开的目录</span><br><span class="line">e: 以文件管理的方式打开选中的目录</span><br><span class="line">D: 删除书签</span><br><span class="line">P: 大写，跳转到当前根路径</span><br><span class="line">p: 小写，跳转到光标所在的上一级路径</span><br><span class="line">K: 跳转到第一个子路径</span><br><span class="line">J: 跳转到最后一个子路径</span><br><span class="line">&lt;C-j&gt;和&lt;C-k&gt;: 在同级目录和文件间移动，忽略子目录和子文件</span><br><span class="line">C: 将根路径设置为光标所在的目录</span><br><span class="line">u: 设置上级目录为根路径</span><br><span class="line">U: 设置上级目录为跟路径，但是维持原来目录打开的状态</span><br><span class="line">r: 刷新光标所在的目录</span><br><span class="line">R: 刷新当前根路径</span><br><span class="line">I: 显示或者不显示隐藏文件</span><br><span class="line">f: 打开和关闭文件过滤器</span><br><span class="line">q: 关闭NERDTree</span><br><span class="line">A: 全屏显示NERDTree，或者关闭全屏</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一章我介绍完用&lt;a href=&quot;https://github.com/VundleVim/Vundle.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vundle&lt;/a&gt;来管理Vim中所有的插件后，今天我又要强推一个Vim的文件管理插件&lt;a href=&quot;https://github.com/scrooloose/nerdtree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nerdtree&lt;/a&gt;,相信所有使用Vim的同学都知道文件管理插件NerdTree,这个几乎是所有拥护Vim的开发人员都会使用的插件，今天就总结一下如何合理的使用NerdTree。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>使用Vundle管理Vim插件</title>
    <link href="http://yoursite.com/2017/12/13/%E4%BD%BF%E7%94%A8Vundle%E7%AE%A1%E7%90%86Vim%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/12/13/使用Vundle管理Vim插件/</id>
    <published>2017-12-13T12:47:27.000Z</published>
    <updated>2017-12-13T12:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>编辑器流派的划分在程序员群体中一直存在着，而我也在尝试了SublimeText、VSCode和Atom这些代表着现代时尚功能的编辑器之后试着使用Vim，其实说到学习使用Vim那已经是很早之前的事情了，但是每次看到各种配置，各种插件，总感觉把折腾Vim的配置是一件很要命的事情，如果把时间用在看书上或许会提高的更多，在这种阿Q的想法下，我始终没有认真的去研究过Vim的配置。</p><p>但是最近也算突然心血来潮，一直在敲前端和PHP的代码，因为有了一点嫌弃移动鼠标的麻烦，开始折腾起了Vim，也想配置出一个自己用得顺手的编辑器。虽然网上有很多完善强大的Vim配置文件，但是总感觉不是自己配置的，再怎么用也不舒服。所以一点一点折腾，一点一点爬坑，总算配置出了一个自己满足自己敲敲前端代码和日常编辑文本功能的编辑器。</p><a id="more"></a><p>而折腾完才发现，Vim的代码补全，编译及错误跳转等插件功能其实还是足够使用的，尤其是我经常在家中和办公室切换电脑使用，各种系统之间跨平台支持做的非常的好，希望是一个可以终生使用的工具。</p><p>对于Vim中如此众多的插件，一个好的插件管理工具是必不可少的，所以今天在这里，我们来讲解一下Vundle这款插件管理器的使用。首先如果你不适用插件管理工具的话，那么你对插件的安装、配置和管理相对会麻烦很多，曾经没使用Vundle的时候，我经常遇到无法安装一些vim插件，但是使用Vundle后你只要在文件中添加一行你的插件名就ok了。</p><p>首先我们要去<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle的github库</a>下载安装Vundle。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure><p>执行上面的命令，将Vundle库下载到本地的<code>~/.vim/bundle/</code>目录下。</p><p>之后编辑我们的<code>.vimrc</code>文件，将下面的文本拷贝到你的<code>.vimrc</code>文件中，并且你可以选择性的删除你暂时不想安装的插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible              <span class="string">" be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                  "</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">" set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">"</span> alternatively, pass a path <span class="built_in">where</span> Vundle should install plugins</span><br><span class="line"><span class="string">"call vundle#begin('~/some/path/here')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> <span class="built_in">let</span> Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" The following are examples of different formats supported.</span></span><br><span class="line"><span class="string">"</span> Keep Plugin commands between vundle<span class="comment">#begin/end.</span></span><br><span class="line"><span class="string">" plugin on GitHub repo</span></span><br><span class="line"><span class="string">Plugin 'tpope/vim-fugitive'</span></span><br><span class="line"><span class="string">"</span> plugin from http://vim-scripts.org/vim/scripts.html</span><br><span class="line"><span class="string">" Plugin 'L9'</span></span><br><span class="line"><span class="string">"</span> Git plugin not hosted on GitHub</span><br><span class="line">Plugin <span class="string">'git://git.wincent.com/command-t.git'</span></span><br><span class="line"><span class="string">" git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="string">Plugin 'file:///home/gmarik/path/to/plugin'</span></span><br><span class="line"><span class="string">"</span> The sparkup vim script is <span class="keyword">in</span> a subdirectory of this repo called vim.</span><br><span class="line"><span class="string">" Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="string">Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;</span></span><br><span class="line"><span class="string">"</span> Install L9 and avoid a Naming conflict <span class="keyword">if</span> you<span class="string">'ve already installed a</span></span><br><span class="line"><span class="string">" different version somewhere else.</span></span><br><span class="line"><span class="string">" Plugin '</span>ascenator/L9<span class="string">', &#123;'</span>name<span class="string">': '</span>newL9<span class="string">'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">" All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            " required</span></span><br><span class="line"><span class="string">filetype plugin indent on    " required</span></span><br><span class="line"><span class="string">" To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="string">"filetype plugin on</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" Brief help</span></span><br><span class="line"><span class="string">" :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="string">" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">" :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="string">" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">" Put your non-Plugin stuff after this line</span></span><br></pre></td></tr></table></figure><p>类似于<code>Plugin &#39;tpope/vim-fugitive&#39;</code>这样的一行语句，就是安装一个新的插件，例如此行为安装<code>vim-fugitive</code>插件，例如这是一个Vim的Git相关插件，利用他可以很方便的查看对于文件的改动，还是很推荐安装使用的。</p><p>之后在我们的终端键入<code>vim</code>跳进vim编辑器的乌干达主界面，并且输入<code>:PluginInstall</code>，则会开始自动的执行插件安装过程，我们说的毫不费劲便是在此体现，一行语句对应一个插件。</p><p>在执行完毕后输入<code>qall</code>退出我们的插件安装界面，至此插件便安装完毕了。</p><p>至于怎么移除插件呢，同样是在<code>.vimrc</code>文件中删除对应的语句，并且在vim编辑器的界面，输入<code>PluginClean</code>就完成插件的清理了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编辑器流派的划分在程序员群体中一直存在着，而我也在尝试了SublimeText、VSCode和Atom这些代表着现代时尚功能的编辑器之后试着使用Vim，其实说到学习使用Vim那已经是很早之前的事情了，但是每次看到各种配置，各种插件，总感觉把折腾Vim的配置是一件很要命的事情，如果把时间用在看书上或许会提高的更多，在这种阿Q的想法下，我始终没有认真的去研究过Vim的配置。&lt;/p&gt;
&lt;p&gt;但是最近也算突然心血来潮，一直在敲前端和PHP的代码，因为有了一点嫌弃移动鼠标的麻烦，开始折腾起了Vim，也想配置出一个自己用得顺手的编辑器。虽然网上有很多完善强大的Vim配置文件，但是总感觉不是自己配置的，再怎么用也不舒服。所以一点一点折腾，一点一点爬坑，总算配置出了一个自己满足自己敲敲前端代码和日常编辑文本功能的编辑器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>反转单向链表</title>
    <link href="http://yoursite.com/2017/11/24/%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/11/24/反转单向链表/</id>
    <published>2017-11-24T11:06:51.000Z</published>
    <updated>2017-11-24T11:12:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>单向链表的反转是一个非常常见的链表类面试题，我在刷leetcode的过程中，发现了有许多链表题目的解法，都是以反转链表为基础进行的。所以我觉得有必要记录一下。</p><p>首先先用一张图来理解单链表的反转。</p><p><img src="https://originalix.github.io/assets/img/1.png" alt=""></p><p><img src="https://originalix.github.io/assets/img/2.png" alt=""></p><p>单链表的反转，就如上图一样，而单链表的反转也有几种方式，今天我主要是想记录我用得最频繁的迭代的方式。</p><a id="more"></a><p>先来看一下链表节点的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是最基础的一个链表节点，而反转链表的代码，其实非常的短，关键点就在于理解这几行代码究竟让链表产生了什么变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到四行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">next = head.next; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">head.next = pre;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">pre = head;       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">head = next;      <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>第一行代码：<code>next = head.next;</code><br>将head.next赋值给next变量，也就是说next指向了节点2，先将节点2保存起来。</p><p>第二行代码： <code>head.next = pre;</code><br>将pre变量赋值给了head.next，即节点1指向了null。</p><p>第三行代码: <code>pre = head;</code><br>将head赋值给了pre，即pre指向节点1，将节点1设为“上一个节点”。</p><p>第四行代码：<code>head = next;</code><br>将next赋值给head，即head指向了节点2。将节点2设置为“头结点”。</p><p>一次循环的具体过程就是这样。</p><p>所以总结一下单链表的反转：</p><ul><li>保存当前头结点的下个节点。</li><li>将当前头结点的下一个节点指向“上一个节点”，这一步是实现了反转。</li><li>将当前头结点设置为“上一个节点”。</li><li>将保存的下一个节点设置为头结点。</li></ul><p>这样说起来确实有点拗口，但是我推荐大家在做链表类题目和理解链表的具体行为时，用一张纸和笔来辅助自己写写画画，相信很快你就会弄懂链表的具体思路的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单向链表的反转是一个非常常见的链表类面试题，我在刷leetcode的过程中，发现了有许多链表题目的解法，都是以反转链表为基础进行的。所以我觉得有必要记录一下。&lt;/p&gt;
&lt;p&gt;首先先用一张图来理解单链表的反转。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://originalix.github.io/assets/img/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://originalix.github.io/assets/img/2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;单链表的反转，就如上图一样，而单链表的反转也有几种方式，今天我主要是想记录我用得最频繁的迭代的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——最短路径Dijkstra算法</title>
    <link href="http://yoursite.com/2017/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95(C++%E5%92%8CJava%E5%AE%9E%E7%8E%B0)/"/>
    <id>http://yoursite.com/2017/10/16/数据结构——最短路径Dijkstra算法(C++和Java实现)/</id>
    <published>2017-10-16T13:52:48.000Z</published>
    <updated>2017-10-16T23:15:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇博文里，我记录了最小生成树的算法实现，而在这篇里，我们来讲讲查找最短路径的算法，Dijkstra算法。</p><p>Dijkstra’s algorithm常用于路由算法或者作为其他图算法的一个子模块。距离来说，如果我们将图的顶点理解为每个城市，而边上的权重表示城市间开车行径的路径，该算法可以用来找到两个城市之间的最短路径。</p><a id="more"></a><p>Dijkstra算法是通过为每个顶点v保留目前为止所找到的从s到v的最短路径来工作的。初始时，原点s的路径权重被赋为0(d[s] = 0)。若对于顶点s存在能直接到达的边，则比较路径的长度，如果路径更短则更新存储的值，当算法结束时，d[v]中存储的便是从s到v的最短路径，或者如果路径不存在的话则是无法访问，用marked数组来记录从s到点v是否存在路径。下面我们来看Dijkstra算法的代码实现，首先是C++版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IndexMinHeap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法求最短路径</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                        <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">int</span> s;                           <span class="comment">// 起始点</span></span><br><span class="line">    Weight *distTo;                  <span class="comment">// distTo[i]存储从起始点s到i的最短路径长度</span></span><br><span class="line">    <span class="keyword">bool</span> *marked;                    <span class="comment">// 标记数组，在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt; from;     <span class="comment">// from[i]记录最短路径中，到达i点的边是哪一条</span></span><br><span class="line">                                     <span class="comment">// 可以用来恢复整个最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用Dijkstra算法求最短路径</span></span><br><span class="line">    Dijkstra(Graph &amp;graph, <span class="keyword">int</span> s):G(graph) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() );</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Weight[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            distTo[i] = Weight();</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            from.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用索引堆记录当前找到的到达每个顶点的最短距离</span></span><br><span class="line">        IndexMinHeap&lt;Weight&gt; ipq(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于起始点s进行初始化</span></span><br><span class="line">        distTo[s] = Weight();</span><br><span class="line">        from[s] = <span class="keyword">new</span> Edge&lt;Weight&gt;(s, s, <span class="number">0</span>);</span><br><span class="line">        ipq.insert(s, distTo[s]);</span><br><span class="line">        marked[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>( !ipq.isEmpty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            <span class="comment">// distTo[v] 就是s到v的最短距离</span></span><br><span class="line">            marked[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 对v的所有相邻节点进行更新</span></span><br><span class="line">            <span class="keyword">typename</span> Graph::<span class="function">adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> ( Edge&lt;Weight&gt; *e = adj.begin(); !adj.end(); e = adj.next() ) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = e-&gt;other(v);</span><br><span class="line">                <span class="comment">// 如果从s点到w点的最短路径还没有找到</span></span><br><span class="line">                <span class="keyword">if</span> ( !marked[w] ) &#123;</span><br><span class="line">                    <span class="comment">// 如果w点以前没有访问过</span></span><br><span class="line">                    <span class="comment">// 或者访问过，但是通过当前的v点到w点距离更短，则进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> ( from[w] == <span class="literal">NULL</span> || distTo[v] + e-&gt;wt() &lt; distTo[w] ) &#123;</span><br><span class="line">                        distTo[w] = distTo[v] + e-&gt;wt();</span><br><span class="line">                        from[w] = e;</span><br><span class="line">                        <span class="keyword">if</span> ( ipq.contain(w) )</span><br><span class="line">                            ipq.change( w, distTo[w] );</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            ipq.insert( w, distTo[w] );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Dijkstra() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] distTo;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">        <span class="keyword">delete</span> from[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function">Weight <span class="title">shortestPathTo</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        assert( hasPathTo(w) );</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathTo</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找从s到w的最短路径，将整个路径经过的边存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shortestPath</span><span class="params">( <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; &amp;vec )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        assert( hasPathTo(w) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径，存放在栈中</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">        Edge&lt;Weight&gt; *e = from[w];</span><br><span class="line">        <span class="keyword">while</span>(e-&gt;v() != <span class="keyword">this</span>-&gt;s) &#123;</span><br><span class="line">            s.push(e);</span><br><span class="line">            e = from[e-&gt;v()];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.push(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素，获得顺序的从s到w的路径</span></span><br><span class="line">        <span class="keyword">while</span>( !s.empty() ) &#123;</span><br><span class="line">            e = s.top();</span><br><span class="line">            vec.push_back(*e);</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        assert( hasPathTo(w) );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; vec;</span><br><span class="line">        shortestPath( w, vec );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i].v() &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">            <span class="keyword">if</span> ( i == vec.size() - <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vec[i].w() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后是java版本的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra算法求最短路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph G;      <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;                <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">private</span> Number[] distTo;      <span class="comment">// distTo[i]存储从起始点s到点i的最短路径长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;     <span class="comment">// 标记数组，在算法运行过程中标记节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[] from;  <span class="comment">// 可以用来恢复整个最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用Dijkstra算法求最短路径</span></span><br><span class="line">    Dijkstra(WeightedGraph graph, <span class="keyword">int</span> s) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        <span class="keyword">this</span>.G = graph;</span><br><span class="line">        <span class="keyword">assert</span> s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V();</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Number[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            distTo[i] = <span class="number">0.0</span>;</span><br><span class="line">            marked[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用索引堆记录当前找到的每个到达顶点的最短距离                                                                     iikkkkkk</span></span><br><span class="line">        IndexMinHeap&lt;Weight&gt; ipq = <span class="keyword">new</span> IndexMinHeap&lt;Weight&gt;(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于起始点s进行初始化</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        from[s] = <span class="keyword">new</span> Edge&lt;Weight&gt;(s, s, (Weight)(Number)(<span class="number">0.0</span>));</span><br><span class="line">        ipq.insert(s, (Weight) distTo[s]);</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!ipq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// distTo[v]就是s到v的最短距离</span></span><br><span class="line">            marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对v的所有相邻节点进行更新</span></span><br><span class="line">            <span class="keyword">for</span> (Object item : G.adj(v)) &#123;</span><br><span class="line">                Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">                <span class="keyword">int</span> w = e.other(v);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果s点到w点的最短路径还没有找到</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果w点以前没有访问过</span></span><br><span class="line">                    <span class="comment">// 或者访问过，但是通过当前v点到w点的距离g更短，则进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> (from[w] == <span class="keyword">null</span> || distTo[v].doubleValue() + e.wt().doubleValue() &lt; distTo[w].doubleValue()) &#123;</span><br><span class="line">                        distTo[w] = distTo[v].doubleValue() + e.wt().doubleValue();</span><br><span class="line">                        from[w] = e;</span><br><span class="line">                        <span class="keyword">if</span> ( ipq.contain(w) ) &#123;</span><br><span class="line">                            ipq.change(w, (Weight) distTo[w]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ipq.insert(w, (Weight) distTo[w]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">shortestPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasPathTo</span><span class="params">(w)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找从s点到w点的最短路径，将整个路径存放在vec中</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; shortestPath(<span class="keyword">int</span> w) &#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasPathTo</span><span class="params">(w)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过from数组逆向查找从s到w的路径，存放到栈中</span></span><br><span class="line">        Stack&lt;Edge&lt;Weight&gt;&gt; s = <span class="keyword">new</span> Stack&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">        Edge&lt;Weight&gt; e = from[w];</span><br><span class="line">        <span class="keyword">while</span> (e.v() != <span class="keyword">this</span>.s) &#123;</span><br><span class="line">            s.push(e);</span><br><span class="line">            e = from[e.v()];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.push(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素，获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; res = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            e = s.pop();</span><br><span class="line">            res.add(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasPathTo</span><span class="params">(w)</span></span>;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; path =  shortestPath(w);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; path.size() ; i ++ )&#123;</span><br><span class="line">            System.out.print( path.elementAt(i).v() + <span class="string">" -&gt; "</span>);</span><br><span class="line">            <span class="keyword">if</span>( i == path.size()-<span class="number">1</span> )</span><br><span class="line">                System.out.println(path.elementAt(i).w());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇博文里，我记录了最小生成树的算法实现，而在这篇里，我们来讲讲查找最短路径的算法，Dijkstra算法。&lt;/p&gt;
&lt;p&gt;Dijkstra’s algorithm常用于路由算法或者作为其他图算法的一个子模块。距离来说，如果我们将图的顶点理解为每个城市，而边上的权重表示城市间开车行径的路径，该算法可以用来找到两个城市之间的最短路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最小生成树" scheme="http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——最小生成树(C++和Java实现)</title>
    <link href="http://yoursite.com/2017/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(C++%E5%92%8CJava%E5%AE%9E%E7%8E%B0)/"/>
    <id>http://yoursite.com/2017/10/09/数据结构——最小生成树(C++和Java实现)/</id>
    <published>2017-10-09T13:30:33.000Z</published>
    <updated>2017-10-09T13:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>快要一整个月没有更新博客了，之前的几周每周都想着要写，但是最后时间还是排不开，最近的状态是一直在写代码，一直在怼工作的需求，顺便刷刷算法题，国庆则是没心没肺的玩了七八天，时间这么一分摊，写博客的时间总是挤不出来，罪过罪过。</p><p>其实数据结构的系列一直也没有写到头，之后还打算写一个<code>Leetcode</code>刷题系列，最近刷的题越多，越是感叹某些题目的解法精妙。</p><p>今天就接着上个月的来讲讲最小生成树的算法吧。</p><a id="more"></a><p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。最小生成树其实是最小权重生成树的简称。</p><p>一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或等于其他生成树的边的权值之和。广义上而言，对于非联通无向图来说，它的每一连通分量同样有最小生成树。</p><p>以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有意最小的生成树能使布线成本最低。</p><p>简单点说有几个城市你要设计一个线路，这个线路能走完所有的这几个城市，而且路程最短，这个线路就是最小生成树的含义。</p><p>所以从上面的例子可以看出来，最小生成树这个算法，对于解决生活实际问题，是一个很重要的存在。下面我们看看最小生成树的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IndexMinHeap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用优化的Prim算法求图的最小生成树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                         <span class="comment">// 图的引用</span></span><br><span class="line">    IndexMinHeap&lt;Weight&gt; ipq;         <span class="comment">// 最小索引堆，算法辅助数据结构</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt;* &gt; edgeTo;   <span class="comment">// 访问的点所对应的边，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">bool</span>* marked;                     <span class="comment">// 标记数组，在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; mst;       <span class="comment">// 最小生成树所包含的所有边</span></span><br><span class="line">    Weight mstWeight;                 <span class="comment">// 最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点v</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">( <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">        assert( !marked[v] );</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typename</span> Graph::<span class="function">adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.begin(); !adj.end(); e = adj.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e-&gt;other(v);</span><br><span class="line">            <span class="comment">// 如果另一个端点未被访问</span></span><br><span class="line">            <span class="keyword">if</span> ( !marked[w] ) &#123;</span><br><span class="line">                <span class="comment">// 如果从没有考虑过这个端点，直接将这个端点和与之相连的边加入索引堆</span></span><br><span class="line">                <span class="keyword">if</span> ( !edgeTo[w] ) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.insert(w, e-&gt;wt());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果曾经考虑过这个端点，但现在的边比之前的边更短，则进行替换</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( e-&gt;wt() &lt; edgeTo[w]-&gt;wt() ) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.change(w, e-&gt;wt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    PrimMST(Graph &amp;graph):G(graph), ipq(IndexMinHeap&lt;<span class="keyword">double</span>&gt;(graph.V())) &#123;</span><br><span class="line"></span><br><span class="line">        assert( graph.E() &gt;= <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            edgeTo.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mst.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>( !ipq.isEmpty() ) &#123;</span><br><span class="line">            <span class="comment">// 使用最小索引堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            <span class="comment">// 最小索引堆中存储的是点的索引，通过点的索引找到相对应的边</span></span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            assert ( edgeTo[v] );</span><br><span class="line">            mst.push_back( *edgeTo[v] );</span><br><span class="line">            visit( v );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mstWeight = mst[<span class="number">0</span>].wt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mst.size(); i++) &#123;</span><br><span class="line">            mstWeight += mst[i].wt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~PrimMST() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; mstEdges() &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的是C++版本的最小生成树Prim MST算法，其中我引进了<code>Edge</code>这个类的数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EDGE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDGE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b;       <span class="comment">// 边的两个端点</span></span><br><span class="line">    Weight weight;  <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Weight weight) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空的构造函数，所有的成员变量都取默认值</span></span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Edge() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">v</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;  <span class="comment">// 返回第一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> b; &#125;  <span class="comment">// 返回第二个顶点</span></span><br><span class="line">    <span class="function">Weight <span class="title">wt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> weight; &#125;  <span class="comment">// 返回权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定一个顶点，返回另一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">        assert( x == a || x == b);</span><br><span class="line">        <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出边的信息</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Edge &amp;e) &#123;</span><br><span class="line">        os &lt;&lt; e.a &lt;&lt; <span class="string">"-"</span> &lt;&lt; e.b &lt;&lt; <span class="string">": "</span> &lt;&lt; e.weight;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的大小比较，是对边的权值的大小比较</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt;= e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt;= e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight == e.wt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//EDGE_H</span></span></span><br></pre></td></tr></table></figure><p>接下来放上<code>Java</code>版本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeightedGraph&lt;Weight&gt; G;        <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinHeap&lt;Weight&gt; ipq;       <span class="comment">// 最小索引堆，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[] edgeTo;          <span class="comment">// 访问的点所对应的边，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst;       <span class="comment">// 标记数组，在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;               <span class="comment">// 最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;               <span class="comment">// 最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(WeightedGraph graph)</span> </span>&#123;</span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">assert</span> graph.E() &gt;= <span class="number">1</span>;</span><br><span class="line">        ipq = <span class="keyword">new</span> IndexMinHeap&lt;Weight&gt;(graph.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            marked[i] = <span class="keyword">false</span>;</span><br><span class="line">            edgeTo[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mst = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!ipq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 使用最小索引堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            <span class="comment">// 最小索引堆中存储的是点的索引，通过点的索引找到相对应的边</span></span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            <span class="keyword">assert</span> (edgeTo[v] != <span class="keyword">null</span>);</span><br><span class="line">            mst.add(edgeTo[v]);</span><br><span class="line">            visit(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mst.size(); i++) &#123;</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点v</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (!marked[v]);</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将和节点v相连接的未访问的另一端点，和与之相连接的边，放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span> (Object item : G.adj(v)) &#123;</span><br><span class="line">            Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;)item;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="comment">// 如果边的另一个端点未被访问</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                <span class="comment">// 如果从没有考虑过这个端点，直接将这个端点和与之相连接的边加入索引堆</span></span><br><span class="line">                <span class="keyword">if</span> (edgeTo[w] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.insert(w, e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果曾经考虑过这个端点，但现在的边比之前考虑的边更短，则进行替换</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e.wt().compareTo(edgeTo[w].wt()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.change(w, e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges() &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中Edge的数据结构如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&lt;<span class="title">Weight</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;          <span class="comment">// 边的两个端点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span> Weight weight;  <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Weight weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Edge&lt;Weight&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = e.a;</span><br><span class="line">        <span class="keyword">this</span>.b = e.b;</span><br><span class="line">        <span class="keyword">this</span>.weight = e.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">v</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;  <span class="comment">// 返回第一个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;  <span class="comment">// 返回第二个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weight <span class="title">wt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; <span class="comment">// 返回权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定一个顶点，返回另一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (x == a || x == b);</span><br><span class="line">        <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出边的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> + a + <span class="string">"-"</span> + b + <span class="string">": "</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 边之间的比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> that 另一个边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weight.compareTo(that.wt()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight.compareTo(that.wt()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只要找到txt格式的测试用例，就能很轻易的测试出我们的最小生成树是否合格, 并且能很清晰的打印出最小成成树的路径，具体的测试用例可以去我的Github里找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快要一整个月没有更新博客了，之前的几周每周都想着要写，但是最后时间还是排不开，最近的状态是一直在写代码，一直在怼工作的需求，顺便刷刷算法题，国庆则是没心没肺的玩了七八天，时间这么一分摊，写博客的时间总是挤不出来，罪过罪过。&lt;/p&gt;
&lt;p&gt;其实数据结构的系列一直也没有写到头，之后还打算写一个&lt;code&gt;Leetcode&lt;/code&gt;刷题系列，最近刷的题越多，越是感叹某些题目的解法精妙。&lt;/p&gt;
&lt;p&gt;今天就接着上个月的来讲讲最小生成树的算法吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最小生成树" scheme="http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——无权图的路径问题(C++和java实现)</title>
    <link href="http://yoursite.com/2017/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98(C++%E5%92%8Cjava%E5%AE%9E%E7%8E%B0)/"/>
    <id>http://yoursite.com/2017/09/11/数据结构——无权图的路径问题(C++和java实现)/</id>
    <published>2017-09-11T06:20:32.000Z</published>
    <updated>2017-12-14T05:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>好像又是接近半个月没有更新，这半个月忙着结婚的各项事情，本来预计的学习任务也拖拖拉拉，进度缓慢。吐槽一句，拍婚纱照真的是最非常非常累的一件事情，不想再有下次了。</p><p>好吧，言归正传，今天就在这周缓慢的学习进度中，抽取出来一个比较有代表性的知识点，记录一下吧。</p><p>首先，首次接触图这个类型的数据结构，我们先来看一下图的定义，了解一下到底什么是图。</p><a id="more"></a><p>图是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为:G(V,E), 其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>接下来我们把图的定义与线性表定义的进行一下对比，让我们来更好的体会一下图的各种定义与其他数据结构的差异:</p><ul><li>线性表中，我们把数据元素叫做元素，树种将数据元素叫结点，在图中的数据元素，我们则称之为顶点。</li><li>线性表中没有数据元素，称为空表。树种可以没有结点，叫做空树。但是在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V是有穷非空的。</li><li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li></ul><p>图的定义我们就暂时讲到这里，更细致的定义希望大家自己在网络或者书籍中获取资料，毕竟我写的再多，也不如教科书详尽，今天我们就来讲一个图的应用，关于路径查找的问题。在这里我想先说明，我们的路径查找是一种针对无向图的路径查找，比如给出起始点A，查询顶点A至顶点B是否有路径，若是有路径，则打印出A至B的路径。而这个路径，我们寻找的不一定是最短路径。</p><p>其实分析这个问题就可以知道，这是对图的深度优先遍历(Depth-First-Search 简称DFS)的一个应用，若是我们能实现了图的深度优先遍历，那么查找路径的问题也就迎刃而解。</p><p>接下来就先给出C++的代码，来展示解决查询路径问题的思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径查询</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G; <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">int</span> s;    <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">bool</span>* visited; <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">int</span>* from; <span class="comment">// 记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typename</span> Graph::<span class="function">adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、寻路算法、寻找图graph从s点到其他点的路径</span></span><br><span class="line">    Path(Graph &amp;graph, <span class="keyword">int</span> s): G(graph) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻路算法</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Path() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询s点到w点的路径，存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">( <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec )</span> </span>&#123;</span><br><span class="line">        assert( hasPath(w) );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径，存放在栈中</span></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素，获得顺序从s到w的路径</span></span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span> ( !<span class="built_in">stack</span>.empty() ) &#123;</span><br><span class="line">            vec.push_back( <span class="built_in">stack</span>.top() );</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123; </span><br><span class="line">        assert( hasPath(w) );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w, vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span> (i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br>通过上面的代码可以得知，我们首先在构造函数中传入我们的图数据结构graph，以及我们标记的起始点S。而通过<code>showPath()</code>函数我们能够展示起始点S至任意点的路径，测试代码就如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    ReadGraph&lt;SparseGraph&gt; readGraph(g, filename);</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较使用深度优先遍历和广度优先遍历获得路径的不同</span></span><br><span class="line">    <span class="comment">// 广度优先遍历获得的是无权图的最短路径</span></span><br><span class="line">    Path&lt;SparseGraph&gt; dfs(g, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS : "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    ShortestPath&lt;SparseGraph&gt; bfs(g, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS : "</span>;</span><br><span class="line">    bfs.showPath(<span class="number">6</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Java版本的代码也是类似，只是某些函数的返回值变化了一点，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Graph G;  <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;  <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] from;  <span class="comment">// 记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，寻路算法，寻找图graph从点s到其他点的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 寻路起始点s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Path</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> s &gt;= <span class="number">0</span> &amp;&amp; s &lt; graph.V();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.G = graph;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 从v点开始深度优先遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点是否存在路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询点s到点w的路径，存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector&lt;Integer&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>(hasPath(w));</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span> (p != -<span class="number">1</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            vec.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从点s到点w的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (hasPath(w));</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = path(w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            System.out.print(vec.elementAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i == vec.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">" -&gt; "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天的无权图的路径问题就讲解到这里，之后的知识点等学习整理之后，再行记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好像又是接近半个月没有更新，这半个月忙着结婚的各项事情，本来预计的学习任务也拖拖拉拉，进度缓慢。吐槽一句，拍婚纱照真的是最非常非常累的一件事情，不想再有下次了。&lt;/p&gt;
&lt;p&gt;好吧，言归正传，今天就在这周缓慢的学习进度中，抽取出来一个比较有代表性的知识点，记录一下吧。&lt;/p&gt;
&lt;p&gt;首先，首次接触图这个类型的数据结构，我们先来看一下图的定义，了解一下到底什么是图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——最大索引堆(C++和Java实现)</title>
    <link href="http://yoursite.com/2017/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E7%B4%A2%E5%BC%95%E5%A0%86(C++%E5%92%8CJava%E5%AE%9E%E7%8E%B0)/"/>
    <id>http://yoursite.com/2017/08/27/数据结构——最大索引堆(C++和Java实现)/</id>
    <published>2017-08-27T13:17:46.000Z</published>
    <updated>2017-08-27T13:19:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇博客中，记录了优先队列——堆这个数据结构的实现，并且关于堆的性质我也在上文中介绍过，堆能用来进行排序，堆排序具有快速(复杂度O(NlogN))，稳定的特点，尤其是非常稳定，因此适用于某些需要排序稳定性的场合。</p><p>但是呢，普通的二叉堆有两个缺陷：</p><ul><li>在对的元素体积非常大的情况下，经常性的移动元素是低效的。</li><li>如果在堆的使用过程中，堆中的元素的值要改变，则普通堆对此无能为力，简单的说，如果一个元素如果进入堆之后，它的值就不能改变了，否则会影响堆的性质。</li></ul><p>第一个缺陷还能用类似于指针排序的技术解决，但是第二个缺陷不采用特殊的技术是没有办法解决的，然而在一些场合，堆中元素的值确实需要改变。于是乎，索引堆这个数据结构就在这里应运而生了。</p><a id="more"></a><p>所谓索引堆，简单的说，就是在堆里头存放的不是数据，而是数据所在的数组的索引，也就是下标，根据数据的某种优先级来调整各个元素对应的下标在堆中的位置。本质上来说，索引堆也是堆，提供堆的接口。</p><p>那么接下来，我们就来尝试用<code>C++</code>和<code>Java</code>两种语言来实现索引堆，注释在代码中写的比较详细。</p><p>C++版如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> *indexes;</span><br><span class="line">    <span class="keyword">int</span> *reverse;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[ indexes[k/<span class="number">2</span>] ] &lt; data[ indexes[k] ]) &#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>], indexes[k] );</span><br><span class="line">            reverse[indexes[k / <span class="number">2</span>]] = k / <span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[ indexes[j] ] &lt; data[ indexes[j+<span class="number">1</span>] ])</span><br><span class="line">                <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[ indexes[k] ] &gt; data[ indexes[j] ])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap( indexes[k], indexes[j] );</span><br><span class="line">            reverse[ indexes[k] ] = k;</span><br><span class="line">            reverse[ indexes[j] ] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity + <span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IndexMaxHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~IndexMaxHeap() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span> </span>&#123;</span><br><span class="line">        assert(count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        assert(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        assert( !contain(i) );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Item ret = data[ indexes[<span class="number">1</span>] ];</span><br><span class="line"></span><br><span class="line">        swap( indexes[<span class="number">1</span>], indexes[count] );</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        shiftDown( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>], indexes[count] );</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">        assert(contain(i));</span><br><span class="line">        <span class="keyword">return</span> data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i, Item newItem )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        assert(contain(i));</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到indexes[j] = i, j 表示 data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line">        <span class="comment">// for ( int j = 1; j &lt;= count; j++ ) &#123;</span></span><br><span class="line">        <span class="comment">//     if (indexes[j] == i) &#123;</span></span><br><span class="line">        <span class="comment">//         shiftUp(j);</span></span><br><span class="line">        <span class="comment">//         shiftDown(j);</span></span><br><span class="line">        <span class="comment">//         return;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有了 reverse 之后,</span></span><br><span class="line">        <span class="comment">// 我们可以非常简单的通过reverse直接定位索引i在indexes中的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = reverse[i];</span><br><span class="line">        shiftUp(j);</span><br><span class="line">        shiftDown(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index和反向数组reverse</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">testIndexesAndReverseIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> *copyReverseIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ )&#123;</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line">            copyReverseIndexes[i] = reverse[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = copyReverseIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(copyIndexes, copyIndexes + count + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(copyReverseIndexes, copyReverseIndexes + count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引和反向索引进行排序后,</span></span><br><span class="line">        <span class="comment">// 两个数组都应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyIndexes[i] ||</span><br><span class="line">                    copyReverseIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyReverseIndexes[i] )&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] copyIndexes;</span><br><span class="line">        <span class="keyword">delete</span>[] copyReverseIndexes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( reverse[ indexes[i] ] != i )&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Java版本的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大索引堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;    <span class="comment">// 最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] indexes;  <span class="comment">// 最大索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] reverse;  <span class="comment">// 最大索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = (Item[]) <span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="keyword">assert</span> (i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        <span class="keyword">assert</span> ( !contain(i) );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count + <span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Item ret = data[ indexes[<span class="number">1</span>] ];</span><br><span class="line">        swap(indexes, <span class="number">1</span>, count);</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap(indexes, <span class="number">1</span>, count);</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[ indexes[k / <span class="number">2</span>] ].compareTo( data[ indexes[k] ] ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(indexes, k / <span class="number">2</span>, k);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[ indexes[j] ].compareTo( data[ indexes[j+<span class="number">1</span>] ] ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data[ indexes[k] ].compareTo(data[ indexes[j] ]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(indexes, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换索引堆中的索引i和j</span></span><br><span class="line">    <span class="comment">// 由于有了反向索引reverse数组，</span></span><br><span class="line">    <span class="comment">// indexes数组发生改变以后， 相应的就需要维护reverse数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line"></span><br><span class="line">        reverse[ indexes[i] ] = i;</span><br><span class="line">        reverse[ indexes[j] ] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (contain(i));</span><br><span class="line">        <span class="keyword">return</span> data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, Item newItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>(contain(i));</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = reverse[i];</span><br><span class="line">        shiftUp(j);</span><br><span class="line">        shiftDown(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index和反向数组reverse</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">testIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] copyReverseIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ ) &#123;</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line">            copyReverseIndexes[i] = reverse[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        copyReverseIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(copyIndexes);</span><br><span class="line">        Arrays.sort(copyReverseIndexes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引和反向索引进行排序后,</span></span><br><span class="line">        <span class="comment">// 两个数组都应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i-<span class="number">1</span>] + <span class="number">1</span> != copyIndexes[i] ||</span><br><span class="line">                    copyReverseIndexes[i-<span class="number">1</span>] + <span class="number">1</span> != copyReverseIndexes[i] )&#123;</span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            System.out.println(<span class="string">"Error!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">        IndexMaxHeap&lt;Integer&gt; indexMaxHeap = <span class="keyword">new</span> IndexMaxHeap&lt;Integer&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            indexMaxHeap.insert(i, (<span class="keyword">int</span>) (Math.random() * N));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> indexMaxHeap.testIndexes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇博客中，记录了优先队列——堆这个数据结构的实现，并且关于堆的性质我也在上文中介绍过，堆能用来进行排序，堆排序具有快速(复杂度O(NlogN))，稳定的特点，尤其是非常稳定，因此适用于某些需要排序稳定性的场合。&lt;/p&gt;
&lt;p&gt;但是呢，普通的二叉堆有两个缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在对的元素体积非常大的情况下，经常性的移动元素是低效的。&lt;/li&gt;
&lt;li&gt;如果在堆的使用过程中，堆中的元素的值要改变，则普通堆对此无能为力，简单的说，如果一个元素如果进入堆之后，它的值就不能改变了，否则会影响堆的性质。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个缺陷还能用类似于指针排序的技术解决，但是第二个缺陷不采用特殊的技术是没有办法解决的，然而在一些场合，堆中元素的值确实需要改变。于是乎，索引堆这个数据结构就在这里应运而生了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="索引堆" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——优先队列(C++和Java实现)</title>
    <link href="http://yoursite.com/2017/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-C-%E5%92%8CJava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/08/18/数据结构——优先队列-C-和Java实现/</id>
    <published>2017-08-18T13:10:11.000Z</published>
    <updated>2017-08-18T13:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>十几天没有更新自己的博客了，因为目前在算法和数据结构的学习中，碰到了一些问题，例如之前就在优先队列，堆这个数据结构面前，感觉到有点吃不透概念，而使用的那本书上写的实在太抽象了，所以又查找了很多资料，最终对优先队列这个数据结构有了一定的了解。花了点时间才啃下来的知识，当然要把它记录下来了，所以今天就来回顾一下优先队列。</p><a id="more"></a><p>优先队列也是一种抽象数据类型。优先队列中的每个元素都有各自的优先级。这个概念其实打几个比方会理解的比较快一点。比如我们人人都用过的windows系统，当我们打开任务管理器的时候，每个任务的优先级别是不同的，而操作系统会选择优先级别最高的任务先执行，同时我们也能在选项里标记任务的优先级。再比如夜班的急诊大夫，如果之前来了两三个感冒发烧的病人正在排队看病，这时候，匆匆忙忙抬进来一个心脏病突发的病人，那我们的大夫当然要先去治疗心脏病突发的病人了。优先队列也是一个道理，优先处理优先级别高的数据或者任务。</p><p>优先级最高的元素最先得到服务，优先级别相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。</p><p>优先队列至少要支持这些操作：</p><ul><li>插入带优先级的元素。</li><li>取出具有最高优先级的元素。</li><li>查看最高优先级的元素。（O(1)的时间复杂度）</li></ul><p>出于性能的考虑，优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(log n),构造二叉树的时间复杂度为O(nlogn)。</p><p>而从时间复杂度的角度，优先队列其实等价于排序算法。而接下来我们就要用C++和Java两种编程语言来实现优先队列。为什么现在要用两种语言呢，其实仅仅是我在使用了C++写完了数据结构之后，改换Java又实现了一遍，经过测试，代码是通过并满足优先队列的性质的，所以一起放出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k]) &#123;</span><br><span class="line">            swap( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[j] &lt; data[j+<span class="number">1</span>])</span><br><span class="line">                <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[k] &gt; data[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k], data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MaxHeap() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像最大堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        assert(count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        data[ count + <span class="number">1</span> ] = item;</span><br><span class="line">        count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>], data[count] );</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        shiftDown( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上是C++版本的实现，接下来是Java版本的实现，测试代码写在java里面，C++的测试也是一样的用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Item[] data;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，构造一个空堆，可容纳capacity个元素</span></span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值，表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大堆中插入一个新元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        data[count + <span class="number">1</span>] = item;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素，即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line">        swap(<span class="number">1</span>, count);</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown( <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Item item = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="comment">//* 最大堆核心辅助函数</span></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>].compareTo(data[k]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(k/<span class="number">2</span>, k);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[j].compareTo(data[j+<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data[k].compareTo(data[j]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试MaxHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaxHeap&lt;Integer&gt; maxHeap = <span class="keyword">new</span> MaxHeap&lt;Integer&gt;(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            maxHeap.insert( <span class="keyword">new</span> Integer((<span class="keyword">int</span>) (Math.random() * M)) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[N];</span><br><span class="line">        <span class="comment">// 将maxHeap中的数据使用extractMax()取出来</span></span><br><span class="line">        <span class="comment">// 取出来的顺序应该是从大到小排序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保arr数组是从大到小排序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">assert</span> arr[i-<span class="number">1</span>] &gt;= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十几天没有更新自己的博客了，因为目前在算法和数据结构的学习中，碰到了一些问题，例如之前就在优先队列，堆这个数据结构面前，感觉到有点吃不透概念，而使用的那本书上写的实在太抽象了，所以又查找了很多资料，最终对优先队列这个数据结构有了一定的了解。花了点时间才啃下来的知识，当然要把它记录下来了，所以今天就来回顾一下优先队列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="优先队列" scheme="http://yoursite.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——AVL树(C语言)</title>
    <link href="http://yoursite.com/2017/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94AVL%E6%A0%91/"/>
    <id>http://yoursite.com/2017/08/06/数据结构——AVL树/</id>
    <published>2017-08-06T01:30:12.000Z</published>
    <updated>2017-08-06T01:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>AVL(Adelson-Velskii 和 Landis)树是带有平衡条件的二叉查找树。在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(lngn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p><p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或-1的结点被认为是平衡的。带有平衡因子-2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p><a id="more"></a><p>AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的”AVL旋转”。</p><p>以下图标表示的四种情况，就是AVL旋转中常见的四种。（图片用了维基百科的，不确定不开vpn图是否会挂）。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png" alt=""></p><p>下面来看AVL树的操作有哪些:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _AvlTree_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">AvlTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">MakeEmpty</span><span class="params">( AvlTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, AvlTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( AvlTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( AvlTree T )</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">( ElementType X, AvlTree T )</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">( ElementType X, AvlTree T )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">( Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _AvlTree_H */</span></span></span><br></pre></td></tr></table></figure><p>下面是对于上面操作定义的实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AvlTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    AvlTree Left;</span><br><span class="line">    AvlTree Right;</span><br><span class="line">    <span class="keyword">int</span> Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">MakeEmpty</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MakeEmpty(T-&gt;Left);</span><br><span class="line">        MakeEmpty(T-&gt;Right);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算Avl节点高度</span></span><br><span class="line"><span class="comment"> * @param  P 节点P</span></span><br><span class="line"><span class="comment"> * @return 树高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Height</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> P-&gt;Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向左单旋 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotateWithLeft</span><span class="params">(Position K2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position K1;</span><br><span class="line"></span><br><span class="line">    K1 = K2-&gt;Left;</span><br><span class="line">    K2-&gt;Left = K1-&gt;Right;</span><br><span class="line">    K1-&gt;Right = K2;</span><br><span class="line"></span><br><span class="line">    K2-&gt;Height = Max(Height(K2-&gt;Left), Height(K2-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    K1-&gt;Height = Max(Height(K1-&gt;Left), K2-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K1; <span class="comment">/* New Root */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向右单旋  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotateWithRight</span><span class="params">(Position K2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position K1;</span><br><span class="line"></span><br><span class="line">    K1 = K2-&gt;Right;</span><br><span class="line">    K2-&gt;Right = K1-&gt;Left;</span><br><span class="line">    K1-&gt;Left = K2;</span><br><span class="line"></span><br><span class="line">    K2-&gt;Height = Max(Height(K2-&gt;Left), Height(K2-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    K1-&gt;Height = Max(K2-&gt;Height, Height(K1-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K1; <span class="comment">/*New root */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向左双旋 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotateWithLeft</span><span class="params">(Position K3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Rotate between K1 and K2 */</span></span><br><span class="line">    K3-&gt;Left = SingleRotateWithRight(K3-&gt;Left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rotate between K3 and K2 */</span></span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithLeft(K3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向右双旋 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotateWithRight</span><span class="params">(Position K3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    K3-&gt;Right = SingleRotateWithLeft(K3-&gt;Right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithRight(K3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">(ElementType X, AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( struct AvlNode ) );</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Out of space!!!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Element = X;</span><br><span class="line">            T-&gt;Height = <span class="number">0</span>;</span><br><span class="line">            T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element) <span class="comment">/* 左子树插入新节点 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Left = Insert(X, T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;Left) - Height(T-&gt;Right) == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (X &lt; T-&gt;Left-&gt;Element)</span><br><span class="line">                T = SingleRotateWithLeft(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRotateWithLeft(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element) <span class="comment">/* 右子树插入新节点 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Right = Insert(X, T-&gt;Right);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;Right) - Height(T-&gt;Left) == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (X &gt; T-&gt;Right-&gt;Element)</span><br><span class="line">                T = SingleRotateWithRight(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRotateWithRight(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Else X is in the tree alredy; we'll do nothing */</span></span><br><span class="line">    T-&gt;Height = Max(Height(T-&gt;Left), Height(T-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">(ElementType X, AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line">     <span class="keyword">if</span>(T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没找到该元素，无法删除！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element)</span><br><span class="line">         T-&gt;Left = Delete(X, T-&gt;Left);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">         T-&gt;Right = Delete(X, T-&gt;Right);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Left &amp;&amp; T-&gt;Right) &#123; <span class="comment">//要删除的树左右都有儿子</span></span><br><span class="line">         TmpCell = FindMin(T-&gt;Right);   <span class="comment">//用该结点右儿子上最小结点替换该结点，然后与只有一个儿子的操作方法相同</span></span><br><span class="line">         T-&gt;Element = TmpCell-&gt;Element;</span><br><span class="line">         T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         TmpCell = T;        <span class="comment">//要删除的结点只有一个儿子</span></span><br><span class="line">         <span class="keyword">if</span>(T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">             T = T-&gt;Right;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">             T = T-&gt;Left;</span><br><span class="line">         <span class="built_in">free</span>(TmpCell);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找X元素所在的位置 */</span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (X &lt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* search the min element in AvlTree*/</span></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(T-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* search the max element in AvlTree */</span></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMax(T-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> P-&gt;Element;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTravel</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        PreorderTravel(T-&gt;Left);</span><br><span class="line">        PreorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTravel</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InorderTravel(T-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        InorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTravel</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostorderTravel(T-&gt;Left);</span><br><span class="line">        PostorderTravel(T-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印二叉树信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(AvlTree T, ElementType Element, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is root\n"</span>, T-&gt;Element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is %2d's %6s child\n"</span>, T-&gt;Element, Element, direction == <span class="number">1</span> ? <span class="string">"right"</span> : <span class="string">"left"</span>);</span><br><span class="line"></span><br><span class="line">        PrintTree(T-&gt;Left, T-&gt;Element, <span class="number">-1</span>);</span><br><span class="line">        PrintTree(T-&gt;Right, T-&gt;Element, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现完成这些函数后，我们在<code>main</code>函数中对AVL树进行测试:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line"></span><br><span class="line">    AvlTree T;</span><br><span class="line">    Position P;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    T = MakeEmpty(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    T = Insert(<span class="number">21</span>, T);</span><br><span class="line">    T = Insert(<span class="number">2150</span>, T);</span><br><span class="line">    T = Insert(<span class="number">50</span>, T);</span><br><span class="line">    T = Insert(<span class="number">12</span>, T);</span><br><span class="line">    T = Insert(<span class="number">1201</span>, T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Root: %d\n"</span>, T-&gt;Element);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的详细信息: \n"</span>);</span><br><span class="line">    PrintTree(T, T-&gt;Element, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树: \n"</span>);</span><br><span class="line">    PreorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树: \n"</span>);</span><br><span class="line">    InorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树: \n"</span>);</span><br><span class="line">    PostorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大值: %d\n"</span>, FindMax(T)-&gt;Element);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最小值: %d\n"</span>, FindMin(T)-&gt;Element);</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">50</span>, T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的详细信息: \n"</span>);</span><br><span class="line">    PrintTree(T, T-&gt;Element, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL(Adelson-Velskii 和 Landis)树是带有平衡条件的二叉查找树。在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(lngn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。&lt;/p&gt;
&lt;p&gt;节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或-1的结点被认为是平衡的。带有平衡因子-2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="AVL树" scheme="http://yoursite.com/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——二叉查找树(C语言)</title>
    <link href="http://yoursite.com/2017/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://yoursite.com/2017/07/29/数据结构——二叉查找树(C语言)/</id>
    <published>2017-07-29T13:08:33.000Z</published>
    <updated>2017-07-29T13:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉查找树，也称作二叉搜索树，有序二叉树，排序二叉树，而当一棵空树或者具有下列性质的二叉树，就可以被定义为二叉查找树：</p><ul><li><p>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值。</p></li><li><p>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值。</p></li><li><p>任意节点的左、右子树也分别为二叉查找树。</p></li><li><p>没有键值相等的节点。</p></li></ul><p>二叉查找树相比于其他数据结构的优势在查找、插入的时间复杂度较低，为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构,如集合、multiset、关联数组等。对于大量的输入数据，链表的线性访问时间太慢，不宜使用。</p><a id="more"></a><p>下面来看我们为二叉查找树定义的抽象行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Tree_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">SearchTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">( SearchTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, SearchTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( SearchTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( SearchTree T )</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">( ElementType X, SearchTree T )</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">( ElementType X, SearchTree T )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">( Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而对于上述抽象行为的实现，我们先来给出实现代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    SearchTree Left;</span><br><span class="line">    SearchTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MakeEmpty(T-&gt;Left);</span><br><span class="line">        MakeEmpty(T-&gt;Right);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (X &lt; T-&gt;Element )</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> ( T-&gt; Left == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin( T-&gt;Left );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T != <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">while</span>(T-&gt;Right != <span class="literal">NULL</span>)</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create and return a one-node tree */</span></span><br><span class="line">        T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( struct TreeNode ));</span><br><span class="line">        <span class="keyword">if</span> ( T == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Out of space!!!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Element = X;</span><br><span class="line">            T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element)</span><br><span class="line">        T-&gt;Left = Insert(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">        T-&gt;Right = Insert(X, T-&gt;Right);</span><br><span class="line">    <span class="comment">/* Else X is in the tree already; we'll do nothing */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Element not found\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element) <span class="comment">/* Go left */</span></span><br><span class="line">        T-&gt;Right = Delete(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element) <span class="comment">/* Go Right */</span></span><br><span class="line">        T-&gt;Right = Delete(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Left &amp;&amp; T-&gt;Right) <span class="comment">/* Two Children */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Replace with smallest in right subtree */</span></span><br><span class="line">        TmpCell = FindMin(T-&gt;Right);</span><br><span class="line">        T-&gt;Element = TmpCell-&gt;Element;</span><br><span class="line">        T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* One or zero children */</span></span><br><span class="line">    &#123;</span><br><span class="line">        TmpCell = T;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;Left == <span class="literal">NULL</span>) <span class="comment">/* Also handles 0 children */</span></span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        <span class="built_in">free</span>( TmpCell );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P-&gt;Element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTravel</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        PreorderTravel(T-&gt;Left);</span><br><span class="line">        PreorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTravel</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InorderTravel(T-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        InorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTravel</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostorderTravel(T-&gt;Left);</span><br><span class="line">        PostorderTravel(T-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(SearchTree T, ElementType Element, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is root\n"</span>, T-&gt;Element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is %2d's %6s child\n"</span>, T-&gt;Element, Element, direction == <span class="number">1</span> ? <span class="string">"right"</span> : <span class="string">"left"</span>);</span><br><span class="line"></span><br><span class="line">        PrintTree(T-&gt;Left, T-&gt;Element, <span class="number">-1</span>);</span><br><span class="line">        PrintTree(T-&gt;Right, T-&gt;Element, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们对我们的实现代码，在<code>main</code>函数中进行测试:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello Leon\n"</span>);</span><br><span class="line">    SearchTree T;</span><br><span class="line">    MakeEmpty(T);</span><br><span class="line"></span><br><span class="line">    T = Insert(<span class="number">21</span>, T);</span><br><span class="line">    T = Insert(<span class="number">2150</span>, T);</span><br><span class="line">    T = Insert(<span class="number">127</span>, T);</span><br><span class="line">    T = Insert(<span class="number">121</span>, T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的详细信息: \n"</span>);</span><br><span class="line">    PrintTree(T, T-&gt;Element, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树: \n"</span>);</span><br><span class="line">    PreorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树: \n"</span>);</span><br><span class="line">    InorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树: \n"</span>);</span><br><span class="line">    PostorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大值: %d\n"</span>, FindMax(T)-&gt;Element);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最小值: %d\n"</span>, FindMin(T)-&gt;Element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行这个C文件，控制台打印的信息如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Hello wsx</span><br><span class="line">树的详细信息:</span><br><span class="line"><span class="number">21</span> is root</span><br><span class="line"><span class="number">2150</span> is <span class="number">21'</span>s  right child</span><br><span class="line"><span class="number">127</span> is <span class="number">2150'</span>s   left child</span><br><span class="line"><span class="number">121</span> is <span class="number">127'</span>s   left child</span><br><span class="line">前序遍历二叉树:</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">2150</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">121</span></span><br><span class="line">中序遍历二叉树:</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">121</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">2150</span></span><br><span class="line">后序遍历二叉树:</span><br><span class="line"><span class="number">121</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">2150</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line">最大值: <span class="number">2150</span></span><br><span class="line">最小值: <span class="number">21</span></span><br></pre></td></tr></table></figure><p>测试成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉查找树，也称作二叉搜索树，有序二叉树，排序二叉树，而当一棵空树或者具有下列性质的二叉树，就可以被定义为二叉查找树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任意节点的左、右子树也分别为二叉查找树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有键值相等的节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉查找树相比于其他数据结构的优势在查找、插入的时间复杂度较低，为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构,如集合、multiset、关联数组等。对于大量的输入数据，链表的线性访问时间太慢，不宜使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉查找树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——链表的游标实现(C语言)</title>
    <link href="http://yoursite.com/2017/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B8%B8%E6%A0%87%E5%AE%9E%E7%8E%B0-C%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/20/数据结构——链表的游标实现-C语言/</id>
    <published>2017-07-20T00:14:12.000Z</published>
    <updated>2017-07-20T00:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博文我们用指针实现了链表，但是诸如BASIC和FORTRAN等许多语言都不支持指针。如果需要链表而又不能使用指针，这时我们可以使用游标（cursor）实现法来实现链表。</p><p>在链表的实现中有两个重要的特点：</p><ul><li><p>数据存储在一组结构体中。每一个结构体包含有数据以及指向下一个结构体的指针。</p></li><li><p>一个新的结构体可以通过调用malloc而从系统全局内存（global memory）得到，并可以通过free而被释放。</p></li></ul><p>游标法必须能够模仿实现这两条特性 。 下面给出实现代码:</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CursorList_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> PtrToNode;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeCursorSpace</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">( List L )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLast</span><span class="params">( <span class="keyword">const</span> Position P, <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">( ElementType X, List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">( ElementType X, <span class="keyword">const</span> List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( ElementType X, List L, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">( <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Header</span><span class="params">( <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">First</span><span class="params">( <span class="keyword">const</span> List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Advance</span><span class="params">( <span class="keyword">const</span> Position P )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">( <span class="keyword">const</span> Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*_CUrsor_H */</span></span></span><br></pre></td></tr></table></figure><p>可以从上面的代码上看到，链表的游标实现跟链表的接口定义几乎是一样的。</p><p>下面放上实现代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CursorList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SpaceSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Position Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">CursorSpace</span>[ <span class="title">SpaceSize</span> ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the CursorSpace */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitCursorSpace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SpaceSize; i++)</span><br><span class="line">        CursorSpace[i].Next = i == SpaceSize<span class="number">-1</span> ? <span class="number">0</span> : i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">CursorAlloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = CursorSpace[<span class="number">0</span>].Next;</span><br><span class="line">    CursorSpace[<span class="number">0</span>].Next = CursorSpace[P].Next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CursorFree</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CursorSpace[P].Next = CursorSpace[<span class="number">0</span>].Next;</span><br><span class="line">    CursorSpace[<span class="number">0</span>].Next = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if L is empty */</span></span><br><span class="line"><span class="function">Status <span class="title">IsEmpty</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CursorSpace[L].Next == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if P is the last position in list L */</span></span><br><span class="line"><span class="comment">/* Parameter L is unused in this implementation */</span></span><br><span class="line"><span class="function">Status <span class="title">IsLast</span><span class="params">(Position P, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CursorSpace[P].Next == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return Position of X in L; 0 if not found */</span></span><br><span class="line"><span class="comment">/* Uses a header node */</span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = CursorSpace[L].Next;</span><br><span class="line">    <span class="keyword">while</span>(P &amp;&amp; CursorSpace[P].Element != X) &#123;</span><br><span class="line">        P = CursorSpace[P].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete first occurrence of X from a list */</span></span><br><span class="line"><span class="comment">/* Assume use of a header node */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(ElementType X, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P, TmpCell;</span><br><span class="line"></span><br><span class="line">    P = FindPrevious(X, L);</span><br><span class="line">    <span class="keyword">if</span> (!IsLast(P, L))</span><br><span class="line">        TmpCell = CursorSpace[P].Next;</span><br><span class="line">        CursorSpace[P].Next = CursorSpace[TmpCell].Next;</span><br><span class="line">        CursorFree(TmpCell);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the front of the first X of The list */</span></span><br><span class="line"><span class="comment">/* Return 0 if not found */</span></span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">(ElementType X, <span class="keyword">const</span> List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line">    P = L;</span><br><span class="line">    <span class="keyword">while</span>(P &amp;&amp; CursorSpace[CursorSpace[P].Next].Element != X)</span><br><span class="line">    &#123;</span><br><span class="line">        P = CursorSpace[P].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert(after legal position P) */</span></span><br><span class="line"><span class="comment">/* Header implementation assumed */</span></span><br><span class="line"><span class="comment">/* Parameter L is unused in this implemention */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X, List L, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = CursorAlloc();</span><br><span class="line">    <span class="keyword">if</span> (TmpCell == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Out of space!\n"</span>);</span><br><span class="line">    CursorSpace[TmpCell].Element = X;</span><br><span class="line">    CursorSpace[TmpCell].Next = CursorSpace[P].Next;</span><br><span class="line">    CursorSpace[P].Next = TmpCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_list</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = L;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print_list: 链表为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = CursorSpace[L].Next;</span><br><span class="line">    <span class="keyword">while</span>(P != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, \n"</span>, CursorSpace[P].Element);</span><br><span class="line">        P = CursorSpace[P].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitCursorSpace();</span><br><span class="line">    List L = CursorAlloc();</span><br><span class="line">    CursorSpace[L].Next = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">1</span>, L, L);</span><br><span class="line">    Insert(<span class="number">0</span>, L, L);</span><br><span class="line">    Insert(<span class="number">21</span>, L, L);</span><br><span class="line">    Insert(<span class="number">1201</span>, L, L);</span><br><span class="line">    Position P;</span><br><span class="line">    P = Find(<span class="number">21</span>, L);</span><br><span class="line">    <span class="keyword">if</span> (P)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找到元素: %d\n"</span>, CursorSpace[P].Element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"未找到21元素\n"</span>);</span><br><span class="line">    Delete(<span class="number">0</span>, L);</span><br><span class="line">    Delete(<span class="number">1</span>, L);</span><br><span class="line">    print_list(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"检查链表是否为空: %d\n"</span>, IsEmpty(L));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现过程比较简单，最后的main函数是对游标链表的测试。代码直接开箱即用，可以看到测试过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博文我们用指针实现了链表，但是诸如BASIC和FORTRAN等许多语言都不支持指针。如果需要链表而又不能使用指针，这时我们可以使用游标（cursor）实现法来实现链表。&lt;/p&gt;
&lt;p&gt;在链表的实现中有两个重要的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据存储在一组结构体中。每一个结构体包含有数据以及指向下一个结构体的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个新的结构体可以通过调用malloc而从系统全局内存（global memory）得到，并可以通过free而被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;游标法必须能够模仿实现这两条特性 。 下面给出实现代码:&lt;/p&gt;
    
    </summary>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——链表(C语言实现)</title>
    <link href="http://yoursite.com/2017/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0)/"/>
    <id>http://yoursite.com/2017/07/16/数据结构——链表(C语言实现)/</id>
    <published>2017-07-16T13:25:01.000Z</published>
    <updated>2017-07-16T13:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>提起链表，我们每个人都不会陌生，不管对数据结构的掌握如何，都或多或少的听过与用过链表这样的常见的数据结构。链表是线性表的一种，最基础的线性表，在插入与删除数据时，我们需要对表的整体或部分做移动，为了允许表可以不按照线性的顺序存储数据结构，于是链表就应运而生。链表最大的特点就是在每个节点里存储了到下一个节点的指针。由于不必按照顺序存储，链表在插入的时候可以达到O(1)的复杂度，比我们学习的最基本的线性表要快得多。但是在查找一个节点，或者访问特定编号的结点则需要O(N)的时间。</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的有点，同时由于增加了指针域，空间开销较大。不过这在算法与数据结构领域是很常见的，用空间换时间，毕竟鱼和熊掌不可兼得。</p><p>我的链表数据结构是使用C语言来实现的，那么下面来看一下链表的头文件定义了哪些操作。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _List_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">(List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLast</span><span class="params">(Position P, List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">( ElementType X, List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">( ElementType X, List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( ElementType X, List L, Position P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">( List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Header</span><span class="params">( List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">First</span><span class="params">( List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Advance</span><span class="params">( Position P )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">( Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _List_H */</span></span></span><br></pre></td></tr></table></figure><p>下面是对于头结点的实现文件，末尾的<code>main</code>函数中还有针对各类函数的测试方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"List.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Position Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_list</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化链表成功\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">create_list</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = <span class="literal">NULL</span>;</span><br><span class="line">    List p1, p2;</span><br><span class="line">    p1 = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    p2 = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span> || p2 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(p1, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表元素的值: \n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;(p1-&gt;Element));</span><br><span class="line">    p1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1-&gt;Element &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;Next = p1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p2 = p1;</span><br><span class="line"></span><br><span class="line">        p1 = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">NULL</span> || p2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            system(<span class="string">"pause"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(p1, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入链表的值: \n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;(p1-&gt;Element));</span><br><span class="line">        p1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"创建链表成功\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_list</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = L;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print_list: 链表为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"打印链表如下: \n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, \n"</span>, p-&gt;Element);</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">IsEmpty</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">IsLast</span><span class="params">(Position P, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line">    P = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>(P != <span class="literal">NULL</span> &amp;&amp; P-&gt;Element != X)</span><br><span class="line">    &#123;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(ElementType X, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P, TmpCell;</span><br><span class="line"></span><br><span class="line">    P = FindPrevious(X, L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsLast(P, L))</span><br><span class="line">        TmpCell = P-&gt;Next;</span><br><span class="line">        P-&gt;Next = TmpCell-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(TmpCell);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">(ElementType X, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L;</span><br><span class="line">    <span class="keyword">while</span>(P-&gt;Next != <span class="literal">NULL</span> &amp;&amp; P-&gt;Next-&gt;Element != X)</span><br><span class="line">    &#123;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X, List L, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    <span class="keyword">if</span> (TmpCell == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Out of space!!!\n"</span>);</span><br><span class="line">    TmpCell-&gt;Element = X;</span><br><span class="line">    TmpCell-&gt;Next = P-&gt;Next;</span><br><span class="line">    P-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P, Tmp;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next;</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(P != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = P-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">        P = Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    init_list(L);</span><br><span class="line">    L = create_list();</span><br><span class="line">    print_list(L);</span><br><span class="line">    <span class="keyword">int</span> isEmpty = IsEmpty(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表是否为空: %d\n"</span>, isEmpty);</span><br><span class="line">    Position p = Find(<span class="number">21</span>, L);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有找到21元素\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找21结果: %d\n"</span>, p-&gt;Element);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(i, L, p);</span><br><span class="line">    &#125;</span><br><span class="line">    Delete(<span class="number">21</span>, L);</span><br><span class="line">    DeleteList(L);</span><br><span class="line">    print_list(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提起链表，我们每个人都不会陌生，不管对数据结构的掌握如何，都或多或少的听过与用过链表这样的常见的数据结构。链表是线性表的一种，最基础的线性表，在插入与删除数据时，我们需要对表的整体或部分做移动，为了允许表可以不按照线性的顺序存储数据结构，于是链表就应运而生。链表最大的特点就是在每个节点里存储了到下一个节点的指针。由于不必按照顺序存储，链表在插入的时候可以达到O(1)的复杂度，比我们学习的最基本的线性表要快得多。但是在查找一个节点，或者访问特定编号的结点则需要O(N)的时间。&lt;/p&gt;
&lt;p&gt;使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的有点，同时由于增加了指针域，空间开销较大。不过这在算法与数据结构领域是很常见的，用空间换时间，毕竟鱼和熊掌不可兼得。&lt;/p&gt;
&lt;p&gt;我的链表数据结构是使用C语言来实现的，那么下面来看一下链表的头文件定义了哪些操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发——十六进制字符串与NSData的转化</title>
    <link href="http://yoursite.com/2017/07/07/iOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8ENSData%E7%9A%84%E8%BD%AC%E5%8C%96/"/>
    <id>http://yoursite.com/2017/07/07/iOS开发——十六进制字符串与NSData的转化/</id>
    <published>2017-07-07T06:58:42.000Z</published>
    <updated>2017-07-07T06:59:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在完成一个需求时，遇到了<code>NSData</code>类型转换为十六进制的字符串这个需求的函数，在<code>stackoverflow</code>中翻找的时候，给出的答案基本上是如下的:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* newStr = [[<span class="built_in">NSString</span> alloc] initWithData:theData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the data is null-terminated, you should instead use -stringWithUTF8String: to avoid the extra \0 at the end.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span>* newStr = [<span class="built_in">NSString</span> stringWithUTF8String:[theData bytes]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// (Note that if the input is not properly UTF-8-encoded, you will get nil.)</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>Swift的写法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newStr = <span class="type">String</span>(data: data, encoding: .utf8)</span><br><span class="line"><span class="comment">// note that `newStr` is a `String?`, not a `String`.</span></span><br><span class="line"><span class="comment">// If the data is null-terminated, you could go though the safe way which is remove the that null character, or the unsafe way similar to the Objective-C version above.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// safe way, provided data is \0-terminated</span></span><br><span class="line"><span class="keyword">let</span> newStr1 = <span class="type">String</span>(data: data.subdata(<span class="keyword">in</span>: <span class="number">0</span> ..&lt; data.<span class="built_in">count</span> - <span class="number">1</span>), encoding: .utf8)</span><br><span class="line"><span class="comment">// unsafe way, provided data is \0-terminated</span></span><br><span class="line"><span class="keyword">let</span> newStr2 = data.withUnsafeBytes(<span class="type">String</span>.<span class="keyword">init</span>(utf8String:))</span><br></pre></td></tr></table></figure><p>但是在实际的测试中，并不能完成将NSData转换为NSData中存储的十六进制字符串的功能，所以在最终找到答案之后，决定记录下来，以便下次使用可以快速查找。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSData</span> *)convertHexStrToData:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str || [str length] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *hexData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">NSRange</span> range;</span><br><span class="line">    <span class="keyword">if</span> ([str length] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        range = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        range = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = range.location; i &lt; [str length]; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> anInt;</span><br><span class="line">        <span class="built_in">NSString</span> *hexCharStr = [str substringWithRange:range];</span><br><span class="line">        <span class="built_in">NSScanner</span> *scanner = [[<span class="built_in">NSScanner</span> alloc] initWithString:hexCharStr];</span><br><span class="line">        </span><br><span class="line">        [scanner scanHexInt:&amp;anInt];</span><br><span class="line">        <span class="built_in">NSData</span> *entity = [[<span class="built_in">NSData</span> alloc] initWithBytes:&amp;anInt length:<span class="number">1</span>];</span><br><span class="line">        [hexData appendData:entity];</span><br><span class="line">        </span><br><span class="line">        range.location += range.length;</span><br><span class="line">        range.length = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hexdata: %@"</span>, hexData);</span><br><span class="line">    <span class="keyword">return</span> hexData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入参数字符串<code>@&quot;400&quot;</code>时，打印出来的是 <code>hexdata: &lt;0400&gt;</code>。十六进制的400就是10进制的1024。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)convertDataToHexStr:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || [data length] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *string = [[<span class="built_in">NSMutableString</span> alloc] initWithCapacity:[data length]];</span><br><span class="line">    </span><br><span class="line">    [data enumerateByteRangesUsingBlock:^(<span class="keyword">const</span> <span class="keyword">void</span> *bytes, <span class="built_in">NSRange</span> byteRange, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *dataBytes = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)bytes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; byteRange.length; i++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *hexStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%x"</span>, (dataBytes[i]) &amp; <span class="number">0xff</span>];</span><br><span class="line">            <span class="keyword">if</span> ([hexStr length] == <span class="number">2</span>) &#123;</span><br><span class="line">                [string appendString:hexStr];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [string appendFormat:<span class="string">@"0%@"</span>, hexStr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上一个🌰的NSData作为参数传入时，返回的字符串为<code>400</code>。转换完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在完成一个需求时，遇到了&lt;code&gt;NSData&lt;/code&gt;类型转换为十六进制的字符串这个需求的函数，在&lt;code&gt;stackoverflow&lt;/code&gt;中翻找的时候，给出的答案基本上是如下的:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;* newStr = [[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; alloc] initWithData:theData encoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// If the data is null-terminated, you should instead use -stringWithUTF8String: to avoid the extra \0 at the end.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;* newStr = [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithUTF8String:[theData bytes]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// (Note that if the input is not properly UTF-8-encoded, you will get nil.)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发——自主设计日志系统</title>
    <link href="http://yoursite.com/2017/06/28/iOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E8%87%AA%E4%B8%BB%E8%AE%BE%E8%AE%A1%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/06/28/iOS开发——自主设计日志系统/</id>
    <published>2017-06-28T09:37:01.000Z</published>
    <updated>2017-06-28T09:37:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>好像很久没有写有关iOS的文章了，其实iOS的开发一直都是在进行的，但是最近有需求拓宽知识的宽度，所以一直在接触别的知识，当然啦，移动端开发并不能丢下。</p><p>我平时开发的项目监测bug和崩溃的模块都是集成了鹅厂的<code>Bugly</code>系统，毕竟是谁用谁说好的第三方系统。而<code>Bugly</code>主要还是返回的还是崩溃之后的日志，所以如果想在平时的运行中，就能拿到客户手机中的日志怎么办呢。在这个需求的驱使下，便开始着手设计一个日志系统。</p><p>需求还是不难的，记录手机操作的内容，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间|日志级别|类名_函数名_行数|分类|Log内容</span><br></pre></td></tr></table></figure><p>这样的一种日志形式。</p><p>因为不希望频繁的读写，所以希望每十条Log生成之后，读写一次。而未写入硬盘的Log保存在内存中。按照天数，每天都有一份日志，并且在客户的手机异常之后，可以将所有日志压缩上传到服务器。需求介绍完了，并不难对不对。</p><a id="more"></a><p>在Log的生成方面，我的设计是枚举出日志的级别，之后利用Swift的 <code>#function</code> 和 <code>#line</code>等定义，方便的获取函数名和行数，类名我是利用一个对于<code>NSObject</code>的<code>extension</code>来完成的，类似这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> className: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>)).components(separatedBy: <span class="string">"."</span>).last!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">className</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>).components(separatedBy: <span class="string">"."</span>).last!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开箱可用，准确获取类名。</p><p>生成log的核心函数例如如下这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">createLog</span><span class="params">(level: DebugLevel, targetClass: AnyClass, type: OperateType, content: String,  <span class="number">_</span> line: Int = #line, <span class="number">_</span> function: String = #function)</span></span></span><br><span class="line">-&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lineStr = <span class="type">String</span>.<span class="keyword">init</span>(format: <span class="string">"line:%d"</span>, line)</span><br><span class="line">    <span class="keyword">let</span> levelStr = levelToString(level: level)</span><br><span class="line">    <span class="keyword">let</span> separator = <span class="string">"|"</span></span><br><span class="line">    <span class="keyword">let</span> classSeparator = <span class="string">"_"</span></span><br><span class="line">    <span class="keyword">let</span> log: <span class="type">String</span> = <span class="type">Date</span>().<span class="built_in">toString</span>() + separator + levelStr + separator + targetClass.className + classSeparator + function + classSeparator + lineStr + separator + content + <span class="string">"\n"</span></span><br><span class="line">    <span class="built_in">print</span>(log)</span><br><span class="line">    <span class="keyword">return</span> log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而基于这个函数做一些封装，就能封装出很简便的打印各级别日志的API了。</p><p>至此，介绍完Log的生成类： <code>LogGenerator</code>。</p><p>之后是对日志的读写，需要有一个文件读写的类，暂定名为<code>LogStorage</code>。</p><p>因为文件的读写都是常规的操作，所以代码就不贴出来了。我在这里只是贴出我在<code>LogStorage</code>类里暴露的接口方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">LogStorageProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取日志缓存地址</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Returns: String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getCachePath</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 删除文件</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter fileName: String</span></span><br><span class="line">    <span class="comment">/// - Returns: Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(fileName: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 清除全部日志缓存</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Returns: Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cleanCache</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 读取日志文件</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameter fileName: String</span></span><br><span class="line">    <span class="comment">/// - Returns: Data</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName: String)</span></span> -&gt; <span class="type">Data</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 更新写入Log数据</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - fileName: String</span></span><br><span class="line">    <span class="comment">///   - data: Data</span></span><br><span class="line">    <span class="comment">/// - Returns: Data</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateFile</span><span class="params">(fileName: String, data: Data)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 自动根据天数创建文件名</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Returns: String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createFileName</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个十条一写，没有达到标准的就暂时保存在内存里，我的想法是创建一个循环队列，根据FIFO原则，当满足十条Log时，做一次写入操作，而循环队列在空间上是非常节省资源的，如果没有满足十条日志，那就都暂存在队列里，整个开销就是循环队列的一个数组，容量是11个元素，还有一个充当哨兵。</p><p>循环队列的数据结构是队列的数据结构里最基础的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">QueueProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createQueue</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">traverseQueue</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isFullQueue</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isEmptyQueue</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">Enqueue</span><span class="params">(log: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">Dequeue</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部增加了一个遍历队列写入日志的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private func updateFileWhenTranverse() &#123;</span><br><span class="line">    var i = queue.front</span><br><span class="line">    while (i != queue.rear) &#123;</span><br><span class="line">        let fileName = LogStorage.share.createFileName()</span><br><span class="line">        let data = queue.logData[i].data(using: .utf8)</span><br><span class="line">        if (LogStorage.share.updateFile(fileName: fileName, data: data!)) &#123;</span><br><span class="line">            let _ = Dequeue()</span><br><span class="line">        &#125;</span><br><span class="line">        i += 1</span><br><span class="line">        i = i % queue.maxsize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而最后一个需求就是压缩上传了，在这里使用了<code>SSZipArchive</code>这个第三方库来压缩文件成zip格式。封装成<code>LogArchive</code>类。是不是三言两语间，整个日志系统就设计完成了，但是我是用<code>Swift</code>来写的，若是<code>Objective-C</code>调用怎么办呢。答案当然是用Objc强大的宏定义来搞定咯，几个宏定义，轻松的一行代码就调用了Log输出。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define Cute_Debug(log) [[LogGenerator new] debugWithTargetClass:self.classForCoder content:[NSString stringWithFormat:@<span class="meta-string">"%@"</span>, log] :(NSInteger)__LINE__ :[NSString stringWithFormat:@<span class="meta-string">"%s"</span>, __FUNCTION__]];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define Cute_Warning(log) [[LogGenerator new] warningWithTargetClass:self.classForCoder content:[NSString stringWithFormat:@<span class="meta-string">"%@"</span>, log] :(NSInteger)__LINE__ :[NSString stringWithFormat:@<span class="meta-string">"%s"</span>, __FUNCTION__]];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define Cute_Info(log) [[LogGenerator new] infoWithTargetClass:self.classForCoder content:[NSString stringWithFormat:@<span class="meta-string">"%@"</span>, log] :(NSInteger)__LINE__ :[NSString stringWithFormat:@<span class="meta-string">"%s"</span>, __FUNCTION__]];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define Cute_Error(log) [[LogGenerator new] errorWithTargetClass:self.classForCoder content:[NSString stringWithFormat:@<span class="meta-string">"%@"</span>, log] :(NSInteger)__LINE__ :[NSString stringWithFormat:@<span class="meta-string">"%s"</span>, __FUNCTION__]];</span></span><br></pre></td></tr></table></figure><p>整个日志系统，我已经开源放在了我的<a href="https://github.com/originalix/CuteLogger" target="_blank" rel="noopener">github</a>上，具体的代码可以去github上看。<br>欢迎提issue，如果有用，请点个star谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好像很久没有写有关iOS的文章了，其实iOS的开发一直都是在进行的，但是最近有需求拓宽知识的宽度，所以一直在接触别的知识，当然啦，移动端开发并不能丢下。&lt;/p&gt;
&lt;p&gt;我平时开发的项目监测bug和崩溃的模块都是集成了鹅厂的&lt;code&gt;Bugly&lt;/code&gt;系统，毕竟是谁用谁说好的第三方系统。而&lt;code&gt;Bugly&lt;/code&gt;主要还是返回的还是崩溃之后的日志，所以如果想在平时的运行中，就能拿到客户手机中的日志怎么办呢。在这个需求的驱使下，便开始着手设计一个日志系统。&lt;/p&gt;
&lt;p&gt;需求还是不难的，记录手机操作的内容，如&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间|日志级别|类名_函数名_行数|分类|Log内容&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的一种日志形式。&lt;/p&gt;
&lt;p&gt;因为不希望频繁的读写，所以希望每十条Log生成之后，读写一次。而未写入硬盘的Log保存在内存中。按照天数，每天都有一份日志，并且在客户的手机异常之后，可以将所有日志压缩上传到服务器。需求介绍完了，并不难对不对。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="Cute-Logger" scheme="http://yoursite.com/tags/Cute-Logger/"/>
    
      <category term="日志系统" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux的用户管理(二)</title>
    <link href="http://yoursite.com/2017/06/21/Linux%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2017/06/21/Linux的用户管理(二)/</id>
    <published>2017-06-21T09:45:39.000Z</published>
    <updated>2017-06-21T09:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次的博客我们讲了关于Linux的用户管理的内容，现在我们来讲第二部分——系统用户组的管理。</p><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于它同名的用户组，这个用户组在创建用户的同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><h3 id="增加用户组"><a href="#增加用户组" class="headerlink" title="增加用户组"></a>增加用户组</h3><p>添加一个新的用户组，使用<code>groupadd</code>命令。 格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupadd [options] [group]</span><br><span class="line"></span><br><span class="line">可以使用的选项有： </span><br><span class="line">-g GID 指定新用户组的组标识号（GID）。</span><br><span class="line">-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</span><br></pre></td></tr></table></figure><a id="more"></a><p>举个🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupadd group1</span><br><span class="line"></span><br><span class="line">此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 </span><br><span class="line"></span><br><span class="line">groupadd -g 101 group2</span><br><span class="line"></span><br><span class="line">此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</span><br></pre></td></tr></table></figure><h3 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h3><p>如果要删除一个存在的用户组，使用<code>groupdel</code>命令,格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel [用户组]</span><br></pre></td></tr></table></figure><p>举个🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># groupdel group1</span><br><span class="line"></span><br><span class="line">此命令从系统中删除组group1</span><br></pre></td></tr></table></figure><h3 id="修改用户组属性"><a href="#修改用户组属性" class="headerlink" title="修改用户组属性"></a>修改用户组属性</h3><p>修改用户组的属性使用<code>groupmod</code>命令。其语法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br><span class="line"></span><br><span class="line">常用的选项有： </span><br><span class="line"></span><br><span class="line">-g GID 为用户组指定新的组标识号。</span><br><span class="line"></span><br><span class="line">-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class="line"></span><br><span class="line">-n新用户组 将用户组的名字改为新名字</span><br></pre></td></tr></table></figure><p>举个🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line">此命令将组group2的组标识号修改为102。 </span><br><span class="line"></span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br><span class="line"></span><br><span class="line">此命令将组group2的标识号改为10000，组名修改为group3</span><br></pre></td></tr></table></figure><h3 id="切换用户组"><a href="#切换用户组" class="headerlink" title="切换用户组"></a>切换用户组</h3><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令<code>newgrp</code>切换到其他用户组，这个命令的参数就是目的用户组。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure><p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p><h3 id="账号相关的系统文件"><a href="#账号相关的系统文件" class="headerlink" title="账号相关的系统文件"></a>账号相关的系统文件</h3><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括<code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>/etc/group</code>等。下面分别介绍这些文件的内容。</p><p><code>/etc/passwd</code>文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在<code>/etc/passwd</code>文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">　　＃ cat /etc/passwd</span><br><span class="line">　　</span><br><span class="line"></span><br><span class="line">　　root:x:0:0:Superuser:/:</span><br><span class="line"></span><br><span class="line">　　daemon:x:1:1:System daemons:/etc:</span><br><span class="line"></span><br><span class="line">　　bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line"></span><br><span class="line">　　sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line"></span><br><span class="line">　　adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line"></span><br><span class="line">　　uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line"></span><br><span class="line">　　auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line"></span><br><span class="line">　　cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line"></span><br><span class="line">　　listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line"></span><br><span class="line">　　lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br><span class="line"></span><br><span class="line">　　sam:x:200:50:Sam san:/usr/sam:/bin/sh</span><br></pre></td></tr></table></figure><p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><ul><li><p>“用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 </p></li><li><p>“口令”一些系统中，存放着加密后的用户口令字。。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 </p></li><li><p>“用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。 </p></li></ul><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 </p><ul><li><p>“组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。 </p></li><li><p>“注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。 </p></li><li><p>“主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 　</p></li><li>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 </li></ul><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 </p><p>用户组的所有信息都存放在/etc/group文件中。 </p><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure><ul><li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 </li><li><p>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 </p></li><li><p>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。 </p></li><li><p>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 </p></li></ul><p>举个🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">　　/etc/group文件的一个例子如下： </span><br><span class="line"></span><br><span class="line">　　# cat /etc/group </span><br><span class="line"></span><br><span class="line">　　root::0:root</span><br><span class="line"></span><br><span class="line">　　bin::2:root,bin</span><br><span class="line"></span><br><span class="line">　　sys::3:root,uucp</span><br><span class="line"></span><br><span class="line">　　adm::4:root,adm</span><br><span class="line"></span><br><span class="line">　　daemon::5:root,daemon</span><br><span class="line"></span><br><span class="line">　　lp::7:root,lp</span><br><span class="line"></span><br><span class="line">　　users::20:root,sam</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次的博客我们讲了关于Linux的用户管理的内容，现在我们来讲第二部分——系统用户组的管理。&lt;/p&gt;
&lt;p&gt;每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于它同名的用户组，这个用户组在创建用户的同时创建。&lt;/p&gt;
&lt;p&gt;用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&lt;code&gt;/etc/group&lt;/code&gt;文件的更新。&lt;/p&gt;
&lt;h3 id=&quot;增加用户组&quot;&gt;&lt;a href=&quot;#增加用户组&quot; class=&quot;headerlink&quot; title=&quot;增加用户组&quot;&gt;&lt;/a&gt;增加用户组&lt;/h3&gt;&lt;p&gt;添加一个新的用户组，使用&lt;code&gt;groupadd&lt;/code&gt;命令。 格式如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;groupadd [options] [group]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以使用的选项有： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-g GID 指定新用户组的组标识号（GID）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux的用户管理(一)</title>
    <link href="http://yoursite.com/2017/06/12/Linux%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86(%E4%B8%80)/"/>
    <id>http://yoursite.com/2017/06/12/Linux的用户管理(一)/</id>
    <published>2017-06-12T08:25:53.000Z</published>
    <updated>2017-06-12T12:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在看《鸟哥的Linux私房菜》的第四章之前，我操作Linux系统时，习惯性的使用<code>root</code>账号，为什么呢？无非图一个方便，没有那么多权限设置，对当时我这个<code>Linux</code>小白来说，再好不过了。但是看完了鸟哥的书，我才意识到当时的操作是有多大的问题，所以在此书写一下以便日后回顾。</p><p><code>Linux</code>系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><a id="more"></a><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><pre><code>- 用户账号的添加、删除与修改。- 用户口令的管理。- 用户组的管理。  </code></pre><h2 id="Linux系统用户账号的管理"><a href="#Linux系统用户账号的管理" class="headerlink" title="Linux系统用户账号的管理"></a>Linux系统用户账号的管理</h2><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p><p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。  </p><h3 id="添加账号"><a href="#添加账号" class="headerlink" title="添加账号"></a>添加账号</h3><p><strong> 添加新的用户账号使用useradd命令，其语法如下：  </strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中各选项含义如下：</span><br><span class="line"></span><br><span class="line">-c comment 指定一段注释性描述。</span><br><span class="line"></span><br><span class="line">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line"></span><br><span class="line">-g 用户组 指定用户所属的用户组。</span><br><span class="line"></span><br><span class="line">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class="line"></span><br><span class="line">-s Shell文件 指定用户的登录Shell。</span><br><span class="line"></span><br><span class="line">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br><span class="line"></span><br><span class="line">用户名 指定新账号的登录名。</span><br></pre></td></tr></table></figure><p>举个🌰子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># useradd –d /usr/lix -m lix</span><br><span class="line"></span><br><span class="line">此命令创建了一个用户lix，</span><br><span class="line">其中-d和-m选项用来为登录名lix产生一个主目录/usr/lix（/usr为默认的用户主目录所在的父目录）。</span><br></pre></td></tr></table></figure><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除一个已有的用户账号使用userdel命令，其格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br><span class="line"></span><br><span class="line">常用的选项是-r，它的作用是把用户的主目录一起删除。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># userdel lix</span></span><br></pre></td></tr></table></figure><p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p><h3 id="修改账号"><a href="#修改账号" class="headerlink" title="修改账号"></a>修改账号</h3><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><p>修改已有用户的信息使用usermod命令，其格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line"> -l 新用户名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</span><br></pre></td></tr></table></figure><p>🌰子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -s /bin/ksh -d /home/z –g developer lix</span><br></pre></td></tr></table></figure><p>此命令将用户lix的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p><h3 id="用户口令管理"><a href="#用户口令管理" class="headerlink" title="用户口令管理"></a>用户口令管理</h3><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>　　指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">passwd 选项 用户名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可使用的选项：</span><br><span class="line"></span><br><span class="line">-l 锁定口令，即禁用账号。</span><br><span class="line"></span><br><span class="line">-u 口令解锁。</span><br><span class="line"></span><br><span class="line">-d 使账号无口令。</span><br><span class="line"></span><br><span class="line">-f 强迫用户下次登录时修改口令。</span><br><span class="line"></span><br><span class="line">如果默认用户名，则修改当前用户的口令。</span><br></pre></td></tr></table></figure><p>例如，假设当前用户是lix，则下面的命令修改该用户自己的口令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　$ passwd</span><br><span class="line"></span><br><span class="line">　　Old password:******</span><br><span class="line"></span><br><span class="line">　　New password:*******</span><br><span class="line"></span><br><span class="line">　　Re-enter new password:*******</span><br></pre></td></tr></table></figure><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　# passwd lix</span><br><span class="line"></span><br><span class="line">　　New password:*******</span><br><span class="line"></span><br><span class="line">　　Re-enter new password:*******</span><br></pre></td></tr></table></figure><p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。  </p><p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p><p>为用户指定空口令时，执行下列形式的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -d lix</span><br></pre></td></tr></table></figure><p>此命令将用户lix的口令删除，这样用户lix下一次登录时，系统就不再询问口令。</p><p>passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l lix</span><br></pre></td></tr></table></figure><p>关于用户操作账户操作的 今天先讲到这里，用户组的操作下章接着记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看《鸟哥的Linux私房菜》的第四章之前，我操作Linux系统时，习惯性的使用&lt;code&gt;root&lt;/code&gt;账号，为什么呢？无非图一个方便，没有那么多权限设置，对当时我这个&lt;code&gt;Linux&lt;/code&gt;小白来说，再好不过了。但是看完了鸟哥的书，我才意识到当时的操作是有多大的问题，所以在此书写一下以便日后回顾。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Liunx的文件权限</title>
    <link href="http://yoursite.com/2017/06/02/Liunx%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2017/06/02/Liunx的文件权限/</id>
    <published>2017-06-02T02:37:39.000Z</published>
    <updated>2017-06-02T02:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前讲过为了统一开发环境生产环境以及更换开发机器的情况，我把环境统一由<code>Vagrant</code>部署在<code>Linux</code>的虚拟机中，但是由于我对<code>Linux</code>系统没有系统的学习过，对于环境的部署也仅仅通过谷歌等刚刚入门，所以在具体的开发中我还是经常在<code>Linux</code>中遇到问题，经常求教老大。看着老大熟练的把玩<code>Linux</code>，我也下定决心要把<code>Linux</code>掌握好。</p><p>经自己了解，《鸟哥的Linux私房菜》一书备受推崇，于是于半个月前购入，开始拜读学习。在日常的工作时间之外，断断续续的学习着，确实受益匪浅，厚厚的一本书现在才看了四分之一左右，决定还是抽出时间记录一下自己曾经对于<code>Linux</code>感到困惑的一些事情。</p><p>今天就来说说<code>Linux</code>中文件权限的一些门门道道。</p><a id="more"></a><p>当初我在部署第一个<code>Laravel</code>项目到阿里云的时候，在部署完成后，看到教程中要给<code>storage</code>文件设置权限，当时这个777 775等这种数字简直把我弄迷糊了。只能对照着命令乖乖的敲进去，神奇的是敲进去之后，果然问题解决了，站点能访问了。感觉甚是困惑。看完书中的文件权限一章之后，才发觉<code>Linux</code>中文件权限的神奇。</p><p>查看文件权限的语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端输入:</span></span><br><span class="line">ls -l xxx.xxx （xxx.xxx是文件名）</span><br><span class="line"><span class="comment"># 那么就会出现相类似的信息，主要都是这些：</span></span><br><span class="line">-rw-rw-r--</span><br></pre></td></tr></table></figure><p>一共有10位数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">其中： 最前面那个 - 代表的是类型</span><br><span class="line">中间那三个 rw- 代表的是所有者（user）</span><br><span class="line">然后那三个 rw- 代表的是组群（group）</span><br><span class="line">最后那三个 r-- 代表的是其他人（other）</span><br><span class="line">然后我再解释一下后面那9位数：</span><br><span class="line">r 表示文件可以被读（<span class="built_in">read</span>）</span><br><span class="line">w 表示文件可以被写（write）</span><br><span class="line">x 表示文件可以被执行（如果它是程序的话）</span><br><span class="line">- 表示相应的权限还没有被授予</span><br><span class="line"></span><br><span class="line">现在该说说修改文件权限了</span><br><span class="line">在终端输入：</span><br><span class="line">chmod o w xxx.xxx</span><br><span class="line">表示给其他人授予写xxx.xxx这个文件的权限</span><br><span class="line">chmod go-rw xxx.xxx</span><br><span class="line">表示删除xxx.xxx中组群和其他人的读和写的权限</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">其中：</span><br><span class="line">　　u 代表所有者（user）</span><br><span class="line">　　g 代表所有者所在的组群（group）</span><br><span class="line">　　o 代表其他人，但不是u和g （other）</span><br><span class="line">　　a 代表全部的人，也就是包括u，g和o</span><br><span class="line">　　r 表示文件可以被读（<span class="built_in">read</span>）</span><br><span class="line">　　w 表示文件可以被写（write）</span><br><span class="line">　　x 表示文件可以被执行（如果它是程序的话）</span><br><span class="line">　　其中：rwx也可以用数字来代替</span><br><span class="line">　　r ------------4</span><br><span class="line">　　w -----------2</span><br><span class="line">　　x ------------1</span><br><span class="line">　　- ------------0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">行动：</span><br><span class="line">　　 表示添加权限</span><br><span class="line">　　- 表示删除权限</span><br><span class="line">　　= 表示使之成为唯一的权限</span><br><span class="line">　　当大家都明白了上面的东西之后，那么我们常见的以下的一些权限就很容易都明白了：</span><br><span class="line">　　-rw------- (600) 只有所有者才有读和写的权限</span><br><span class="line">　　-rw-r--r-- (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限</span><br><span class="line">　　-rwx------ (700) 只有所有者才有读，写，执行的权限</span><br><span class="line">　　-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限</span><br><span class="line">　　-rwx--x--x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限</span><br><span class="line">　　-rw-rw-rw- (666) 每个人都有读写的权限</span><br><span class="line">　　-rwxrwxrwx (777) 每个人都有读写和执行的权限</span><br></pre></td></tr></table></figure><p>常用的权限修改命令:</p><ul><li>chgrp ：改变文件所属群组</li><li>chown ：改变文件拥有者</li><li>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性</li></ul><p>改变权限, chmod</p><p>文件权限的改变使用的是chmod这个指令，但是，权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。我们就来谈一谈：</p><p>数字类型改变文件权限</p><p>各权限的分数对照表如下：<br>r:4<br>w:2<br>x:1<br>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：<br>owner = rwx = 4+2+1 = 7<br>group = rwx = 4+2+1 = 7<br>others= — = 0+0+0 = 0</p><p>在讲解清楚了这种权限分值的累加之后，再去体会自己当初敲入命令行中的数字，是不是恍然大悟了呢。不知道你们是不是，反正我是这样的。今天小小的知识点就记录到这里，下次有时间再更新咯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前讲过为了统一开发环境生产环境以及更换开发机器的情况，我把环境统一由&lt;code&gt;Vagrant&lt;/code&gt;部署在&lt;code&gt;Linux&lt;/code&gt;的虚拟机中，但是由于我对&lt;code&gt;Linux&lt;/code&gt;系统没有系统的学习过，对于环境的部署也仅仅通过谷歌等刚刚入门，所以在具体的开发中我还是经常在&lt;code&gt;Linux&lt;/code&gt;中遇到问题，经常求教老大。看着老大熟练的把玩&lt;code&gt;Linux&lt;/code&gt;，我也下定决心要把&lt;code&gt;Linux&lt;/code&gt;掌握好。&lt;/p&gt;
&lt;p&gt;经自己了解，《鸟哥的Linux私房菜》一书备受推崇，于是于半个月前购入，开始拜读学习。在日常的工作时间之外，断断续续的学习着，确实受益匪浅，厚厚的一本书现在才看了四分之一左右，决定还是抽出时间记录一下自己曾经对于&lt;code&gt;Linux&lt;/code&gt;感到困惑的一些事情。&lt;/p&gt;
&lt;p&gt;今天就来说说&lt;code&gt;Linux&lt;/code&gt;中文件权限的一些门门道道。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Vagrant来搭建开发环境</title>
    <link href="http://yoursite.com/2017/05/15/%E4%BD%BF%E7%94%A8Vagrant%E6%9D%A5%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2017/05/15/使用Vagrant来搭建开发环境/</id>
    <published>2017-05-15T08:36:31.000Z</published>
    <updated>2017-05-15T08:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在大半年前刚刚接触PHP的时候，因为那时候只想先熟悉PHP的语法，并且对配置服务器、Mysql等一干事情不想花费太多时间，于是在网上找到了XAMPP这个解决方案。当时那是惊为天人，感觉虚拟主机很是方便。但是随着后来自己的慢慢深入，并且也在云服务器上陆续的部署自己的小项目，这才感觉到一个很恶心的事情，就是本地和线上的开发环境不同意，导致自己在频繁的修改配置文件，并且主力开发机器是用mac，家里还有win10的台式机，线上是Liunx系统，各种不一样的环境让我想寻求一个解决方案，统一线上和线下的开发环境。</p><p>在这种想法的指引下，很快有一个解决方案进入我的视线。通过搭建Liunx虚拟机，解决线上线下开发环境不统一的情况。这个解决方案，就是<code>VirtualBox</code> + <code>Vagrant</code>。目前他能完成我的所有需求，并且提供了很快捷的打包，来实现开发环境的迁移及统一部署，非常好用。本文就来记录如何使用Vagrant这个工具，好让我在日后部署环境的时候，能够把这些命令翻出来再看看。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>实际上Vagrant只是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统，本书中我们将使用VirtualBox来进行说明，所以第一步需要先安裝Vagrant和VirtualBox。</p></blockquote><p>安装环境：mac<br>注：windows环境下，基本一致</p><h3 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h3><p>直接来到官网 <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a> 点击下载最新的virtualbox，双击安装，一路傻瓜化完成。</p><h3 id="安装Vagrant"><a href="#安装Vagrant" class="headerlink" title="安装Vagrant"></a>安装Vagrant</h3><p>在进行完上一个步骤后，我们就要考虑我们的虚拟机需要使用什么操作系统了。因为我线上使用了<code>Ubuntu16.04</code>的操作系统，所以我线下也选择了16.04的<code>Ubuntu</code>操作系统。在以前使用vm的过程中，我们需要自己去下载镜像，然后进行相关的安装，设置系统等等操作。而vagrant的开源社区，提供了很多已经打包好的操作系统，在vagrant的世界里被称为box。在 <a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">http://www.vagrantbox.es/</a> 这里你可以找到你想要的操作系统box，当然你也可以自己制作一个。后续教程会讲到，这里就不多说。</p><p>我的开发机是Mac，所以我建立了如下的开发环境目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /Users/vagrant</span><br><span class="line">$ cd /Users/vagrant</span><br></pre></td></tr></table></figure><p>这里注意，vagrant提供的在线安装，有可能因为天朝的网络原因，很慢或者下载失败，所以我会找到box的下载链接，用迅雷等工具下载好这个盒子。之后执行安装设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add &#123;title&#125; &#123;url&#125;</span><br><span class="line">$ vagrant init &#123;title&#125;</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure><p><code>vagrant box add</code> 是添加box的命令<br>其中｛title｝可以自行设置，我这里使用的是 <code>Ubuntu</code> ，｛url｝是下载到本地box路径。我的路径是：/Users/vagrant/ubuntu.box</p><p>box中的镜像文件被放到了：/Users/.vagrant.d/boxes/，如果在window系统中应该是放到了： C:\Users\当前用户名.vagrant.d\boxes\目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 如果是才add 的box，就必须执行本步骤，初始化一次后，以后启动系统，就不需要执行本步骤。</span><br><span class="line">$ vagrant init Ubuntu</span><br></pre></td></tr></table></figure><p>输出如下 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A `Vagrantfile` has been placed in this directory.</span><br><span class="line">You are now ready to `vagrant up` your first virtual environment!</span><br><span class="line">Please read the comments in the Vagrantfile as well as documentation on `vagrantup.com` for more information on using Vagrant.</span><br></pre></td></tr></table></figure><p>这样就会在当前目录生成一个 Vagrantfile的文件，里面有很多配置信息，后面我在慢慢说，默认不做任何配置改动，也是可以启动系统的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动系统</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...</span><br><span class="line">[default] Importing base box &apos;base&apos;...</span><br><span class="line">[default] Matching MAC address for NAT networking...</span><br><span class="line">[default] Setting the name of the VM...</span><br><span class="line">[default] Clearing any previously set forwarded ports...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="ssh链接到虚拟机"><a href="#ssh链接到虚拟机" class="headerlink" title="ssh链接到虚拟机"></a>ssh链接到虚拟机</h2><p>经过以上操作后，完成了虚拟机的安装，现在需要登录上虚拟机，进行操作。链接很简单，可以使用第三方（xshell等）shell工具或系统自带的，进行登录<br>在系统中，如mac，可直接使用 vagrant ssh 来完成链接。或者使用第三方如xshell，ip地址是：localhost，端口，需要观察，映射的22端口是多少。一般是2200 或者2222<br>用户名与密码均是： vagrant</p><h2 id="vagrant的命令详解"><a href="#vagrant的命令详解" class="headerlink" title="vagrant的命令详解"></a>vagrant的命令详解</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>vagrant box add</td><td>添加box的操作</td></tr><tr><td>vagrant init</td><td>初始化box的操作，会生成vagrant的配置文件Vagrantfile</td></tr><tr><td>vagrant up</td><td>启动本地环境</td></tr><tr><td>vagrant ssh</td><td>通过 ssh 登录本地环境所在虚拟机</td></tr><tr><td>vagrant halt</td><td>关闭本地环境</td></tr><tr><td>vagrant suspend</td><td>暂停本地环境</td></tr><tr><td>vagrant resume</td><td>恢复本地环境</td></tr><tr><td>vagrant reload</td><td>修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）</td></tr><tr><td>vagrant destroy</td><td>彻底移除本地环境</td></tr><tr><td>vagrant box list</td><td>显示当前已经添加的box列表</td></tr><tr><td>vagrant box remove</td><td>删除相应的box</td></tr><tr><td>vagrant package</td><td>打包命令，可以把当前的运行的虚拟机环境进行打包</td></tr><tr><td>vagrant plugin</td><td>用于安装卸载插件</td></tr><tr><td>vagrant status</td><td>获取当前虚拟机的状态</td></tr><tr><td>vagrant global-status</td><td>显示当前用户Vagrant的所有环境状态</td></tr></tbody></table><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>配置好Vagrant只是开始，而之后在Linux配置环境，可以参考我之前的一篇文章，在《云服务器上部署Laravel》这篇文章，来配置自己的<code>LNMP</code>环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大半年前刚刚接触PHP的时候，因为那时候只想先熟悉PHP的语法，并且对配置服务器、Mysql等一干事情不想花费太多时间，于是在网上找到了XAMPP这个解决方案。当时那是惊为天人，感觉虚拟主机很是方便。但是随着后来自己的慢慢深入，并且也在云服务器上陆续的部署自己的小项目，这才感觉到一个很恶心的事情，就是本地和线上的开发环境不同意，导致自己在频繁的修改配置文件，并且主力开发机器是用mac，家里还有win10的台式机，线上是Liunx系统，各种不一样的环境让我想寻求一个解决方案，统一线上和线下的开发环境。&lt;/p&gt;
&lt;p&gt;在这种想法的指引下，很快有一个解决方案进入我的视线。通过搭建Liunx虚拟机，解决线上线下开发环境不统一的情况。这个解决方案，就是&lt;code&gt;VirtualBox&lt;/code&gt; + &lt;code&gt;Vagrant&lt;/code&gt;。目前他能完成我的所有需求，并且提供了很快捷的打包，来实现开发环境的迁移及统一部署，非常好用。本文就来记录如何使用Vagrant这个工具，好让我在日后部署环境的时候，能够把这些命令翻出来再看看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Vagrant" scheme="http://yoursite.com/tags/Vagrant/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置二级域名</title>
    <link href="http://yoursite.com/2017/05/05/nginx%E9%85%8D%E7%BD%AE%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/"/>
    <id>http://yoursite.com/2017/05/05/nginx配置二级域名/</id>
    <published>2017-05-05T09:23:29.000Z</published>
    <updated>2017-05-15T08:41:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了练手Vue框架，写了一个博客项目，昨天刚刚把个人博客部署上线，因为前后端分离，所以使用Ajax来请求后端api接口获取数据，部署的过程中碰到了一个坑。我只有一个域名，所以想让一级域名<code>originalix.com</code>来访问博客，而使用二级域名<code>demo.originalix.com</code>来访问后端页面并且请求api。</p><p>怎么做呢，在查阅了资料以后发现，首先应该在域名供应商中添加一条二级域名的记录，比如我想使用的是<strong>demo</strong>。</p><p><img src="http://originalix.github.io/assets/img/nginxdomain.png" alt=""></p><p>设置好域名后，在本地<strong>ping</strong>一下看看能不能<strong>ping</strong>通过 <code>demo.originalix.com</code></p><a id="more"></a><p>接下来，ssh进服务器，找到你安装的nginx，启动并且配置。</p><ul><li>安装nginx</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><ul><li>重启nginx</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx start</span><br></pre></td></tr></table></figure><ul><li>进入nginx配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure><p>在配置文件中可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;</span><br><span class="line">    server_name originalix.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header   Host      $http_host;</span><br><span class="line">        proxy_pass         http://127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;  </span><br><span class="line">    listen 80;</span><br><span class="line">    server_name demo.originalix.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header   Host      $http_host;</span><br><span class="line">        proxy_pass         http://127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我具体是因为后端是<code>Laravel</code>框架的项目，所以我得配置文件是这样写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">    root /var/www/;</span><br><span class="line"></span><br><span class="line">    index index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    # server_name 110.223.38.82;</span><br><span class="line">    server_name http://originalix.xyz;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">            try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">            try_files $uri /index.php =404;</span><br><span class="line">            fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">            fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name demo.originalix.com;</span><br><span class="line">    root /var/www/originalix/public;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">      try_files $uri /index.php =404;</span><br><span class="line">      fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">      fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class="line">      fastcgi_index index.php;</span><br><span class="line">      fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">      include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启nginx，并且打开浏览器，输入 <code>demo.originalix.com</code> 就ok了</p><p>ps:在整个过程中如果遇到什么问题，比如 nginx启动失败。可以看一下这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这个命令可以看一下你的nginx配置文件有没有问题，</span><br><span class="line">//如果有问题它会指出，做相应的修改，直到没报错</span><br><span class="line">nginx -t </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//查看日志。比如我nginx -t明明没问题，老是启动失败，</span><br><span class="line">//看了日志才知道 Address already in use，端口被占用o(╯□╰)o</span><br><span class="line">cat /var/log/nginx/error.log</span><br></pre></td></tr></table></figure><p>还是那句话，失败了一定要学会看日志！！！看日志！！！看日志！！！</p><p>很简单的事情，我也是摸索了一会儿，崩溃ing。</p><p>所以写个博客记录下来，希望能帮助到大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近为了练手Vue框架，写了一个博客项目，昨天刚刚把个人博客部署上线，因为前后端分离，所以使用Ajax来请求后端api接口获取数据，部署的过程中碰到了一个坑。我只有一个域名，所以想让一级域名&lt;code&gt;originalix.com&lt;/code&gt;来访问博客，而使用二级域名&lt;code&gt;demo.originalix.com&lt;/code&gt;来访问后端页面并且请求api。&lt;/p&gt;
&lt;p&gt;怎么做呢，在查阅了资料以后发现，首先应该在域名供应商中添加一条二级域名的记录，比如我想使用的是&lt;strong&gt;demo&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://originalix.github.io/assets/img/nginxdomain.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置好域名后，在本地&lt;strong&gt;ping&lt;/strong&gt;一下看看能不能&lt;strong&gt;ping&lt;/strong&gt;通过 &lt;code&gt;demo.originalix.com&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="Domin" scheme="http://yoursite.com/tags/Domin/"/>
    
  </entry>
  
  <entry>
    <title>简单的编程体会</title>
    <link href="http://yoursite.com/2017/04/26/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E7%A8%8B%E4%BD%93%E4%BC%9A/"/>
    <id>http://yoursite.com/2017/04/26/简单的编程体会/</id>
    <published>2017-04-26T09:09:52.000Z</published>
    <updated>2017-04-26T09:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的这篇博文，我不谈及具体的编程技术，只想从这段时间的学习以及写代码的过程中，分享一下自己的编程体会。</p><a id="more"></a><p>上周呢，项目中碰到了一个新的任务，要接入一个第三方外设厂商的蓝牙设备，对方公司提供了一个sdk。其实接入一个sdk这个小事情呢，每个从业者都会碰到，合理的选用第三方的sdk服务能大大缩短我们的开发时间，让我们把目光都放到自己的核心业务上去。而碰巧这个sdk是对方公司新写出来的，于是，本着怀疑的态度，我开始了对这个sdk包的接入工作。</p><p>由于这个sdk包是新版，为了预防后面的升级，为了松耦合，我在这个第三方库上加了一层完整的封装。仔细的整理好项目的需求，封装了一层适用于项目的API接口，并且提供给团队的小伙伴使用。而既然是要提供给团队的小伙伴使用的API，我在编写代码的过程中慎之又慎，单元测试覆盖率基本达到了95%以上。很早以前我有一篇博文，是专门讲TDD模式和一款Kiwi的测试框架，其实那个阶段的我，更多的是停留在对那款单元测试的框架使用和摸索上，并没有极大程度的重视TDD的思想。而在又重读《Clean Code》这本书之后，单元测试的这根弦又在我脑子里绷紧了。</p><p>于是在这次的编码过程中，没有经过单元测试的代码，坚决不能放在生产环境里成了我坚持的原则，每一行代码都必须跑过，在各种条件下测试过，才会成为放心的代码，才能在之后放心的重构。不然小伙伴调用API的时候如果产生了一堆bug，你让我这张脸往哪搁。在这样的实践之下，我逐渐尝到了测试驱动开发这个思想的甜头，之前我还有接入其他设备的经验，但是当时赶工期，缺乏系统的单元测试，使得上线后bug不断，有时候debug时定位都要花费一些功夫，但是当你的每行代码都跑过单元测试时，你会对你的代码很有信心，并且能梳理的逻辑更清楚。况且，你要进行单元测试，那么以最小单元模块为单位的代码块或者函数，也必然是一段短小的代码，符合短函数的要求，最近苛刻的要求自己绝对不写超过20行的代码。只为函数的单一职责和逻辑清晰。</p><p>通过近期补充自己的数据结构和算法知识，我在敲代码的过程中，对这个方面，也多了一层考虑。从一些细节方面来思考怎么把代码写的更好，除了表层的代码风格，在组织数据时，考虑是否有合适的数据结构类型可以使用，并且哪怕小到一个排序算法，或者查找算法，也会想怎么写才能更有效率，平衡时间复杂度和空间复杂度的关系。这些意识都是之前所不具备的，所以感觉到最近自己在编程方面通过学习还是有一些提升的。而同时也很后悔自己对于这方面知识的学习来的太晚，回顾以前写的代码，还是生产了不小量的脏代码。检索一组规律数据，使用从头遍历这样时间复杂度底下的方式，实在不应该。</p><p>其他的一些编码细节也慢慢注意了起来，比如命名的更合理规范明确，比如函数在类里的摆放位置，一切其实都是为了一个事情，就是代码的可读性。写出来的代码20%的时间在开发，80%的时间在维护，可读性是非常重要的一件事情，而最近不断培养的也正是这个意识，只希望写出能让人读的舒服的代码。仅此而已。</p><p>近期敲得代码比较杂，写过前端三件套，HTML+CSS+JavaScript,并且系统的学习了Vue框架，也用了stylus这个css预处理器写过css，算法数据结构用Java写，后端的处理是php，框架使用了Laravel，iOS端Swift Objective-C混写，慢慢的有种感受就是，其实用什么框架用什么语言真的无所谓，早先时候，自己还是太过于追求框架，有时候学习的路线反而是不正确是，是要去深刻的理解一门语言，以及这个语言主要解决问题的场景，而非如何使用一个趁手的框架去完成任务，轮子是永远造不完的，旧的框架以后一定会被新的取代，而语言特性这种小细节，是需要去细细体会，花时间琢磨的。</p><p>今天随便说说的一些体会，也只是为了写出更好的代码，仅此而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的这篇博文，我不谈及具体的编程技术，只想从这段时间的学习以及写代码的过程中，分享一下自己的编程体会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程体会" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E4%BD%93%E4%BC%9A/"/>
    
  </entry>
  
</feed>
