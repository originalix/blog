<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leon的博客</title>
  <icon>https://www.gravatar.com/avatar/9d151238658e9fa1d07c5b6b41f6fcbc</icon>
  <subtitle>每多学一点知识，就少写一行代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-07T12:03:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李晓</name>
    <email>xiao.liunit@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆排序算法</title>
    <link href="http://yoursite.com/2018/08/07/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/07/堆排序算法/</id>
    <published>2018-08-07T12:02:17.000Z</published>
    <updated>2018-08-07T12:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>啊噢，又开始写算法学习的笔记了。最近在准备面试的过程中又把这些常见的排序算法拿出来复习复习，既然这篇写到了堆排序，那么就代表堆排序算法的概念被我忘的差不多了，写篇博客加深记忆吧。</p><a id="more"></a><p>在维基百科上看堆排序，上面有这么一张图，</p><p><img src="https://camo.githubusercontent.com/207aa201f944b13e8a79842effcacf3f7ee3721e/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f312f31622f536f7274696e675f68656170736f72745f616e696d2e676966" alt=""></p><p>可是原谅我概念真的忘的差不多了，所以理解不了这张图，于是我又找到另一个可视化的过程，一目了然，是别人放在github page上的一个<a href="https://bajdcc.github.io/html/heap.html" target="_blank" rel="noopener">页面</a>，地址就在<a href="https://bajdcc.github.io/html/heap.html" target="_blank" rel="noopener">这里</a>。所以本篇文章的堆排序的可视化动画，就参考这个吧。</p><p>堆排序（Heapsort)是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。</p><p>通常堆是通过一维数组来实现的，在数组起始位置为0的情形中来看看堆节点的一些定义。</p><ul><li>父节点i的左子节点在位置(2i + 1);</li><li>父节点i的右子节点在位置(2i + 2);</li><li>子节点i的父节点在floor((i - 1) / 2);</li></ul><p>关于堆中节点的位置，有如上三个定义。</p><p>在堆的数据结构中，堆中的最大值总是位于根节点上。而堆中的一个很重要的操作就是最大堆调整(Max_Heapify)，即为将堆的末端子节点作调整，使得子节点永远小于父节点。</p><p>接下来看看这个关键的Max_Heapify最大堆调整的实现是怎样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">maxHeapify(start, end) &#123;</span><br><span class="line">  <span class="comment">// 建立父节点指标和子节点指标</span></span><br><span class="line">  <span class="keyword">let</span> dad = start;</span><br><span class="line">  <span class="keyword">let</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若子节点指标超过范围，则直接跳出函数</span></span><br><span class="line">  <span class="keyword">if</span> (son &gt;= end)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 先比较两个子节点的大小 选择最大的</span></span><br><span class="line">  <span class="keyword">if</span> (son + <span class="number">1</span> &lt; end &amp;&amp; <span class="keyword">this</span>.array[son] &lt; <span class="keyword">this</span>.array[son + <span class="number">1</span>])</span><br><span class="line">    son++;</span><br><span class="line">  <span class="comment">// 如果父节点小于子节点，交换父子节点的内容再继续子节点与孙节点的比较</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.array[dad] &lt; <span class="keyword">this</span>.array[son]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.swap(dad, son);</span><br><span class="line">    <span class="keyword">this</span>.maxHeapify(son, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行最大堆调整的操作时，我们传入初始和终止的两个索引，并且根据我们刚提到的堆节点的定义，建立父节点和子节点指标。接下来如果子节点的指标超过的终止索引的范围，则直接跳出函数。否则的话我们比较两个子节点的大小，选择大的节点进行接下来的操作。</p><p>在两个节点中选取完较大节点后，我们比较父节点与子节点，如果父节点小于子节点，那么交换父子节点的内容，再递归的比较子节点与孙节点，直到调整完成。</p><p>完整的堆排序算法（javascript实现）如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  堆排序算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(originalArray) &#123;</span><br><span class="line">    <span class="comment">// 拷贝数组，不修改原数组</span></span><br><span class="line">    <span class="keyword">this</span>.array = [...originalArray];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swap(i, j) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="keyword">this</span>.array[i];</span><br><span class="line">    <span class="keyword">this</span>.array[i] = <span class="keyword">this</span>.array[j];</span><br><span class="line">    <span class="keyword">this</span>.array[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maxHeapify(start, end) &#123;</span><br><span class="line">    <span class="comment">// 建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="keyword">let</span> dad = start;</span><br><span class="line">    <span class="keyword">let</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若子节点指标超过范围，则直接跳出函数</span></span><br><span class="line">    <span class="keyword">if</span> (son &gt;= end)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 先比较两个子节点的大小 选择最大的</span></span><br><span class="line">    <span class="keyword">if</span> (son + <span class="number">1</span> &lt; end &amp;&amp; <span class="keyword">this</span>.array[son] &lt; <span class="keyword">this</span>.array[son + <span class="number">1</span>])</span><br><span class="line">      son++;</span><br><span class="line">    <span class="comment">// 如果父节点小于子节点，交换父子节点的内容再继续子节点与孙节点的比较</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.array[dad] &lt; <span class="keyword">this</span>.array[son]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.swap(dad, son);</span><br><span class="line">      <span class="keyword">this</span>.maxHeapify(son, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sort() &#123;</span><br><span class="line">    <span class="keyword">const</span> len = <span class="keyword">this</span>.array.length;</span><br><span class="line">    <span class="comment">// 初始化 i从最后一个父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor((len - <span class="number">1</span>) / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">this</span>.maxHeapify(i, len);</span><br><span class="line">    <span class="comment">// 先将第一个元素和已排好的前一位做交换，再重新调整，直到排序完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.swap(<span class="number">0</span>, i);</span><br><span class="line">      <span class="keyword">this</span>.maxHeapify(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.array;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> heap = <span class="keyword">new</span> HeapSort(array);</span><br><span class="line"><span class="keyword">let</span> res = heap.sort();</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>sort函数里的两个for循环也要解释一下，第一个for循环，是堆的初始化，从最后一个父节点开始，调整整个数组的排序。而第二个for循环，是把第一个已经确定大小的元素和已经排好位的前一个元素做交换，再重新调整排序，直到整个排序完成。待for循环完成之后，整个数组也就呈从小到大的顺序了排好了。</p><p>理解完代码之后，再看看堆排序的时间复杂度，堆排序的平均时间复杂度，以及最优、最坏的时间复杂度都是O(nlog n)，而空间复杂度是O(1)，并且堆排序是一种不稳定排序。</p><p>文章中的源码在这里<a href="https://github.com/originalix/algorithm/blob/4cd004c0c96e39a35daa3e97171ad0bbea5e2f49/JavaScript/algorithms/sorting/heap-sort/HeapSort.js" target="_blank" rel="noopener">堆排序算法源码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊噢，又开始写算法学习的笔记了。最近在准备面试的过程中又把这些常见的排序算法拿出来复习复习，既然这篇写到了堆排序，那么就代表堆排序算法的概念被我忘的差不多了，写篇博客加深记忆吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>从element-ui源码来看BEM实现</title>
    <link href="http://yoursite.com/2018/07/23/%E4%BB%8Eelement-ui%E6%BA%90%E7%A0%81%E6%9D%A5%E7%9C%8BBEM%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/07/23/从element-ui源码来看BEM实现/</id>
    <published>2018-07-23T11:50:58.000Z</published>
    <updated>2018-07-23T11:52:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前看过一些CSS的编码规范，也照着规范编写代码，但是还是觉得自己的CSS编码风格不是很好，在平时开发中使用各个知名的组件库的时候，发现现在挺多组件库都是BEM的命名风格了，于是找了比较知名的element饿了么前端的组件库的源码，想从看饿了么组件库的代码入手，学习学习大厂的的CSS BEM规范代码的书写风格。</p><a id="more"></a><p>BEM代表“块（block），元素（element），修饰符（modifier）”，开发组件的过程中经常使用这三个实体，而在选择器中，这三个实体由以下符号来表示扩展关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-  中划线：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</span><br><span class="line">__ 双下划线：双下划线用来连接块和块的子元素。</span><br><span class="line">_  单下划线：单下划线用来描述一个块或者块的子元素的一种状态。</span><br><span class="line"></span><br><span class="line">type-block__element_modifier</span><br></pre></td></tr></table></figure><p>以上的描述是从腾讯的前端规范库中找到的，简单的来说理解了块、元素、修饰符三个分类之后，就能大致理解BEM代码是什么样的结构了，可是了解结构是一方面，如何写好代码又是另一方面。我在element组件库中的<code>mixins.scss</code>文件中找到了想要的答案。</p><p>接下来我要讲的就是如何利用sass，编写具有可读性和可维护性的BEM规则的css代码。</p><p>首先来看sass代码中对于block的定义:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$namespace: 'el';</span><br><span class="line">$element-separator: '__';</span><br><span class="line">$modifier-separator: '--';</span><br><span class="line">$state-prefix: 'is-';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> b($block) &#123;</span><br><span class="line">  $B: $namespace+'-'+$block !global;</span><br><span class="line"></span><br><span class="line">  .#&#123;$B&#125; &#123;</span><br><span class="line">    @<span class="keyword">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便大家理解代码，我现在开头贴上配置文件中定义的变量，而这时就能很清楚的看到block的生成就是基于BEM规范中，块是设计或布局的一部分，具有唯一地意义，利用命名空间<code>el</code>加上中划线，以及传入的block的名字，构建出block的样式，例如<code>alert</code>组件，在渲染完成后是<code>el-alert</code>，体现出它的唯一性。而在块的内部，再来编写跟这个块关联的其他样式代码。</p><p>块的构建非常的简单，接下来来看稍微有点复杂的元素的定义:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> e($element) &#123;</span><br><span class="line">  $E: $element !global;</span><br><span class="line">  $selector: &amp;;</span><br><span class="line">  $currentSelector: "";</span><br><span class="line">  @<span class="keyword">each</span> $unit in $element &#123;</span><br><span class="line">    $currentSelector: #&#123;$currentSelector + "." + $B + $element-separator + $unit + ","&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">if</span> hitAllSpecialNestRule($selector) &#123;</span><br><span class="line">    @<span class="keyword">at</span>-<span class="keyword">root</span> &#123;</span><br><span class="line">      #&#123;$selector&#125; &#123;</span><br><span class="line">        #&#123;$currentSelector&#125; &#123;</span><br><span class="line">          @<span class="keyword">content</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">at</span>-<span class="keyword">root</span> &#123;</span><br><span class="line">      #&#123;$currentSelector&#125; &#123;</span><br><span class="line">        @<span class="keyword">content</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素选择器的实现中，我们应该把关注点放在if和eles分支上，为什么会出现<code>hitAllSpecialNestRule</code>函数判断的分支，原因是在修饰符或者其他mixin中嵌套一个元素element，会出现修饰符在前，而元素在后的编译结果，所以我们用<code>hitAllSpecialNestRule</code>函数来判断是否存在特殊的嵌套，如果存在的话，将我们的元素字符串写在前面，而修饰符放在后面，如果不存在，则原样输出。</p><p>而<code>hitAllSpecialNestRule</code>的实现则在下面的代码中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">function</span> selectorToString($selector) &#123;</span><br><span class="line">  $selector: inspect($selector);</span><br><span class="line">  $selector: str-slice($selector, 2, -2);</span><br><span class="line">  @<span class="keyword">return</span> $selector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">function</span> containsModifier($selector) &#123;</span><br><span class="line">  $selector: selectorToString($selector);</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">if</span> str-index($selector, $modifier-separator) &#123;</span><br><span class="line">    @<span class="keyword">return</span> true;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">return</span> false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">function</span> containWhenFlag($selector) &#123;</span><br><span class="line">  $selector: selectorToString($selector);</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">if</span> str-index($selector, <span class="string">'.'</span> + $state-prefix) &#123;</span><br><span class="line">    @<span class="keyword">return</span> true</span><br><span class="line">  &#125; @else &#123;</span><br><span class="line">    @<span class="keyword">return</span> false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@function containPseudoClass($selector) &#123;</span><br><span class="line">  $selector: selectorToString($selector);</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">if</span> str-index($selector, <span class="string">':'</span>) &#123;</span><br><span class="line">    @<span class="keyword">return</span> true</span><br><span class="line">  &#125; @else &#123;</span><br><span class="line">    @<span class="keyword">return</span> false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@function hitAllSpecialNestRule($selector) &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">return</span> containsModifier($selector) or containWhenFlag($selector) or containPseudoClass($selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个函数<code>selectorToString</code>，就是将我们的选择器转换成一个字符串，而接下来的三个函数，分别判断了是否存在修饰符、flag例如（.isCenter）、伪类的情况。最后综合在一起返回结果，避免嵌套。</p><p>最后则是<code>modifier</code>修饰符的实现了，代码如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> m($modifier) &#123;</span><br><span class="line">  $selector: &amp;;</span><br><span class="line">  $currentSelector: "";</span><br><span class="line">  @<span class="keyword">each</span> $unit in $modifier &#123;</span><br><span class="line">    $currentSelector: #&#123;$currentSelector + &amp; + $modifier-separator + $unit + ","&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">at</span>-<span class="keyword">root</span> &#123;</span><br><span class="line">    #&#123;$currentSelector&#125; &#123;</span><br><span class="line">      @<span class="keyword">content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看懂的元素的实现之后，修饰符的实现就是一目了然的了。利用刚刚介绍的函数，以及块、元素、修饰符的实现代码，在sass中已经能非常高效率并且优雅的基于BEM规范的代码了。</p><p>贴一段示例代码，如何利用上面的代码编写BEM规范的css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"mixins/mixins"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"common/var"</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">include</span> b(test) &#123;</span><br><span class="line">    <span class="selector-tag">width</span>: 100%;</span><br><span class="line">    background-color: $--color-white;</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">include</span> when(center) &#123;</span><br><span class="line">        <span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">include</span> m(success) &#123;</span><br><span class="line">        background-color: $--color-black;</span><br><span class="line">        <span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line">        <span class="selector-class">.lix-test__description</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: $--color-white;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">include</span> m(warning) &#123;</span><br><span class="line">        background-color: $--color-black;</span><br><span class="line">        <span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line">        <span class="selector-class">.lix-test__description</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: $--color-white;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">include</span> e(content) &#123;</span><br><span class="line">        <span class="selector-tag">display</span>: <span class="selector-tag">table-cell</span>;</span><br><span class="line">        <span class="selector-tag">padding</span>: 0 8<span class="selector-tag">px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">include</span> e(title) &#123;</span><br><span class="line">        <span class="selector-tag">font-size</span>: 8<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">line-height</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">        </span><br><span class="line">        @<span class="keyword">include</span> when(bold) &#123;</span><br><span class="line">            <span class="selector-tag">font-weight</span>: <span class="selector-tag">bold</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.lix-test-fade-enter</span>,</span><br><span class="line"><span class="selector-class">.lix-test-fade-leave-active</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后的样子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.lix-test</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>; &#125;</span><br><span class="line">  <span class="selector-class">.lix-test</span><span class="selector-class">.is-center</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: center; &#125;</span><br><span class="line">  <span class="selector-class">.lix-test--success</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>; &#125;</span><br><span class="line">    <span class="selector-class">.lix-test--success</span> <span class="selector-class">.lix-test__description</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>; &#125;</span><br><span class="line">  <span class="selector-class">.lix-test--warning</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>; &#125;</span><br><span class="line">    <span class="selector-class">.lix-test--warning</span> <span class="selector-class">.lix-test__description</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>; &#125;</span><br><span class="line">  <span class="selector-class">.lix-test__content</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">8px</span>; &#125;</span><br><span class="line">  <span class="selector-class">.lix-test__title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">10px</span>; &#125;</span><br><span class="line">    <span class="selector-class">.lix-test__title</span><span class="selector-class">.is-bold</span> &#123;</span><br><span class="line">      <span class="attribute">font-weight</span>: bold; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.lix-test-fade-enter</span>,</span><br><span class="line"><span class="selector-class">.lix-test-fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>瞧见了么，合理的利用b、m、e的mixin就可以风格良好的css代码了。上面的所有代码都在<a href="https://github.com/originalix/Original/tree/master/sass/BEM" target="_blank" rel="noopener">这里</a>哦，有需要的可以直接看完整代码学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前看过一些CSS的编码规范，也照着规范编写代码，但是还是觉得自己的CSS编码风格不是很好，在平时开发中使用各个知名的组件库的时候，发现现在挺多组件库都是BEM的命名风格了，于是找了比较知名的element饿了么前端的组件库的源码，想从看饿了么组件库的代码入手，学习学习大厂的的CSS BEM规范代码的书写风格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="前端开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发总结</title>
    <link href="http://yoursite.com/2018/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/17/小程序开发总结/</id>
    <published>2018-07-17T12:08:47.000Z</published>
    <updated>2018-07-17T12:09:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久很久没有更新了，最近几个月因为房子交房，生活上是一片忙碌，工作上的事其实还好，没有分去很多精力，主要是在生活上的事情牵扯了太多了精力，于是乎把每周一更博客的习惯都打断了，每周想起这件事情都觉得很愧疚，但是总是又抽不出时间来写，好像脑袋一片空白，不知道在要写什么。</p><p>现在房子开始正常装修了，想起来前段时间从前端到后端的独立完成了一个小程序的项目，想在恢复更新的时候，总结总结我在小程序的开发过程中碰到的问题或者是产生的感想。</p><a id="more"></a><p>这个项目是我第一个接触小程序的项目，所以一开始我抛掉了用一些热门框架的想法，就想从原生的小程序组织架构来感受小程序最初的设计。在完整的看完微信提供的小程序开发文档后，就开始着手尝试开发小程序了，因为是基于前端而构建的小程序，所以语言方面是没有什么障碍的，只是微信封装了一套自己的类似HTML标签，放在<code>wxml</code>这个格式的文件中，大家可以理解为<code>html</code>的后缀名，剩下的话<code>wxss</code>就与<code>css</code>基本一致了。而小程序与其他前端程序构建有区别的地方之一就是把配置文件放在了<code>json</code>格式的文件里，因为我有Native iOS的基础，所以我大概理解把一些Navigation与Tabbar UI组件相关的配置放在了<code>json</code>文件里，还有把React和Vue中引入组件相关的配置，放在<code>json</code>文件里。而全局有一个<code>app.json</code>的文件，路由配置也必须写在里面，写到这里就要开始吐槽微信小程序开发第一个让我体验不是很好的地方，就是你的每一个页面，是放在<code>pages</code>这个文件夹下面的，例如我们的主页<code>index</code>目录底下有这么几个文件<code>index.wxml</code>、<code>index.wxss</code>、<code>index.json</code>、<code>index.js</code>。而这时你得在<code>app.json</code>中注册这个页面，比如填写<code>/pages/index/index</code>。就是这样的一个配置过程，每个页面下面有四个文件，每次还要去注册页面，只要一旦没注册，或者js里没有完成<code>Page({})</code>初始化对应的代码，那么整个小程序就会报错，运行不了，除非按照规范完成配置。如果小程序比较大，页面很多，那么这样配置我感觉还是挺累的。对于这个点我看到了微信官方发布的小程序框架<code>wepy</code>，在这个框架中是仿照<code>Vue</code>的组织架构，解决了上述的问题，所以接下来的小程序开发，我会尝试基于这个框架来开发，看看是否体验会变得更好。</p><p>第二点就是小程序的配置真的好严格哦，开发iOS或者安卓的时候，直接一台测试服务器就可以先把接口部署上，立马可以开发了，而小程序必须有已经完成备案的域名，并且基于https协议部署好，然后才可以在小程序的后台配置，上传文件域名，socket使用的域名，甚至webview的域名都要单独配置，累觉不爱。总是在需要完成某项功能的时候，才想起来还要配置，打开后台又是一番折腾。不过腾讯在这方面应该是基于安全考虑吧，毕竟是运行在微信的平台里的。</p><p>第三点就是小程序目前已经发展了快两年的时间了，感觉生态还不是很完善，比较完善的组件库也不是很多，我找到的大概除了微信官方的<code>WeUI</code>外，就是有赞的组件库和蘑菇街的组件库比较全了。所以如果想搞开源项目的同学，可以围绕小程序的生态动动脑筋，可能会孵化出不错的开源项目。</p><p>吐槽完小程序之后，再说说体验不错的地方，首先就是微信的JSAPI体验真的不错，受过iOS里各种API折磨的同学可能会有跟我一样的感觉，一些组件在JSAPI的设计里，调用只是这么简单的事情，并且微信的开发工具调试也是很不错的。只是真机测试的自由度还是有限，只能开发者本人测试。而小程序的设计也让下载app这样一个讨厌的事情被无形的解决了。当然了，代价就是你没有推送这种运营很关心的手段了，毕竟鱼和熊掌不可得兼。</p><p>我的第一个小程序的项目完成了，这只是开始的第一步，接下来也一定还会有更多的想法在微信小程序的平台上诞生的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久很久很久没有更新了，最近几个月因为房子交房，生活上是一片忙碌，工作上的事其实还好，没有分去很多精力，主要是在生活上的事情牵扯了太多了精力，于是乎把每周一更博客的习惯都打断了，每周想起这件事情都觉得很愧疚，但是总是又抽不出时间来写，好像脑袋一片空白，不知道在要写什么。&lt;/p&gt;
&lt;p&gt;现在房子开始正常装修了，想起来前段时间从前端到后端的独立完成了一个小程序的项目，想在恢复更新的时候，总结总结我在小程序的开发过程中碰到的问题或者是产生的感想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序——使用setData修改数组中的单个对象</title>
    <link href="http://yoursite.com/2018/05/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8setData%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/05/30/微信小程序——使用setData修改数组中的单个对象/</id>
    <published>2018-05-30T13:47:21.000Z</published>
    <updated>2018-05-30T13:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序已经出来挺久的时间了，之前只是在文档上粗略的看了一下，最近稍得空闲，便利用微信小程序平台写一个练手的项目，顺便学习一下小程序开发，感觉大体跟前端开发基本类似，但是因为是在微信的平台上运行，具体还是要根据小程序的规则来编写代码的，其中还是有部分的内容跟前端中常见的有所不同，于是接下来的博客里，也会顺手记录微信小程序开发过程中的一些坑，帮助后来的小程序开发者少踩一些坑，当然我踩的坑大部分都是以前的开发者踩过的，我所做的也仅仅是记录，分享。</p><p>习惯使用Vue或者React这类框架的开发者们，肯定不会对修改data内中数组的单个对象而烦恼，因为这些框架已经帮我们很好的处理了这个问题，并且在文档上也写的非常清楚。</p><p>比如要求是有一个数组存放了购物车的商品信息，而你在购物车内修改了单个商品的期望购买数量后，我们就要动态的更新这个单个对象的购买数量值，如果在小程序里我们会怎么做呢？</p><a id="more"></a><p>如果你按照Vue的写法来实现的话，不出意外会失败。而微信小程序也只给我们提供了一个setData方法，这个方法是使用键值对的形式对数据进行修改，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    name : <span class="string">'leon'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回到我们刚刚的例子里，这时候，如果你想修改单个商品的数量信息，应该怎么写？</p><p>首先展示一种错误的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    array: [&#123;<span class="attr">text</span>: <span class="string">'init data'</span>&#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  changeItemInArray: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      <span class="string">'array['</span>+index+<span class="string">'].text'</span>:<span class="string">'changed data'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果这样动态的写index，很显然，这样是无法使用在对象的key中的，我相信小程序的新手开发者可能尝试过这样的写法。</p><p>那么正确的写法究竟是怎么样的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">changeItemInArray: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提前准备好对象</span></span><br><span class="line">  <span class="keyword">var</span> item = <span class="keyword">this</span>.data.list[index]</span><br><span class="line">  </span><br><span class="line">  item.count = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依旧是根据index获取数组中的对象</span></span><br><span class="line">  <span class="keyword">var</span> key = <span class="string">"list["</span>+ index + <span class="string">"]"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    <span class="comment">// 这里使用键值对方式赋值</span></span><br><span class="line">    key: item </span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，希望以后的小程序版本更新中，有更好的赋值方法。希望这篇文章能帮助到小程序的新手开发者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序已经出来挺久的时间了，之前只是在文档上粗略的看了一下，最近稍得空闲，便利用微信小程序平台写一个练手的项目，顺便学习一下小程序开发，感觉大体跟前端开发基本类似，但是因为是在微信的平台上运行，具体还是要根据小程序的规则来编写代码的，其中还是有部分的内容跟前端中常见的有所不同，于是接下来的博客里，也会顺手记录微信小程序开发过程中的一些坑，帮助后来的小程序开发者少踩一些坑，当然我踩的坑大部分都是以前的开发者踩过的，我所做的也仅仅是记录，分享。&lt;/p&gt;
&lt;p&gt;习惯使用Vue或者React这类框架的开发者们，肯定不会对修改data内中数组的单个对象而烦恼，因为这些框架已经帮我们很好的处理了这个问题，并且在文档上也写的非常清楚。&lt;/p&gt;
&lt;p&gt;比如要求是有一个数组存放了购物车的商品信息，而你在购物车内修改了单个商品的期望购买数量后，我们就要动态的更新这个单个对象的购买数量值，如果在小程序里我们会怎么做呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云上免费部署HTTPS</title>
    <link href="http://yoursite.com/2018/05/22/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B8%8A%E5%85%8D%E8%B4%B9%E9%83%A8%E7%BD%B2HTTPS/"/>
    <id>http://yoursite.com/2018/05/22/腾讯云上免费部署HTTPS/</id>
    <published>2018-05-22T12:15:05.000Z</published>
    <updated>2018-05-22T13:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写微信小程序的时候，微信小程序需要所有的请求接口都部署在https协议上，于是就研究了一下怎么在腾讯云上部署https环境，发现还是比较简单的，首先我的服务器环境是Ubuntu 16.04, LAMP的环境。</p><h2 id="获取SSL证书"><a href="#获取SSL证书" class="headerlink" title="获取SSL证书"></a>获取SSL证书</h2><p>腾讯云的SSL证书服务中，域名型的（DV）SSL证书是免费的，那么我们这次主要是申请这个证书，如需其他类型证书，也请付费申请。</p><p>进入SSL证书管理控制台，点击申请证书</p><a id="more"></a><p>能看到如图所示的申请表单:</p><p><img src="http://img.yzl1030.com/510586EC-C2CF-49EF-988E-5AF9044B5BCF.png" alt=""></p><p>填上申请信息后，等待大概一个小时左右，证书就能申请下来。接着在云解析里配置上申请的二级域名:</p><p><img src="http://img.yzl1030.com/561179-20161123132020581-1776760709.png" alt=""></p><p>把二级域名解析好之后，待证书申请好。</p><p>在证书申请通过后，下载证书。</p><p><img src="http://img.yzl1030.com/55E31E55-8095-4A55-A273-D6DD71F0ADC1.png" alt=""></p><h2 id="上传SSL证书"><a href="#上传SSL证书" class="headerlink" title="上传SSL证书"></a>上传SSL证书</h2><p>将下载好之后的证书，解压，可以看到里面有Apache, IIS, Nginx, Tomcat等证书，这里根据自己的服务器环境选择对应的证书。这里根据我使用的是Apache环境，使用FileZilla将证书文件上传到Apache目录下，我上传的路径是<code>/etc/apache2/ctr</code>，ctr是我自己创建存储证书的文件夹。</p><h2 id="添加HTTPS的Apache配置"><a href="#添加HTTPS的Apache配置" class="headerlink" title="添加HTTPS的Apache配置"></a>添加HTTPS的Apache配置</h2><p>待证书上传完成后，我在路径<code>/etc/apache2/sites-available</code>下创建一个文件，名为<code>vhostssl.conf</code>，在这个文件里写我这个站点的https配置信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Listen 443</span><br><span class="line">&lt;VirtualHost *:443&gt;</span><br><span class="line">    ServerName www.example.com:443</span><br><span class="line">    DocumentRoot <span class="string">"/var/www/html/example"</span></span><br><span class="line">    ServerAlias www.example.com</span><br><span class="line">    SSLEngine on</span><br><span class="line">    SSLCertificateFile <span class="string">"/etc/apache2/ctr/examplecom/Apache/2_example.com.crt"</span></span><br><span class="line">    SSLCertificateKeyFile <span class="string">"/etc/apache2/ctr/examplecom/Apache/3_example.com.key"</span></span><br><span class="line">    SSLCertificateChainFile <span class="string">"/etc/apache2/ctr/examplecom/Apache/1_root_bundle.crt"</span></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>在<code>vhostssl.conf</code>文件内写入上述的配置信息，其中注意将<code>example</code>替换为你自己的域名，并且修改成正确的证书路径。</p><p>配置文件完成后，进入<code>/etc/apache2/sites-enabled/</code>路径，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ../sites-available/vhostssl.conf</span><br></pre></td></tr></table></figure><p>执行这个命令，添加一个软链至<code>sites-available</code>目录。</p><p>在这些工作都做完后，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service apache2 restart</span><br></pre></td></tr></table></figure><p>重启Apache服务器，然后在你配置的域名前输入https，就能看到一把小绿锁了，至此https的配置也就结束了。</p><p>在完成一遍配置后，会觉得特别简单是么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写微信小程序的时候，微信小程序需要所有的请求接口都部署在https协议上，于是就研究了一下怎么在腾讯云上部署https环境，发现还是比较简单的，首先我的服务器环境是Ubuntu 16.04, LAMP的环境。&lt;/p&gt;
&lt;h2 id=&quot;获取SSL证书&quot;&gt;&lt;a href=&quot;#获取SSL证书&quot; class=&quot;headerlink&quot; title=&quot;获取SSL证书&quot;&gt;&lt;/a&gt;获取SSL证书&lt;/h2&gt;&lt;p&gt;腾讯云的SSL证书服务中，域名型的（DV）SSL证书是免费的，那么我们这次主要是申请这个证书，如需其他类型证书，也请付费申请。&lt;/p&gt;
&lt;p&gt;进入SSL证书管理控制台，点击申请证书&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>CSS——实现元素的垂直居中</title>
    <link href="http://yoursite.com/2018/05/14/CSS%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>http://yoursite.com/2018/05/14/CSS——实现元素的垂直居中/</id>
    <published>2018-05-14T12:41:02.000Z</published>
    <updated>2018-05-14T12:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写CSS的过程中，我常常谷歌一个东西，就是如何实现元素的垂直居中，水平居中难度还不是很大，但是垂直居中我这个烂记性是写一次忘一次，于是本着好记性不如烂笔头的想法，写下一篇博客记录下来。那么今天就记录下三种垂直居中的方法，各位看官按需使用。</p><a id="more"></a><h2 id="通用情况"><a href="#通用情况" class="headerlink" title="通用情况"></a>通用情况</h2><p>首先我们先介绍一种通用情况下的垂直居中，这个方法不需要设置自己的高度，也不需要父容器设置高度，利用绝对定位只需要三行代码就能实现。</p><p>首先html代码长这个样子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outter1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>这里的子元素自适应，不设置高度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么来看css代码如何完成垂直居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#outter1</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">background</span>:black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#outter1</span> <span class="selector-class">.inner1</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#outter1</span> <span class="selector-class">.inner2</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:blue;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父容器设置了高度，父容器下只有一个元素的情况"><a href="#父容器设置了高度，父容器下只有一个元素的情况" class="headerlink" title="父容器设置了高度，父容器下只有一个元素的情况"></a>父容器设置了高度，父容器下只有一个元素的情况</h2><p>若是父容器设置了高度，父容器里只有一个元素，那么使用相对定位即可完成垂直居中。</p><p>html代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outter2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>父亲设置了高度，且只有我一个子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#outter2</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">background</span>:black;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#outter2</span> <span class="selector-class">.inner1</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#outter2</span> <span class="selector-class">.inner2</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">background</span>:blue;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flex布局搞定垂直居中"><a href="#Flex布局搞定垂直居中" class="headerlink" title="Flex布局搞定垂直居中"></a>Flex布局搞定垂直居中</h2><p>如果不用考虑老式浏览器兼容的话，直接用flex布局来搞定就是非常简单的了，三行代码搞定垂直居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outter3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>子元素1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>子元素2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>子元素3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#outter3</span><span class="selector-class">.inner1</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是三种CSS里垂直居中的方法了，希望写下这篇文章的我，在遇到垂直居中的问题时，再也不用谷歌了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写CSS的过程中，我常常谷歌一个东西，就是如何实现元素的垂直居中，水平居中难度还不是很大，但是垂直居中我这个烂记性是写一次忘一次，于是本着好记性不如烂笔头的想法，写下一篇博客记录下来。那么今天就记录下三种垂直居中的方法，各位看官按需使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>在Ubunt16.04上安装LAMP</title>
    <link href="http://yoursite.com/2018/05/09/%E5%9C%A8Ubunt16-04%E4%B8%8A%E5%AE%89%E8%A3%85LAMP/"/>
    <id>http://yoursite.com/2018/05/09/在Ubunt16-04上安装LAMP/</id>
    <published>2018-05-09T13:47:54.000Z</published>
    <updated>2018-05-09T13:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近经常在自己的测试服务器上部署项目，也开了好几台测试服务器，都是用最简单的LAMP方案来建站的。毕竟是最简单易用的，LAMP即为 Linux、Web 服务器 (Apache)、 数据库服务器 (MySQL / MariaDB) 和 PHP (脚本语言)。由于我使用的都是Ubuntu 16.04的系统，所以我将记录基于Ubuntu16.04的系统中安装LAMP的过程。在这里我将默认你已经安装好Ubuntu 16.04的系统了。</p><a id="more"></a><h2 id="Apache2-web服务器的安装"><a href="#Apache2-web服务器的安装" class="headerlink" title="Apache2 web服务器的安装:"></a>Apache2 web服务器的安装:</h2><p>在 Ubuntu Linux 中，web服务器是Apache2，我们可以利用如下命令安装Apache2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line"></span><br><span class="line">$ sudo apt install apache2 -y</span><br></pre></td></tr></table></figure><p>当安装完成Apache2的包之后，Apache2的相关服务是启动的，并在重启后自动运行。在某些情况下，如果你的Apache2的服务并没有自动运行和启用，你可以利用如下命令来启用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start apache2.service</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> apache2.service</span><br><span class="line">$ sudo systemctl status apache2.service</span><br></pre></td></tr></table></figure><p>如果你开启了Ubuntu的防火墙（ufw）,那么你可以使用如下命令来解除web服务器的端口（80和443）限制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw status</span><br><span class="line">Status: active</span><br><span class="line">$ sudo ufw allow <span class="keyword">in</span> <span class="string">'Apache Full'</span></span><br><span class="line">Rule added</span><br><span class="line">Rule added (v6)</span><br></pre></td></tr></table></figure><p>好了，这时候你已经可以输入你的服务器的IP地址来访问你的web服务器了，不出意外你会看到Apache2的欢迎页面。</p><h2 id="数据库服务器的安装-MySQL-Server-5-7"><a href="#数据库服务器的安装-MySQL-Server-5-7" class="headerlink" title="数据库服务器的安装(MySQL Server 5.7):"></a>数据库服务器的安装(MySQL Server 5.7):</h2><p>MySQL 和 MariaDB 都是 Ubuntu 16.04 中的数据库服务器。 MySQL Server 和 MariaDB Server的安装包都可以在Ubuntu 的默认软件源中找到，我们可以选择其中的一个来安装。通过下面的命令来在终端中安装mysql服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install mysql-server mysql-client</span><br></pre></td></tr></table></figure><p>在安装的过程中，它会要求你设置mysql服务器的root账户的密码：</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201606/14/203351wti8ttrbudtwb8io.jpg" alt=""></p><p>确认root账户的密码，并点击确定。</p><p>MySQL 服务器的安装到此已经结束了， MySQL 服务会自动启动并启用。我们可以通过如下的命令来校验 MySQL 服务的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status mysql.service</span><br></pre></td></tr></table></figure><h2 id="PHP脚本语言的安装"><a href="#PHP脚本语言的安装" class="headerlink" title="PHP脚本语言的安装:"></a>PHP脚本语言的安装:</h2><p>由于PHP7已经存在于Ubuntu的软件源中了，在终端中执行如下的命令来安装PHP7</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install php7.0-mysql php7.0-curl php7.0-json php7.0-cgi php7.0 libapache2-mod-php7.0</span><br></pre></td></tr></table></figure><p>在<code>/var/www/html</code>的apache的根目录下创建一个简单的php页面。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ touch info.php</span><br><span class="line">$ vi info.php</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在vi中编辑之后保存并退出文件。</p><p>现在你可以从 web 浏览器中访问这个页面, 输入 : “http://<server_ip>/info.php” ，你可以看到如下页面。</server_ip></p><p>如果能看到紫色的PHPINFO页面，说明已经完全安装成功了。</p><h2 id="phpMyAdmin的安装："><a href="#phpMyAdmin的安装：" class="headerlink" title="phpMyAdmin的安装："></a>phpMyAdmin的安装：</h2><p>phpMyAdmin 可以让我们通过它的 web 界面来执行所有与数据库管理和其他数据库操作相关的任务，这个安装包已经存在于 Ubuntu 的软件源中。</p><p>利用如下的命令来在 Ubuntu server 16.04 LTS 中安装 phpMyAdmin。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install php-mbstring php7.0-mbstring php-gettext</span><br><span class="line">$ sudo systemctl restart apache2.service</span><br><span class="line">$ sudo apt install phpmyadmin</span><br></pre></td></tr></table></figure><p>在以下的安装过程中，它会提示我们选择 phpMyAdmin 运行的目标服务器。</p><p>选择 Apache2 并点击确定。</p><p>点击确定来配置 phpMyAdmin 管理的数据库。</p><p>指定 phpMyAdmin 向数据库服务器注册时所用的密码。</p><p>确认 phpMyAdmin 所需的密码，并点击确认。</p><p>现在可以开始尝试访问 phpMyAdmin，打开浏览器并输入 : “<a href="http://Server_IP_OR_Host_Name/phpmyadmin”" target="_blank" rel="noopener">http://Server_IP_OR_Host_Name/phpmyadmin”</a></p><p>使用我们安装时设置的 root 帐户和密码。<br>当我们点击“Go”的时候，将会重定向到如下所示的 ‘phpMyAdmin’ web界面。</p><p>如果这里出现了错误，那么记得给phpmyadmin加一个软链接，指向apache目录，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin</span><br></pre></td></tr></table></figure><p>到现在，LAMP 方案已经被成功安装并可以使用了，欢迎分享你的反馈和评论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近经常在自己的测试服务器上部署项目，也开了好几台测试服务器，都是用最简单的LAMP方案来建站的。毕竟是最简单易用的，LAMP即为 Linux、Web 服务器 (Apache)、 数据库服务器 (MySQL / MariaDB) 和 PHP (脚本语言)。由于我使用的都是Ubuntu 16.04的系统，所以我将记录基于Ubuntu16.04的系统中安装LAMP的过程。在这里我将默认你已经安装好Ubuntu 16.04的系统了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Ubuntu 16.04" scheme="http://yoursite.com/tags/Ubuntu-16-04/"/>
    
      <category term="LAMP" scheme="http://yoursite.com/tags/LAMP/"/>
    
  </entry>
  
  <entry>
    <title>在Mac上使用ssh-key免密码登录服务器</title>
    <link href="http://yoursite.com/2018/04/25/%E5%9C%A8Mac%E4%B8%8A%E4%BD%BF%E7%94%A8ssh-key%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/04/25/在Mac上使用ssh-key免密码登录服务器/</id>
    <published>2018-04-25T12:42:50.000Z</published>
    <updated>2018-04-25T12:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>从很早之前开始，在搭建测试服务器的时候，就不停的谷歌怎么免密登录服务器，每次配置好免密登录后，到搭建新的服务器时，又忘记了具体的命令，所以决定把这个方法记下来，方便之后日后查找。</p><p>通常的来说，我们会使用 <code>ssh user@host -p port</code>这个命令，之后输入密码来登录服务器，才能ssh登录到服务器进行操作。如果一天需要登录很多遍服务器，就会输入很多次密码，偷懒的我当然不愿意这么干。而今天我们就要偷懒的进行免密码登录服务器的操作。</p><a id="more"></a><p>Unix系的操作系统提供了各种ssh支持，我们可以通过这些来实现ssh登录。</p><p>首先我们要在我们的mac上电脑上生成公钥和私钥，在终端中输入以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p>首先进入<code>~/.ssh</code>目录，之后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>之后就可以一路回车，一般都不设置密码，即可在~/.ssh目录中生成私钥文件(id_rsa)和公钥文件（id_rsa.pub）。如果熟悉git ssh-key配置的朋友，可能已经很熟悉这个步骤了，所以我们只要把公钥上传到我们的服务器的~/.ssh目录就好了。</p><p>所以我们可以用接下来的命令上传我们的公钥文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub ssh foo@8.8.8.8 -p 2222:~/.ssh/</span><br></pre></td></tr></table></figure><p>接下来我们登录到服务器中，将~/.ssh目录下的id_rsa.pub文件改名为authorized_keys:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure><p>接着修改文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ~/.ssh/</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>现在，我们就可以正常的在mac 终端中使用ssh来登录服务器了，无需输入密码。</p><p>我们可以在<code>bash_profile</code>中设置一个<code>alias</code>，更能方便登录服务器的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从很早之前开始，在搭建测试服务器的时候，就不停的谷歌怎么免密登录服务器，每次配置好免密登录后，到搭建新的服务器时，又忘记了具体的命令，所以决定把这个方法记下来，方便之后日后查找。&lt;/p&gt;
&lt;p&gt;通常的来说，我们会使用 &lt;code&gt;ssh user@host -p port&lt;/code&gt;这个命令，之后输入密码来登录服务器，才能ssh登录到服务器进行操作。如果一天需要登录很多遍服务器，就会输入很多次密码，偷懒的我当然不愿意这么干。而今天我们就要偷懒的进行免密码登录服务器的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP开发——yii2多图上传组件的使用</title>
    <link href="http://yoursite.com/2018/04/17/PHP%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94yii2%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/04/17/PHP开发——yii2多图上传组件的使用/</id>
    <published>2018-04-17T13:29:50.000Z</published>
    <updated>2018-04-17T13:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用yii2开发一个表单页面的时候，有多图上传的需求，稍微找了找这方面的组件，基本都安利fileInput这个组件，于是就尝试着使用这个库来完成后端表单页面的多图上传功能。使用的过程中发现还是有不少小细节需要注意的，于是记录一下使用的过程。</p><p><a href="https://github.com/kartik-v/yii2-widget-fileinput" target="_blank" rel="noopener">yii2-widget-fileinput</a>这个库的github地址在这里，安装的部分就很常规了，按文档走就可以了。</p><a id="more"></a><p>我们来看官方文档展示的几个常规操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">kartik</span>\<span class="title">widgets</span>\<span class="title">FileInput</span></span><br><span class="line">// <span class="title">or</span> '<span class="title">use</span> <span class="title">kartik</span><span class="title">ile</span>\<span class="title">FileInput</span>' <span class="title">if</span> <span class="title">you</span> <span class="title">have</span> <span class="title">only</span> <span class="title">installed</span> <span class="title">yii2</span>-<span class="title">widget</span>-<span class="title">fileinput</span> <span class="title">in</span> <span class="title">isolation</span></span><br><span class="line"> </span><br><span class="line">// 使用<span class="title">ActiveForm</span> 和 <span class="title">model</span>绑定的单张图片示例</span><br><span class="line"><span class="title">echo</span> $<span class="title">form</span>-&gt;<span class="title">field</span>($<span class="title">model</span>, '<span class="title">avatar</span>')-&gt;<span class="title">widget</span>(<span class="title">FileInput</span>::<span class="title">classname</span>(), [</span><br><span class="line">    '<span class="title">options</span>' =&gt; ['<span class="title">accept</span>' =&gt; '<span class="title">image</span>/*'],</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多图上传示例</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;label class="control-label"&gt;Add Attachments&lt;/label&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> FileInput::widget([</span><br><span class="line">    <span class="string">'model'</span> =&gt; $model,</span><br><span class="line">    <span class="string">'attribute'</span> =&gt; <span class="string">'attachment_1[]'</span>,</span><br><span class="line">    <span class="string">'options'</span> =&gt; [<span class="string">'multiple'</span> =&gt; <span class="keyword">true</span>]</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不绑定model的使用方法</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;label class="control-label"&gt;Upload Document&lt;/label&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> FileInput::widget([</span><br><span class="line">    <span class="string">'name'</span> =&gt; <span class="string">'attachment_3'</span>,</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不可点击的示例</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;label class="control-label"&gt;Select Attachment&lt;/label&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> FileInput::widget([</span><br><span class="line">    <span class="string">'name'</span> =&gt; <span class="string">'attachment_4'</span>,</span><br><span class="line">    <span class="string">'disabled'</span> =&gt; <span class="keyword">true</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>而这些都是常规操作，我们来设想一下，我们要完成淘宝的商品添加，有个商品表，有着一对多关系的若干张图片，这时候就需要用到多图上传功能了。而且我们还希望上传图片是异步的，那么我们可以这么配置我们的fileInput组件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>= $form-&gt;field($model, <span class="string">'image[]'</span>)-&gt;label($label)-&gt;widget(FileInput::classname(), [</span><br><span class="line"><span class="comment">// 'name' =&gt; 'ImgSelect',</span></span><br><span class="line"><span class="string">'language'</span> =&gt; <span class="string">'zh-CN'</span>, </span><br><span class="line"><span class="string">'options'</span> =&gt; [<span class="string">'multiple'</span> =&gt; <span class="keyword">true</span>, <span class="string">'accept'</span> =&gt; <span class="string">'image/*'</span>],  </span><br><span class="line"><span class="string">'pluginOptions'</span> =&gt; [  </span><br><span class="line">    <span class="string">'initialPreview'</span> =&gt; $initialPreview,  </span><br><span class="line">    <span class="string">'initialPreviewConfig'</span> =&gt; $initialPreviewConfig,  </span><br><span class="line">    <span class="string">'allowedPreviewTypes'</span> =&gt; [<span class="string">'image'</span>],  </span><br><span class="line">    <span class="string">'allowedFileExtensions'</span> =&gt; [<span class="string">'jpg'</span>, <span class="string">'gif'</span>, <span class="string">'png'</span>],  </span><br><span class="line">    <span class="string">'previewFileType'</span> =&gt; <span class="string">'image'</span>,  </span><br><span class="line">    <span class="string">'overwriteInitial'</span> =&gt; <span class="keyword">false</span>,  </span><br><span class="line">    <span class="string">'browseLabel'</span> =&gt; <span class="string">'选择图片'</span>,</span><br><span class="line">    <span class="string">'msgFilesTooMany'</span> =&gt; <span class="string">"选择上传的图片数量(&#123;n&#125;) 超过允许的最大图片数&#123;m&#125;！"</span>,  </span><br><span class="line">    <span class="string">'maxFileCount'</span> =&gt; <span class="number">5</span>,<span class="comment">//允许上传最多的图片5张  </span></span><br><span class="line">    <span class="string">'maxFileSize'</span> =&gt; <span class="number">2048</span>,<span class="comment">//限制图片最大200kB  </span></span><br><span class="line">    <span class="string">'uploadUrl'</span> =&gt; Url::to([<span class="string">'/upload/image'</span>]),</span><br><span class="line">    <span class="comment">//'uploadExtraData' =&gt; ['testid' =&gt; 'listimg'],  </span></span><br><span class="line">    <span class="string">'uploadAsync'</span> =&gt; <span class="keyword">true</span>,<span class="comment">//配置异步上传还是同步上传  </span></span><br><span class="line">],</span><br><span class="line"><span class="string">'pluginEvents'</span> =&gt; [  </span><br><span class="line">    <span class="string">'filepredelete'</span> =&gt; <span class="string">"function(event, key) &#123;  </span></span><br><span class="line"><span class="string">            return (!confirm('确认要删除'));  </span></span><br><span class="line"><span class="string">        &#125;"</span>,  </span><br><span class="line">    <span class="string">'fileuploaded'</span> =&gt; <span class="string">'function(event, data, previewId, index) &#123;  </span></span><br><span class="line"><span class="string">            $(event.currentTarget.closest("form")).append(data.response.imgfile);</span></span><br><span class="line"><span class="string">        &#125;'</span>,  </span><br><span class="line">    <span class="string">'filedeleted'</span> =&gt; <span class="string">'function(event, key) &#123;  </span></span><br><span class="line"><span class="string">            $(event.currentTarget.closest("form")).find("#"+key).remove();  </span></span><br><span class="line"><span class="string">            return;</span></span><br><span class="line"><span class="string">        &#125;'</span>,  </span><br><span class="line">]</span><br><span class="line">]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们在控制器配置好图片浏览的配置，传入进来。代码里的关键点我已经加上了配置，我们可以看到，这时异步上传的url已经配置到了<code>upload/image</code>这个控制器里，而我们也在删除，上传等操作完成时加上了js的回调。</p><p>如上所述，我们罗列了一些都是组件 FileInput的基本属性和设置，如有所需，可查看文档看属性的详细说明。</p><p>看下上传图片的控制器里，我们是怎么写<code>actionImage</code>这个函数的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 上传图片到临时目录 </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> string </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> \yii\base\Exception </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionImage</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (Yii::$app-&gt;request-&gt;isPost) &#123;  </span><br><span class="line">          $res = [];  </span><br><span class="line">          $initialPreview = [];  </span><br><span class="line">          $initialPreviewConfig = [];  </span><br><span class="line">          $images = UploadedFile::getInstancesByName(<span class="string">"UploadImage[image]"</span>);  </span><br><span class="line">          <span class="keyword">if</span> (count($images) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">              <span class="keyword">foreach</span> ($images <span class="keyword">as</span> $key =&gt; $image) &#123;  </span><br><span class="line">                  <span class="keyword">if</span> ($image-&gt;size &gt; <span class="number">2048</span> * <span class="number">1024</span>) &#123;  </span><br><span class="line">                      $res = [<span class="string">'error'</span> =&gt; <span class="string">'图片最大不可超过2M'</span>];  </span><br><span class="line">                      <span class="keyword">return</span> json_encode($res);  </span><br><span class="line">                  &#125;  </span><br><span class="line">                  <span class="keyword">if</span> (!in_array(strtolower($image-&gt;extension), <span class="keyword">array</span>(<span class="string">'gif'</span>, <span class="string">'jpg'</span>, <span class="string">'jpeg'</span>, <span class="string">'png'</span>))) &#123;  </span><br><span class="line">                      $res = [<span class="string">'error'</span> =&gt; <span class="string">'请上传标准图片文件, 支持gif,jpg,png和jpeg.'</span>];  </span><br><span class="line">                      <span class="keyword">return</span> json_encode($res);  </span><br><span class="line">                  &#125;  </span><br><span class="line">                  $dir = <span class="string">'/uploads/temp/'</span>;  </span><br><span class="line">                  <span class="comment">//生成唯一uuid用来保存到服务器上图片名称  </span></span><br><span class="line">                  $pickey = ToolExtend::genuuid();  </span><br><span class="line">                  $filename = $pickey . <span class="string">'.'</span> . $image-&gt;getExtension();</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//如果文件夹不存在，则新建文件夹  </span></span><br><span class="line">                  <span class="keyword">if</span> (!file_exists(Yii::getAlias(<span class="string">'@backend'</span>) . <span class="string">'/web'</span> . $dir)) &#123;  </span><br><span class="line">                      FileHelper::createDirectory(Yii::getAlias(<span class="string">'@backend'</span>) . <span class="string">'/web'</span> . $dir, <span class="number">777</span>);  </span><br><span class="line">                  &#125;  </span><br><span class="line">                  $filepath = realpath(Yii::getAlias(<span class="string">'@backend'</span>) . <span class="string">'/web'</span> . $dir) . <span class="string">'/'</span>;  </span><br><span class="line">                  $file = $filepath . $filename;  </span><br><span class="line">    </span><br><span class="line">                  <span class="keyword">if</span> ($image-&gt;saveAs($file)) &#123;  </span><br><span class="line">                      $imgpath = $dir . $filename;  </span><br><span class="line">                      <span class="comment">/*Image::thumbnail($file, 100, 100) </span></span><br><span class="line"><span class="comment">                          -&gt;save($file . '_100x100.jpg', ['quality' =&gt; 80]); </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">                    <span class="comment">//   array_push($initialPreview, "&lt;img src='" . $imgpath . "' class='file-preview-image' alt='" . $filename . "' title='" . $filename . "'&gt;");  </span></span><br><span class="line">                      $config = [  </span><br><span class="line">                          <span class="string">'caption'</span> =&gt; $filename,  </span><br><span class="line">                          <span class="string">'width'</span> =&gt; <span class="string">'120px'</span>,  </span><br><span class="line">                          <span class="string">'url'</span> =&gt; <span class="string">'../upload/delete'</span>, <span class="comment">// server delete action  </span></span><br><span class="line">                          <span class="string">'key'</span> =&gt; $pickey,</span><br><span class="line">                          <span class="string">'extra'</span> =&gt; [<span class="string">'filename'</span> =&gt; $filename]  </span><br><span class="line">                      ];</span><br><span class="line">                      array_push($initialPreviewConfig, $config);  </span><br><span class="line">    </span><br><span class="line">                      $res = [  </span><br><span class="line">                          <span class="string">"initialPreview"</span> =&gt; $initialPreview,  </span><br><span class="line">                          <span class="string">"initialPreviewConfig"</span> =&gt; $initialPreviewConfig,  </span><br><span class="line">                          <span class="string">"imgfile"</span> =&gt; <span class="string">"&lt;input name='image[]' id='"</span> . $pickey . <span class="string">"' type='hidden' value='"</span> . $imgpath . <span class="string">"'/&gt;"</span>,</span><br><span class="line">                          <span class="string">'filename'</span> =&gt; $filename,</span><br><span class="line">                          <span class="string">'imagePath'</span> =&gt; $imgpath,</span><br><span class="line">                      ];  </span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span> json_encode($res);  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到此，多图上传的工作我们也就完美的实现了。</p><p>为了实现图片的删除效果，这里可以先上传两张图片。你可以单张上传也可以多张上传。</p><p>上传成功后你可以刷新当前页面，因为一开始我们就在controller中实现了图片的预览工作，所以理应会展示我们已经上传的两张图片。</p><p>至于删除函数就不讲了，只要在浏览里配置上删除的url，也是一样的操作咯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在使用yii2开发一个表单页面的时候，有多图上传的需求，稍微找了找这方面的组件，基本都安利fileInput这个组件，于是就尝试着使用这个库来完成后端表单页面的多图上传功能。使用的过程中发现还是有不少小细节需要注意的，于是记录一下使用的过程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kartik-v/yii2-widget-fileinput&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yii2-widget-fileinput&lt;/a&gt;这个库的github地址在这里，安装的部分就很常规了，按文档走就可以了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://yoursite.com/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>在create-react-app中使用sass</title>
    <link href="http://yoursite.com/2018/04/04/%E5%9C%A8create-react-app%E4%B8%AD%E4%BD%BF%E7%94%A8sass/"/>
    <id>http://yoursite.com/2018/04/04/在create-react-app中使用sass/</id>
    <published>2018-04-04T14:00:13.000Z</published>
    <updated>2018-04-04T14:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Sass（英文全称：Syntactically Awesome Stylesheets）是一个最初由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass是一个将脚本解析成CSS的脚本语言，即SassScript。Sass包括两套语法。最开始的语法叫做“缩进语法”，与Haml类似，使用缩进来区分代码块，并且用回车将不同规则分隔开。而较新的语法叫做“SCSS”，使用和CSS一样的块语法，即使用大括号将不同的规则分开，使用分号将具体的样式分开。通常情况下，这两套语法通过.sass和.scss两个文件扩展名区分开。相信每个前端开发者都对这种css预处理器有所耳闻。</p></blockquote><p>不管你是刚使用Reactjs或者是Reactjs的老司机，你们一定都听说过<code>create-react-app</code>这个脚手架，而从<code>create-react-app</code>的官方文档中，我们可以看到他们暂时还不支持直接导入LESS或者Sass。但是通过一些配置，我们还是可以从官方脚手架中使用sass/scss/less的。</p><a id="more"></a><p>首先我们先安装<code>node-sass</code>这个组件，我推荐我们国内的coder使用下面的命令行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mirror-config-china --registry=http://registry.npm.taobao.org</span><br><span class="line">npm install node-sass</span><br></pre></td></tr></table></figure><p>然后在自己项目的<code>package.json</code>中，将以下行添加到scripts中:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"build-css": "node-sass-chokidar src/ -o src/",</span><br><span class="line">"watch-css": "npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/ --watch --recursive",</span><br></pre></td></tr></table></figure><blockquote><p>Note:  在使用不同的预处理器时，请根据预处理的文档替换build-css和watch-css命令。</p></blockquote><p>现在，您可以将src/App.css重命名为src/App.scss并运行npm run watch-css。watch-css将在src子目录中找到每个Sass文件，并在其旁边创建一个相应的CSS文件，在我们的例子中覆盖src/App.css。由于src/app.js仍然 improt src/App.css，所以样式同样成为您的应用程序的一部分。您现在可以编辑src/App.scss，同时会生成相应的src/App.css。</p><p>为了能一边编译sass，一边运行我们的前端项目，我们还需要<code>npm-run-all</code>这个工具，这是一个并行运行多个npm脚本的脚手架工具，安装方式也非常简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install npm-run-all --save-dev</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn add npm-run-all --dev</span><br></pre></td></tr></table></figure><p>最后，在不使用<code>ejec</code>命令的情况下，更改<code>create-react-app</code>的<code>webpack</code>配置，我们使用<code>react-app-rewired</code>来处理，安装方式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install react-app-rewired --save-dev</span><br></pre></td></tr></table></figure><p>在完成这些步骤之后，我们修改<code>package.json</code>的<code>script</code>内容，让sass一边编译，一边跑着我们的前端项目，实现热更。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">"build-css": "node-sass src/ -o src/",</span><br><span class="line">"watch-css": "npm run build-css &amp;&amp; node-sass src/ -o src/ --watch --recursive",</span><br><span class="line">"start-js": "node scripts/start.js",</span><br><span class="line">"start": "npm-run-all -p watch-css start-js",</span><br><span class="line">"build": "npm run build-css &amp;&amp; node scripts/build.js",</span><br><span class="line">"test": "node scripts/test.js --env=jsdom"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>scripts</code>的命令如上所述，安装完之后，<code>npm start</code>就可以搞定sass的使用问题了。</p><p>现在运行run npm和npm run build同样构建了Sass文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Sass（英文全称：Syntactically Awesome Stylesheets）是一个最初由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass是一个将脚本解析成CSS的脚本语言，即SassScript。Sass包括两套语法。最开始的语法叫做“缩进语法”，与Haml类似，使用缩进来区分代码块，并且用回车将不同规则分隔开。而较新的语法叫做“SCSS”，使用和CSS一样的块语法，即使用大括号将不同的规则分开，使用分号将具体的样式分开。通常情况下，这两套语法通过.sass和.scss两个文件扩展名区分开。相信每个前端开发者都对这种css预处理器有所耳闻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不管你是刚使用Reactjs或者是Reactjs的老司机，你们一定都听说过&lt;code&gt;create-react-app&lt;/code&gt;这个脚手架，而从&lt;code&gt;create-react-app&lt;/code&gt;的官方文档中，我们可以看到他们暂时还不支持直接导入LESS或者Sass。但是通过一些配置，我们还是可以从官方脚手架中使用sass/scss/less的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React.js" scheme="http://yoursite.com/tags/React-js/"/>
    
      <category term="Sass" scheme="http://yoursite.com/tags/Sass/"/>
    
  </entry>
  
  <entry>
    <title>在Yii2框架中使用Redis</title>
    <link href="http://yoursite.com/2018/03/28/%E5%9C%A8Yii2%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8Redis/"/>
    <id>http://yoursite.com/2018/03/28/在Yii2框架中使用Redis/</id>
    <published>2018-03-28T12:56:16.000Z</published>
    <updated>2018-03-28T12:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要在Yii2这个PHP框架中很好的使用redis键值存储，那么首先就要推荐<a href="https://github.com/yiisoft/yii2-redis" target="_blank" rel="noopener">yii2-redis</a>这个官方的<a href="https://github.com/originalix" target="_blank" rel="noopener">Github</a>库。这个库能够很好的帮助我们在Yii2框架中使用redis，它提供缓存，Session以及ActiveRecord模式的支持。</p><h2 id="安装yii2-redis库"><a href="#安装yii2-redis库" class="headerlink" title="安装yii2-redis库"></a>安装yii2-redis库</h2><p>推荐使用composer安装yii2-redis库，在你的项目根目录执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php composer.phar <span class="keyword">require</span> --prefer-dist yiisoft/yii2-redis:<span class="string">"~2.0.0"</span></span><br></pre></td></tr></table></figure><p>或者将</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"yiisoft/yii2-redis": "~2.0.0"</span><br></pre></td></tr></table></figure><p>加入你的<code>composer.json</code>文件里，之后运行<code>composer update</code>，墙内真的很慢，耐心等待即可。</p><a id="more"></a><h2 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h2><p>要正确的使用这个扩展，你必须在你的应用程序的配置文件内，配置<code>Connection</code>类，一般来说，配置文件是<code>config\web.php</code>。</p><p>在你的组件里加入<code>redis</code>项目，如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="string">'components'</span> =&gt; [</span><br><span class="line">        <span class="string">'redis'</span> =&gt; [</span><br><span class="line">            <span class="string">'class'</span> =&gt; <span class="string">'yii\redis\Connection'</span>,</span><br><span class="line">            <span class="string">'hostname'</span> =&gt; <span class="string">'localhost'</span>,</span><br><span class="line">            <span class="string">'port'</span> =&gt; <span class="number">6379</span>,</span><br><span class="line">            <span class="string">'database'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">        ],</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>如此之后，你便能正常的在yii2框架中使用redis。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>我们先来看一段最简单的使用redis的代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$redis = Yii::$app-&gt;redis;</span><br><span class="line">$key = <span class="string">'username'</span>;</span><br><span class="line"><span class="keyword">if</span> ($val = $redis-&gt;get($key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'redis'</span> =&gt; $val];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $redis-&gt;set($key, <span class="string">'Leon'</span>);</span><br><span class="line">    $redis-&gt;expire($key, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="string">'redis'</span> =&gt; <span class="string">'no data'</span>];</span><br></pre></td></tr></table></figure><p>没有一行注释，但是就是一目了然是不是。</p><p>寻找<code>username</code>这个key，如果找不到，设置键值存储，并且过期时间是5秒钟。</p><p>这就是一个完整的使用redis的例子。</p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>那么接下来，我们来看看怎么样将redis用在缓存上。</p><p>同样的，作为缓存使用，我们需要去配置文件里修改缓存项:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'components'</span> =&gt; [</span><br><span class="line">    <span class="string">'cache'</span> =&gt; [</span><br><span class="line">        <span class="comment">// 'class' =&gt; 'yii\caching\FileCache',</span></span><br><span class="line">        <span class="string">'class'</span> =&gt; <span class="string">'yii\redis\Cache'</span>,</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>如果你没有配置过redis组件，那么还需要在cache下配置redis:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'components'</span> =&gt; [</span><br><span class="line">    <span class="string">'cache'</span> =&gt; [</span><br><span class="line">        <span class="comment">// 'class' =&gt; 'yii\caching\FileCache',</span></span><br><span class="line">        <span class="string">'class'</span> =&gt; <span class="string">'yii\redis\Cache'</span>,</span><br><span class="line">        <span class="string">'redis'</span> =&gt; [</span><br><span class="line">            <span class="string">'hostname'</span> =&gt; <span class="string">'localhost'</span>,</span><br><span class="line">            <span class="string">'port'</span> =&gt; <span class="number">6379</span>,</span><br><span class="line">            <span class="string">'database'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>示例代码如下，通俗易懂也就不过多解释了:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$cache = Yii::$app-&gt;cache;</span><br><span class="line">$key = <span class="string">'username'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($cache-&gt;exists($key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'cache'</span> =&gt; $cache-&gt;get($key)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $cache-&gt;set($key, <span class="string">'Leon'</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="string">'cache'</span> =&gt; <span class="string">'no cache'</span>];</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>最后是redis用作session。也是要在组件中配置:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'components'</span> =&gt; [</span><br><span class="line">    <span class="string">'session'</span> =&gt; [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'advanced-frontend'</span>,</span><br><span class="line">        <span class="string">'class'</span> =&gt; <span class="string">'yii\redis\Session'</span></span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>如果没有配置过redis，同样需要配置:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'components'</span> =&gt; [</span><br><span class="line">    <span class="string">'session'</span> =&gt; [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'advanced-frontend'</span>,</span><br><span class="line">        <span class="string">'class'</span> =&gt; <span class="string">'yii\redis\Session'</span>,</span><br><span class="line">        <span class="string">'redis'</span> =&gt; [</span><br><span class="line">            <span class="string">'hostname'</span> =&gt; <span class="string">'localhost'</span>,</span><br><span class="line">            <span class="string">'port'</span> =&gt; <span class="number">6379</span>,</span><br><span class="line">            <span class="string">'database'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$session = Yii::$app-&gt;session;</span><br><span class="line">$key = <span class="string">'username'</span>;</span><br><span class="line"><span class="keyword">if</span> ($session-&gt;has($key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'session'</span> =&gt; $session-&gt;get($key)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $session-&gt;set($key, <span class="string">'Leon'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> [<span class="string">'session'</span> =&gt; <span class="string">'no session'</span>];</span><br></pre></td></tr></table></figure><p>在简单的示范下，如何将redis这个高效的工具用好，则是考验大家的能力了。加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要在Yii2这个PHP框架中很好的使用redis键值存储，那么首先就要推荐&lt;a href=&quot;https://github.com/yiisoft/yii2-redis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yii2-redis&lt;/a&gt;这个官方的&lt;a href=&quot;https://github.com/originalix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;库。这个库能够很好的帮助我们在Yii2框架中使用redis，它提供缓存，Session以及ActiveRecord模式的支持。&lt;/p&gt;
&lt;h2 id=&quot;安装yii2-redis库&quot;&gt;&lt;a href=&quot;#安装yii2-redis库&quot; class=&quot;headerlink&quot; title=&quot;安装yii2-redis库&quot;&gt;&lt;/a&gt;安装yii2-redis库&lt;/h2&gt;&lt;p&gt;推荐使用composer安装yii2-redis库，在你的项目根目录执行&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;php composer.phar &lt;span class=&quot;keyword&quot;&gt;require&lt;/span&gt; --prefer-dist yiisoft/yii2-redis:&lt;span class=&quot;string&quot;&gt;&quot;~2.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者将&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&quot;yiisoft/yii2-redis&quot;: &quot;~2.0.0&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;加入你的&lt;code&gt;composer.json&lt;/code&gt;文件里，之后运行&lt;code&gt;composer update&lt;/code&gt;，墙内真的很慢，耐心等待即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://yoursite.com/tags/Yii2/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>ES6——箭头函数</title>
    <link href="http://yoursite.com/2018/03/25/ES6%E2%80%94%E2%80%94%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/25/ES6——箭头函数/</id>
    <published>2018-03-25T13:28:13.000Z</published>
    <updated>2018-03-25T13:28:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6之后，允许使用箭头<code>=&gt;</code>来定义函数。首先我们来总结一下箭头函数存在的意义，之后再来细细的看它的使用方法。</p><p>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this,arguments,super或者new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。</p><p>讲完了箭头函数的意义，那么我们总最基础的示例开始看，先看一个常规语法定义的函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> params + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcName(<span class="number">2</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>如果这个函数用箭头函数改写的话，仅仅需要一行代码就够了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcName = <span class="function">(<span class="params">params</span>) =&gt;</span> params + <span class="number">2</span>;</span><br><span class="line">funcName(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，如果有返回值，就要使用return语句返回。如果表达式是单一的，则可以只用小括号<code>()</code>。例如我上面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">number1, number2</span>) =&gt;</span> &#123; <span class="keyword">return</span> number1 + number2; &#125;</span><br></pre></td></tr></table></figure><p>而箭头函数的参数部分，可以用一个圆括号来代表参数部分。如果有多个参数则用<code>,</code>分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数示例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>总结起来就是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; &#123; 函数声明 &#125;</span><br><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; 表达式（单一）</span><br><span class="line"><span class="comment">//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只有一个参数时，圆括号是可选的：</span></span><br><span class="line">(单一参数) =&gt; &#123;函数声明&#125;</span><br><span class="line">单一参数 =&gt; &#123;函数声明&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有参数的函数应该写成一对圆括号。</span></span><br><span class="line">() =&gt; &#123;函数声明&#125;</span><br></pre></td></tr></table></figure><p>箭头函数的一个用处就是简化回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> materials = [</span><br><span class="line">  <span class="string">'Hydrogen'</span>,</span><br><span class="line">  <span class="string">'Helium'</span>,</span><br><span class="line">  <span class="string">'Lithium'</span>,</span><br><span class="line">  <span class="string">'Beryllium'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是常规写法的话</span></span><br><span class="line">materials.map(<span class="function"><span class="keyword">function</span>(<span class="params">material</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> material.length; </span><br><span class="line">&#125;); <span class="comment">// [8, 6, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而使用箭头函数简化的话</span></span><br><span class="line">materials.map(<span class="function"><span class="params">material</span> =&gt;</span> material.length); <span class="comment">// [8, 6, 7, 9]</span></span><br></pre></td></tr></table></figure><p>可以看到，如果用箭头函数，代码简化到了一行，并且清晰醒目。</p><p>在箭头函数出现之前，每个新定义的函数都有它自己的this值。而箭头函数体内的this值，就是定义时所在的对象，而不是使用时所在的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'id'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">50</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时的，而它的真正执行要等到100毫秒之后，如果是普通函数，执行时this应该指向全局函数window，这时应该输出21。但是箭头函数导致this总是指向函数定义生效时所在的对象，所以输出的是50。</p><p>通过call或者apply也可以调用箭头函数。</p><p>由于this已经在词法层面完成了绑定，通过call()或apply()方法调用一个函数时，只是传入了参数而已，对this并没有什么影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  base : <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">  add : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      base : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2（而不是3 ——译者注）</span></span><br></pre></td></tr></table></figure><p>箭头函数的用法还有很多种，我只是记录下初学的东西，还有很多深入用法的要在日常的编码中去思考。建议参考阮一峰老师的ES6的这本书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6之后，允许使用箭头&lt;code&gt;=&amp;gt;&lt;/code&gt;来定义函数。首先我们来总结一下箭头函数存在的意义，之后再来细细的看它的使用方法。&lt;/p&gt;
&lt;p&gt;箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this,arguments,super或者new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。&lt;/p&gt;
&lt;p&gt;讲完了箭头函数的意义，那么我们总最基础的示例开始看，先看一个常规语法定义的函数:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;funcName&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;params&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; params + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;funcName(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);		&lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果这个函数用箭头函数改写的话，仅仅需要一行代码就够了:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; funcName = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;params&lt;/span&gt;) =&amp;gt;&lt;/span&gt; params + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;funcName(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); 	&lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="箭头函数" scheme="http://yoursite.com/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6——扩展运算符使用</title>
    <link href="http://yoursite.com/2018/03/14/ES6%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/14/ES6——扩展运算符使用/</id>
    <published>2018-03-14T12:46:31.000Z</published>
    <updated>2018-03-14T12:47:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近又开始把大量的时间花费在了夯实前端基础上了，看了很多的前端规范，书籍，并且敲了大量的前端代码。系统的在补习自己的前端基础，于是乎可能是日久生情，我对javascript这门语言的感情也在慢慢加深。系统的学习ES6标准一定是学习前端必要的一件事。ES6中增加了不少新特性新语法，一边学习，一边记录。</p><p>初看ES6的代码，或许有许多同学不了解那三个点的用法，扩展运算符(spread)是三个点(<code>...</code>)。它好比rest的逆运算，将一个数组转化为用逗号分隔的参数序列。扩展运算符允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组字面量）或多个变量（用于解构赋值）的位置扩展。</p><a id="more"></a><p>来看一个用于函数调用的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunction(...iterableObj);</span><br></pre></td></tr></table></figure><p>用于数组字面量的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>[...iterableObj] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">[...iterableObj, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="comment">// [1, 3, 5, 7, 9, 0, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, ...iterableObj, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">// [0, 2, 1, 3, 5, 7, 9, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>用于对象字面量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objClone = &#123; ...obj&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里要注意，<strong>…rest</strong>必须是参数列表的最后一个参数！</p><p>但是 <strong>…spread</strong>无限制</p></blockquote><h2 id="扩展运算符的使用示例"><a href="#扩展运算符的使用示例" class="headerlink" title="扩展运算符的使用示例"></a>扩展运算符的使用示例</h2><h3 id="替换apply方法"><a href="#替换apply方法" class="headerlink" title="替换apply方法"></a>替换apply方法</h3><p>在需要使用数组作为函数参数的情况下，通常使用<code>apply</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">myFunction.apply(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure><p>如果使用了扩展运算符，我们可以这么来表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">myFunction(...args);</span><br></pre></td></tr></table></figure><p>还可以同时展开多个数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">v, w, x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">myFunction(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><h3 id="更方便的数组字面量"><a href="#更方便的数组字面量" class="headerlink" title="更方便的数组字面量"></a>更方便的数组字面量</h3><p>如果已经有一个数组，此时还需要再新建一个数组，要求新数组包含已有数组的数组项的话，就要用push，splice，concat等数组方法，但是有了扩展运算符之后，这些麻烦似乎都不存在了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parts = [<span class="string">'shoulder'</span>, <span class="string">'knees'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Tshirts = [<span class="string">'Lee'</span>, <span class="string">'Nike'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lyrics = [<span class="string">'head'</span>, ...parts, <span class="string">'and'</span>, <span class="string">'toes'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["head", "shoulder", "knees", "and", "toes"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lyrics = [<span class="string">'head'</span>, ...parts, <span class="string">'and'</span>, <span class="string">'toes'</span>, ...Tshirts];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["head", "shoulder", "knees", "and", "toes", "Lee", "Nike"]</span></span><br></pre></td></tr></table></figure><p>就像扩展参数列表一样， <code>...</code>可以在数组字面量中的任何地方使用，可以多次使用。</p><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]; <span class="comment">// 就像是 arr.slice()</span></span><br><span class="line"></span><br><span class="line">arr2.push(<span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arr 不受影响</span></span><br></pre></td></tr></table></figure><h3 id="配合new运算符"><a href="#配合new运算符" class="headerlink" title="配合new运算符"></a>配合new运算符</h3><p>在ES5中，我们无法使用同时使用new运算符和apply方法（apply方法调用[[call]]而不是[[Construct]]）。在ES6中，我们可以使用扩展运算符，就和普通的函数调用一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFields = [<span class="number">1970</span>, <span class="number">0</span>, <span class="number">1</span>];  </span><br><span class="line"><span class="comment">// 1 Jan 1970</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateFields = readDateFields(database);</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又开始把大量的时间花费在了夯实前端基础上了，看了很多的前端规范，书籍，并且敲了大量的前端代码。系统的在补习自己的前端基础，于是乎可能是日久生情，我对javascript这门语言的感情也在慢慢加深。系统的学习ES6标准一定是学习前端必要的一件事。ES6中增加了不少新特性新语法，一边学习，一边记录。&lt;/p&gt;
&lt;p&gt;初看ES6的代码，或许有许多同学不了解那三个点的用法，扩展运算符(spread)是三个点(&lt;code&gt;...&lt;/code&gt;)。它好比rest的逆运算，将一个数组转化为用逗号分隔的参数序列。扩展运算符允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组字面量）或多个变量（用于解构赋值）的位置扩展。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Python——爬虫实战 爬取淘宝店铺内所有宝贝图片</title>
    <link href="http://yoursite.com/2018/03/07/Python%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%BA%97%E9%93%BA%E5%86%85%E6%89%80%E6%9C%89%E5%AE%9D%E8%B4%9D%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/03/07/Python——爬虫实战-爬取淘宝店铺内所有宝贝图片/</id>
    <published>2018-03-06T23:04:01.000Z</published>
    <updated>2018-03-06T23:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前用四篇很啰嗦的入门级别的文章，带着大家一起去了解并学习在编写爬虫的过程中，最基本的几个库的用法。</p><p>那么今天，我们就正式开始我们的第一篇实战内容，爬取一整个淘宝店铺里的所有宝贝的详情页，并且把详情页里的宝贝图片保存下来。我自己刚开了一个小网店，当时写出这个爬虫，也是真真正正的为我自己服务了一回呢。</p><p>在写之前，我先把这个爬虫的代码分析一下，方便大家在看代码的时候，理解整个流程是怎么样的。</p><a id="more"></a><p>爬虫框架我一直是使用Scrapy的，在用Scrapy抓取店铺信息的时候，因为淘宝的反爬机制，发现了机器人，所以获取不到任何信息，当时我赶着用宝贝图片，所以我使用了之前介绍的selenium来获取网页信息，并且通过我们上一篇介绍的lxml框架来提取信息。最主要的库就是这两个，那么我针对这个爬虫，编写了一个叫做<code>taobaoShop</code>的爬虫类。</p><p>之后，我们首先进入店铺的首页，抓取首页所有商品的资料，并用他们的宝贝名，来生成文件夹，方便存储对应的详情图片，然后爬虫进入宝贝的详情页，从详情页中提取详情照片，并且保存在宝贝名称对应的文件夹中，在该页面所有的宝贝爬取完成后，咱们后检查是否有分页，如果还有下一页的宝贝，那么进入下一页的宝贝接着爬，过程就和刚刚描述的一样了。</p><p>所以我们的淘宝店铺爬虫类的初始化代码是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""初始化构造函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    self.site_url = <span class="string">'https://shop67309167.taobao.com/?spm=a230r.7195193.1997079397.2.xPZZS0'</span></span><br><span class="line">    self.driver = webdriver.Chrome()</span><br><span class="line">    self.sleep_time = <span class="number">10</span></span><br><span class="line">    self.save_img_path = <span class="string">'/Users/Lix/Documents/tbshop/'</span></span><br></pre></td></tr></table></figure><p>初始化中我们设置了要爬取的店铺url（这就是我的小店，如果可以的话，请各位大佬帮忙点个关注），另外是启动selenium中webdriver的代码，我用Chrome打开，静默的话可以选择Phantomjs打开，另外有个间歇时间，因为爬取的过快，会被淘宝判定为爬虫，弹出登录框，最后的<code>save_img_path</code>自然就是我保存图片的路径了。</p><p>在初始化的构造函数完成之后，我们首先获取的是淘宝店铺页面的网页信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""获取淘宝店铺页面代码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    self.driver.get(self.site_url)</span><br><span class="line">    time.sleep(self.sleep_time)</span><br><span class="line">    content = self.driver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">print</span> self.driver.title</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存html代码debug</span></span><br><span class="line">    <span class="comment"># self.saveHtml('taobaoshop', content)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分析该页面的每个宝贝</span></span><br><span class="line">    self.getItem()</span><br></pre></td></tr></table></figure><p>在获取到店铺的网页信息后，我们调用<code>getItem()</code>函数，获取每个宝贝的信息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItem</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""爬取当前页面的每个宝贝，</span></span><br><span class="line"><span class="string">       提取宝贝名字，价格，标题等信息</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    html = self.driver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    selector = etree.HTML(html)</span><br><span class="line">    itemList = selector.xpath(<span class="string">"//div[@class='item3line1']"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环遍历该页所有商品</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item3line1 <span class="keyword">in</span> itemList:</span><br><span class="line">        dl = item3line1.xpath(<span class="string">"./dl"</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dl:</span><br><span class="line">            link = <span class="string">'https:'</span> + item.xpath(<span class="string">"./dt/a/@href"</span>)[<span class="number">0</span>]</span><br><span class="line">            photo = <span class="string">'https:'</span> + item.xpath(<span class="string">"./dt/a/img/@src"</span>)[<span class="number">0</span>]</span><br><span class="line">            title = item.xpath(<span class="string">"./dd/a/text()"</span>)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">            res = &#123;</span><br><span class="line">                <span class="string">'link'</span> : link,</span><br><span class="line">                <span class="string">'photo'</span> : photo,</span><br><span class="line">                <span class="string">'title'</span> : title</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 进入宝贝详情页 开始爬取里面的图片资料</span></span><br><span class="line">            self.getItemDetail(link, <span class="string">''</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取分页信息</span></span><br><span class="line">    pagination = selector.xpath(<span class="string">"//div[@class='pagination']/a[contains(@class, 'J_SearchAsync') and contains(@class, 'next')]/@href"</span>)</span><br><span class="line">    <span class="keyword">print</span> pagination</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'正在准备切换分页'</span></span><br><span class="line">    <span class="keyword">if</span> len(pagination) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'没有下一页了'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'加载下一页内容'</span></span><br><span class="line">        self.site_url = <span class="string">'https:'</span> + pagination[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> self.site_url</span><br><span class="line">        self.getPage()</span><br><span class="line">```            </span><br><span class="line"></span><br><span class="line">在这里，我们看到我们已经获取到了宝贝的链接，封面图，标题。并且执行了`getItemDetail(self, link, save_img_path)`函数去爬取宝贝的详情页了，最后我们还在循环结束之后，分析了分页数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么最后，我们就来看看最关键的`getItemDetail()`函数，看看是怎么爬取宝贝信息的:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItemDetail</span><span class="params">(self, link, save_img_path)</span>:</span></span><br><span class="line">    <span class="string">"""从宝贝的详情链接里 爬取图片</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        link &#123;String&#125; -- [宝贝详情链接]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    newDriver = webdriver.Chrome()</span><br><span class="line">    newDriver.get(link)</span><br><span class="line">    time.sleep(self.sleep_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> newDriver.title</span><br><span class="line"></span><br><span class="line">    img_dir_path = self.save_img_path + newDriver.title.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">True</span> == self.mkdir(img_dir_path):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'创建宝贝目录成功'</span></span><br><span class="line"></span><br><span class="line">    html = newDriver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    selector = etree.HTML(html)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 封面图</span></span><br><span class="line">    J_ULThumb = selector.xpath(<span class="string">"//div[@class='tb-gallery']/ul/li"</span>)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> J_ULThumb:</span><br><span class="line">        <span class="comment"># 替换图片 从50*50 至 400 * 400</span></span><br><span class="line">        <span class="keyword">if</span> len(li.xpath(<span class="string">"./div/a/img/@data-src"</span>)) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        small_pic = li.xpath(<span class="string">"./div/a/img/@data-src"</span>)[<span class="number">0</span>]</span><br><span class="line">        common_pic = <span class="string">'https:'</span> + small_pic.replace(<span class="string">'50x50'</span>, <span class="string">'400x400'</span>)</span><br><span class="line">        thumb_title = str(<span class="string">'封面图'</span>) + str(index)</span><br><span class="line">        <span class="keyword">print</span> thumb_title</span><br><span class="line">        <span class="comment"># self.saveImg(img_dir_path, common_pic, thumb_title.decode('utf-8'))</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬取里面所有图片</span></span><br><span class="line">    all_img = selector.xpath(<span class="string">"//div[@id='J_DivItemDesc']//descendant::img/@src"</span>)</span><br><span class="line">    <span class="keyword">print</span> all_img</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> all_img:</span><br><span class="line">        imglink = img</span><br><span class="line">        <span class="keyword">if</span> img.startswith(<span class="string">'http'</span>) <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">            imglink = img</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            imglink = <span class="string">'https:'</span> + img</span><br><span class="line"></span><br><span class="line">        self.saveImg(img_dir_path, imglink, str(index))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    newDriver.quit()</span><br></pre></td></tr></table></figure><p>注释都写在代码里了，大家看看就好，这里有很多地方的代码不够优雅，那是我当天急着用，所以后来也没有去优化了。</p><p>在这个核心解析代码的完成之后，宝贝图片就已经稳稳的存储到我们的硬盘上了，可以开箱即用了。完整的代码我也放在了<a href="https://github.com/originalix/Original/blob/master/python2.7/taobaoshop.py" target="_blank" rel="noopener">Github</a>上了，如果对您有帮助，请帮忙star一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用四篇很啰嗦的入门级别的文章，带着大家一起去了解并学习在编写爬虫的过程中，最基本的几个库的用法。&lt;/p&gt;
&lt;p&gt;那么今天，我们就正式开始我们的第一篇实战内容，爬取一整个淘宝店铺里的所有宝贝的详情页，并且把详情页里的宝贝图片保存下来。我自己刚开了一个小网店，当时写出这个爬虫，也是真真正正的为我自己服务了一回呢。&lt;/p&gt;
&lt;p&gt;在写之前，我先把这个爬虫的代码分析一下，方便大家在看代码的时候，理解整个流程是怎么样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python——爬虫入门XPath的使用</title>
    <link href="http://yoursite.com/2018/02/27/Python%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8XPath%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/27/Python——爬虫入门XPath的使用/</id>
    <published>2018-02-27T12:30:35.000Z</published>
    <updated>2018-02-27T12:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Xpath即为XML路径语言（XML Path Language）。它是一种用来确定XML文档中某部分位置的语言。</p><p>XPath基于XML的树状结构，提供在数据结构树种找寻节点的能力。起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型。但是XPath很快的被开发者采用来当做小型查询语言。</p><p>由于XPath确定XML文档中定位的能力，我们在用Python写爬虫时，常常使用XPath来确定HTML中的位置，辅助我们编写爬虫，抓取数据。</p><a id="more"></a><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>在Xpath中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或者称为根节点）。</p><p>下面举几个节点的例子来说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的XML文档中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span>  (文档节点)</span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> (元素节点)</span><br><span class="line">lang="en" (属性节点)</span><br></pre></td></tr></table></figure><h2 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h2><p>Xpath最常见的表达式就是路径表达式（XPath这一名称的另一来源）。路径表达式是从一个XML节点（当前的上下文节点）到另一个节点、或一组节点的书面步骤顺序。这些步骤以“/”字符分开，每一步有三个构成部分。</p><ul><li>轴描述（用最直接的方式接近目标节点）</li><li>节点测试（用于筛选节点位置和名称）</li><li>节点描述（用于筛选节点的属性和子节点特征）</li></ul><p>一般情况下，我们使用简写后的语法，虽然完整的轴描述是一种更加贴近人类语言，利用自然语言的单词和语法来书写的描述方式，但是相比之下也更加啰嗦。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>我们将在下面的例子中使用这个XML文档。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"eng"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"eng"</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们来使用路径表达式在上面的XML文档中选取节点。</p><p>节点是通过沿着路径或者step来选取的。</p><p>下面表格列举的是最有用的路径表达式:</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此结点的所有节点</td></tr><tr><td>/</td><td>从根节点选取</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><p>而下面的这个表格，我已经列出了一些路径表达式以及表达式的结果</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>bookstore</td><td>选取 bookstore 元素的所有子节点</td></tr><tr><td>/bookstore</td><td>选取根元素bookstore ps: 假如路径起始于正斜杠(/),则此路径始终代表到某元素的绝对路径</td></tr><tr><td>bookstore/book</td><td>选取属于bookstore的子元素的所有book元素 </td></tr><tr><td>//book</td><td>选取所有book子元素，而不管它们在文档中的位置</td></tr><tr><td>bookstore//book</td><td>选择属于bookstore元素的后代的所有book元素，而不管它们位于bookstore之下的什么位置</td></tr><tr><td>//@lang</td><td>选取名为lang的所有属性</td></tr></tbody></table><h2 id="通配符选用节点"><a href="#通配符选用节点" class="headerlink" title="通配符选用节点"></a>通配符选用节点</h2><p>XPath通配符可用来选取未知的XML元素</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配任何元素节点</td></tr><tr><td>@*</td><td>匹配任何属性节点 </td></tr><tr><td>node()</td><td>匹配任何类型的节点</td></tr></tbody></table><h2 id="Python中的XPath库"><a href="#Python中的XPath库" class="headerlink" title="Python中的XPath库"></a>Python中的XPath库</h2><p>通过 Python 的 LXML 库利用 XPath 进行 HTML 的解析。</p><p>lxml用法源自 lxml python 官方文档，更多内容请直接参阅官方文档，本文对其进行翻译与整理。</p><p>安装lxml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><p>现在我们简单的介绍完了XPath的语法，对于爬虫的准备知识已经铺垫完毕了，从下一篇博客开始，就要进入爬虫的实战教程了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xpath即为XML路径语言（XML Path Language）。它是一种用来确定XML文档中某部分位置的语言。&lt;/p&gt;
&lt;p&gt;XPath基于XML的树状结构，提供在数据结构树种找寻节点的能力。起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型。但是XPath很快的被开发者采用来当做小型查询语言。&lt;/p&gt;
&lt;p&gt;由于XPath确定XML文档中定位的能力，我们在用Python写爬虫时，常常使用XPath来确定HTML中的位置，辅助我们编写爬虫，抓取数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="XPath" scheme="http://yoursite.com/tags/XPath/"/>
    
  </entry>
  
  <entry>
    <title>Python——爬虫入门Selenium的简单使用</title>
    <link href="http://yoursite.com/2018/02/22/Python%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8Selenium%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/22/Python——爬虫入门Selenium的简单使用/</id>
    <published>2018-02-21T23:34:29.000Z</published>
    <updated>2018-02-21T23:37:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前的两篇我们讲解了Python内的urllib库的使用，不知道大家有没有在爬取一些动态网站的时候，发现自己用urllib爬取到的内容是不对的，无法抓取到自己想要的内容，比如淘宝的店铺宝贝等，它会用js动态的加载内容，此时selenium这个家伙就能派上用场了。</p><p>selenium是什么？简单的概括，它的初衷就是自动化测试工具。它支持各种浏览器，包括chrome，safari，firefox等主流界面式浏览器，如果你在这些浏览器里安装一个selenium的插件，那么便可以方便的实现Web界面的测试。换句话说selenium支持这些浏览器驱动，selenium支持多种语言开发，比如Python、Java、C、Ruby等等。</p><a id="more"></a><p>而在爬虫这个领域，我们则用这个自动化测试工具来模拟我们是真实的浏览器用户，用他来爬取页面非常方便，只要按照访问步骤模拟人在操作就可以了，完全不用操心cookie，session的处理，它甚至可以帮助你输入账户、密码，然后点击登录按钮，这些功能在应对一些常见的反爬虫机制时非常有用。</p><p>在我们开始示例代码之前，首先你要在Python中安装selenium库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>安装好了之后，我们便开始探索抓取方法了。</p><p>那么我们就把一个淘宝店铺为示例，试着来爬取他里面的宝贝列表。你可以先用urllib来验证一下这个url，是不是爬取不到浏览器显示的dom内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Lix'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selenium_example</span><span class="params">()</span>:</span></span><br><span class="line">    site_url = <span class="string">'https://elcjstyle.taobao.com/search.htm?spm=a1z10.1-c-s.0.0.68616fccLXsimv&amp;search=y'</span></span><br><span class="line"></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    driver.get(site_url)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    content = driver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">print</span> driver.title</span><br><span class="line">    <span class="keyword">print</span> content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    selenium_example()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行完这段示例代码之后，不出意外会打印出店铺名字和整张页面的html代码。可以把这个代码和Chrome内调试环境下看到的html代码比较一下，是否完全一样了。</p><p>而在selenium中，更是有很多不同的策略可以定位到一个元素，实现它本身的自动化测试目的，而我们也可以配合<code>Beautiful Soup</code>或者<code>Xpath</code>来提取我们想要的内容。</p><p>一次查找多个元素 (这些方法会返回一个list列表):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find_elements_by_name</span><br><span class="line">find_elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure><p>假如我们要通过name来查找一个元素:</p><p>页面元素如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"loginForm"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"continue"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"continue"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Clear"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>name属性为 username &amp; password 的元素可以像下面这样查找:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = driver.find_element_by_name(<span class="string">'username'</span>)</span><br><span class="line">password = driver.find_element_by_name(<span class="string">'password'</span>)</span><br></pre></td></tr></table></figure><p>通过这样的两句代码，我们就能提取到username和password的元素，所以selenium真的是一个很有用的工具呢。</p><p>关于selenium更多的用法，希望大家能认真阅读他的文档。这一定是一个会让你非常受用的工具的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的两篇我们讲解了Python内的urllib库的使用，不知道大家有没有在爬取一些动态网站的时候，发现自己用urllib爬取到的内容是不对的，无法抓取到自己想要的内容，比如淘宝的店铺宝贝等，它会用js动态的加载内容，此时selenium这个家伙就能派上用场了。&lt;/p&gt;
&lt;p&gt;selenium是什么？简单的概括，它的初衷就是自动化测试工具。它支持各种浏览器，包括chrome，safari，firefox等主流界面式浏览器，如果你在这些浏览器里安装一个selenium的插件，那么便可以方便的实现Web界面的测试。换句话说selenium支持这些浏览器驱动，selenium支持多种语言开发，比如Python、Java、C、Ruby等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Selenium" scheme="http://yoursite.com/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>Python——爬虫入门 Urllib库的进阶</title>
    <link href="http://yoursite.com/2018/02/07/Python%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-Urllib%E5%BA%93%E7%9A%84%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/02/07/Python——爬虫入门-Urllib库的进阶/</id>
    <published>2018-02-07T13:06:30.000Z</published>
    <updated>2018-02-07T13:07:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我们简单讲解了Urllib库的基础用法，包括如何获取请求之后的页面响应，如何使用POST请求上传数据，今天我们就来讲讲Urllib库的几个进阶用法。</p><a id="more"></a><h2 id="Headers"><a href="#Headers" class="headerlink" title="Headers:"></a>Headers:</h2><p>我们先讨论关于请求头的使用，如何构造HTTP-Headers。我们先进入Chrome浏览器打开调试模式，</p><p><img src="http://originalix.github.io/images/python-urllib.png" alt=""></p><p>在network一栏中找到Headers，在里面我们能看到Request Headers，这就是我们发送当前页面请求所用的请求头。其中User-Agent就是请求的身份，如果没有写入这个信息，那么有可能初级的反爬虫策略就会识别我们不是基于浏览器的请求，这次的请求就不会被响应了。</p><p>所以我们今天的第一段代码就是展示如何构造这个User-Agent的请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib  </span><br><span class="line"><span class="keyword">import</span> urllib2  </span><br><span class="line"> </span><br><span class="line">url = <span class="string">'http://originalix.github.io/#blog'</span></span><br><span class="line">user_agent = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36'</span>  </span><br><span class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;  </span><br><span class="line">request = urllib2.Request(url, <span class="keyword">None</span>, headers)  </span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">html = response.read()</span><br><span class="line"><span class="keyword">print</span> html</span><br></pre></td></tr></table></figure><p>上面的代码中的请求，我们就构造了一个携带携带User-Agent字段的请求，以后如果没有响应的页面，可要记得检查检查是不是忘记了在请求头里做文章了。</p><h2 id="URLError："><a href="#URLError：" class="headerlink" title="URLError："></a>URLError：</h2><p>通常，URLError被抛出是因为网络请求出现了错误，比如服务器访问错误，或者访问的站点不存在，在这种情况下都会抛出一个URLError,这个错误是一个包含着reason和code的元组，分别对应着错误消息和错误代码。我们可以用try/except语句来捕获异常，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># URLError</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">req = urllib2.Request = (<span class="string">'http://www.lixxxxxxxx.com'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    urllib2.urlopen(req)</span><br><span class="line"><span class="keyword">except</span> urllib2.URLError <span class="keyword">as</span> e :</span><br><span class="line">    <span class="keyword">print</span> e.reason</span><br></pre></td></tr></table></figure><p>在接触URLError之前，大家一定更早的接触过HTTPError，每个来自服务器的HTTP应答都会携带着一个包含数值的状态码，例如我们耳熟能详的200、404(页面丢失)、403(请求被禁止)等等。HTTPError的异常实例拥有一个整型的code属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时处理HTTPError和URLError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.lixxxxxxxx.com'</span></span><br><span class="line">req = urllib2.Request(url)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">response = urllib2.urlopen(req)</span><br><span class="line"><span class="keyword">except</span> urllib2.HTTPError <span class="keyword">as</span> e:</span><br><span class="line"><span class="keyword">print</span> e.code</span><br><span class="line"><span class="keyword">print</span> <span class="string">'we can not fulfill the request \n'</span></span><br><span class="line"><span class="keyword">except</span> urllib2.URLError <span class="keyword">as</span> e:</span><br><span class="line"><span class="keyword">print</span> e.reason</span><br><span class="line"><span class="keyword">print</span> <span class="string">'we can not reach a server'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'No problem'</span>)</span><br></pre></td></tr></table></figure><p>上面的代码是一个同时处理HTTPError和URLError的例子，记得一定要把HTTPError放在前面处理，因为HTTPError是URLError的子集。</p><p>最后诸如代理什么的也就不讲解了，因为我觉得使用到这些的时候，大家可能就不会使用urllib2这个库了，有更好的轮子在等着你们。放上urllib2库的官方文档，有不懂的可以速查哟。 <a href="https://docs.python.org/2/library/urllib2.html" target="_blank" rel="noopener">urllib2官方文档任意门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我们简单讲解了Urllib库的基础用法，包括如何获取请求之后的页面响应，如何使用POST请求上传数据，今天我们就来讲讲Urllib库的几个进阶用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python——爬虫入门 Urllib库的使用</title>
    <link href="http://yoursite.com/2018/01/28/Python%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-Urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/28/Python——爬虫入门-Urllib库的使用/</id>
    <published>2018-01-28T12:44:16.000Z</published>
    <updated>2018-01-28T12:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在系统的学习Python爬虫，觉得还是比较有意思的，能够干很多的事情，所以也写点文章记录一下学习过程，帮助日后回顾。</p><p>网上关于Python的爬虫文章、教程特别多，尤其是喜欢刷知乎的用户，我总是感觉其他语言都是讨论xx框架如何，xx如何进阶，而Pythoner一开专栏，保准是xx爬虫入门教学，于是想零基础的入门Python爬虫也是非常容易的一件事，但是事实上会和达到工作要求，之间要学习补充的东西还是非常非常多的。</p><p>我在初学爬虫这段时间内，对于爬虫的流程，简单的概括为下面四步骤：网页 -&gt; 网页源代码 -&gt; 正则表达式 -&gt; 需要的内容。而针对这四个方面展开则有许多许多可以提升并完善的细节，例如一个网页，我们就可以从在浏览器的地址栏敲入url之后说起。当然，这里我是不准备展开来说的。</p><p>而目前的文章我打算从爬虫的入门开始写，看看是否可以写出一个系列来记录，完成品是争取带大家爬出一个动态js加载的妹子页面。</p><p>爬虫的功能往简单的说就是把网页源代码想办法爬下来，然后分析我们需要的内容，总结起来就是两个部分：</p><ul><li><p>爬！</p></li><li><p>提取。</p></li></ul><a id="more"></a><p>所以整个过程里需要掌握的技能就是如何爬，以及爬到之后如何处理。</p><p>所以今天的入门文章里，我们就不去介绍第三方库的工具如何使用，我们来看看Python自带的标准库——Urllib库。</p><h1 id="Urllib"><a href="#Urllib" class="headerlink" title="Urllib"></a>Urllib</h1><p>这个自带的标准库提供了诸如网页请求、响应获取、代理和cookie设置、异常处理、URL解析等等功能。</p><p>一个爬虫所需要的功能，基本上在urllib中都能找到，学习这个标准库，可以更加深入的理解之后要用到的第三方库，包括提高对于爬虫框架的理解。</p><p>那我们就从第一个网页的爬取入手，现在我们首先打开我们的编辑器，创建一个Python文件，并且在里面写入如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>是的，就是这么简短的代码，现在我们来运行一下这个py文件。在命令行中能看到爬取到的百度网站的一堆html代码。是的，你没有看错，想抓到百度的html页面，只要这么简单的两行代码，看到命令行里反馈回来的这么多代码，是不是心里一阵痛快！</p><p>好，我们我们开始从头分析我们的三行代码，第一行，我们import了我们的urllib2的库。</p><p>第二行代码，我们使用urlopen的api，传入了url参数，执行urlopen方法后，就返回了一个response对象，我们打印的返回信息便保存在里面。</p><p>第三行代码，我们打印了response响应对象里的内容，并且转换成了utf-8编码，你可以试试如果去掉了utf-8的编码，是不是会乱码呢？</p><p>而我们请求之前，也可以根据urllib2提供的request的类，在发送请求前构造一个request的对象，然后通过urllib的urlopen函数来发送请求。例如上面请求百度的代码也可以写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">url = <span class="string">r'http://www.baidu.com'</span></span><br><span class="line">req = urllib2.Request(url)</span><br><span class="line">html = urllib2.urlopen(req).read()</span><br><span class="line"><span class="keyword">print</span> html</span><br></pre></td></tr></table></figure><p>我们先用<code>req = urllib2.Request(url)</code>实例化了一个request对象，之后再请求打开这个网页。</p><p>而我们常用的HTTP协议里还有GET、POST等方法的请求，我们该如何实现呢，以Post请求为例，我们怎么发送一个携带着数据的请求呢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'http://www.baidu.com/'</span></span><br><span class="line">params = &#123;<span class="string">'name'</span> : <span class="string">'Lix'</span>, <span class="string">'location'</span> : <span class="string">'China'</span>&#125;</span><br><span class="line">data = urllib.urlencode(params)</span><br><span class="line">req = urllib2.Request(url,data)</span><br><span class="line">response = urllib2.urlopen(req)</span><br><span class="line">the_page = response.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> the_page</span><br></pre></td></tr></table></figure><p>这样就可以完成一个post请求，至于GET方法，我们举例的第一段代码就是get类型的哦。</p><p>根据现在讲解的一些基本知识，我们就可以抓取到一些简单的页面的数据了，之后更深的内容我们在之后的文章里接着分析哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在系统的学习Python爬虫，觉得还是比较有意思的，能够干很多的事情，所以也写点文章记录一下学习过程，帮助日后回顾。&lt;/p&gt;
&lt;p&gt;网上关于Python的爬虫文章、教程特别多，尤其是喜欢刷知乎的用户，我总是感觉其他语言都是讨论xx框架如何，xx如何进阶，而Pythoner一开专栏，保准是xx爬虫入门教学，于是想零基础的入门Python爬虫也是非常容易的一件事，但是事实上会和达到工作要求，之间要学习补充的东西还是非常非常多的。&lt;/p&gt;
&lt;p&gt;我在初学爬虫这段时间内，对于爬虫的流程，简单的概括为下面四步骤：网页 -&amp;gt; 网页源代码 -&amp;gt; 正则表达式 -&amp;gt; 需要的内容。而针对这四个方面展开则有许多许多可以提升并完善的细节，例如一个网页，我们就可以从在浏览器的地址栏敲入url之后说起。当然，这里我是不准备展开来说的。&lt;/p&gt;
&lt;p&gt;而目前的文章我打算从爬虫的入门开始写，看看是否可以写出一个系列来记录，完成品是争取带大家爬出一个动态js加载的妹子页面。&lt;/p&gt;
&lt;p&gt;爬虫的功能往简单的说就是把网页源代码想办法爬下来，然后分析我们需要的内容，总结起来就是两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;爬！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提取。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python——搞定烦人的字符串编码</title>
    <link href="http://yoursite.com/2018/01/17/Python%E2%80%94%E2%80%94%E6%90%9E%E5%AE%9A%E7%83%A6%E4%BA%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2018/01/17/Python——搞定烦人的字符串编码/</id>
    <published>2018-01-17T12:31:36.000Z</published>
    <updated>2018-01-17T12:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>注意：以下讨论为Python2.x版本</p><p>在学习Python之前，就听说过Python的版本圣战，最可怕的是有的写Py3的程序员觉得Py2是另一种语言….所以在刚开始学习的时候，我索性把Python3和Python2的文档都看了一遍。</p><p>在之后写爬虫的过程中，我还是选择使用了Python2.x来写，原因嘛，emmmmm，可能就是因为一些好用的库或者框架的示例代码也是用旧一点的版本，所以为了效率，先用旧版本上手得了。在学习Python2之前，我还特意去比较了2和3的区别，其中着重被提及的就是字符串编码的问题，于是乎我在看旧版本文档的时候很仔细的去阅读了Python2的字符串部分。</p><a id="more"></a><p>然而结局证明，仔细阅读之后还是too young too simple，在读取文件，处理参数，以及处理http链接的过程中，经常一运行，发生两个对于Python的开发者熟悉的不能再熟悉的报错了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">'ascii'</span> codec can<span class="string">'t decode byte 0xe6 in position 0: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure><p>怎么样，是不是非常眼熟上面的两句话，好吧，我承认我这个小白一开始发现有这种编码问题的时候，就是调用encode/decode各种调试，期望这两个函数中有一个能够生效，救救我苟延残喘的程序，而在最初的时候，好像这样做还挺有效果的。</p><p>但是好运不长，在编写爬虫的过程中，随着处理字符串的量越来越大，http请求参数越来越多，往往一个参数是由好几个参数拼接而成的，而有时候你并不知道是哪个地方出了问题，盲目的替换和使用encode/decode方法效率非常低下。而造成这个问题的原因，就是没有明确的思考为什么会出现编码错误，授人以鱼不如授人以渔，所以我们今天要来从根上探究一下这个问题。</p><h1 id="编码的简介"><a href="#编码的简介" class="headerlink" title="编码的简介"></a>编码的简介</h1><p>首先，作为一名程序员，我想ASCII、Unicode、UTF-8三种字符编码大家肯定是听到过的，而这三种编码到底有什么区别呢？</p><p>ASCII是美国信息交换标准代码，是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。</p><p>Unicode是电脑科学领域里的一项业界标准，它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用以更为简单的方式来呈现和处理文字。</p><p>UTF-8是一种正对Unicode的可变长度字元编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字元，且其编码中的第一个位元组仍与ASCII相容，这使得原来处理的ASCII的软体无须或只须少部分修改，即可以继续使用，因此，它逐渐成为了电子邮件、网页以及其他存储或传送文字的应用中，优先采用的编码。</p><h1 id="判断编码类型"><a href="#判断编码类型" class="headerlink" title="判断编码类型"></a>判断编码类型</h1><p>在简单的介绍了三种编码之后，我们首先在处理字符编码问题的时候，搞清楚我们到底处理的是什么类型的编码。因为在Python中str和unicode都是<code>basestring</code>的子类，所以我们可以用下面的方法判断我们处理的类型是否为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool = isinstance(s, basestring)</span><br></pre></td></tr></table></figure><p>而str和unicode的转换也非常简单，总结一下就是如下的样子:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">str  -&gt; decode('coding') -&gt; unicode</span><br><span class="line">unicode -&gt; encode('coding') -&gt; str</span><br></pre></td></tr></table></figure><p>可以看出，str这个字符串，是由unicode经过编码后的字节形成的。而在字符串前面加u，就是unicode类型了。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'富强民主文明和谐'</span></span><br><span class="line">s = <span class="string">u'富强民主文明和谐'</span>.encode(<span class="string">'uft-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">'富强民主文明和谐'</span>)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure><p>而分析str字符串长度的时候，可以看到返回的字节数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">u'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>每个中文在UTF-8编码中，通常占用三个字节，这个结果是正确的。值得注意的是，unicode的字符编码和utf-8的存储编码表示是不同的。</p><p>上面的代码是分析了utf-8字符串的编码，而接下来，我们要分析真正的unicode字符编码，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">u'富强民主文明和谐'</span></span><br><span class="line">s = <span class="string">'富强民主文明和谐'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">s = unicode(<span class="string">'富强民主文明和谐'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u'富强民主文明和谐'</span>)</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br></pre></td></tr></table></figure><p>从长度来观察unicode字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span></span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">u'中文'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>上面的结果是unicode的字符分析结果。</p><p>所以我们在处理字符串的时候，要搞清楚我们处理的str还是unicode，使用正确的处理方法来处理。</p><p>教给大家一个简便的记忆方法，不要对str使用encode，而对于unicode也不要使用decode。其实是有特殊情况的，但是为了少出错，建议新手先这么处理呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注意：以下讨论为Python2.x版本&lt;/p&gt;
&lt;p&gt;在学习Python之前，就听说过Python的版本圣战，最可怕的是有的写Py3的程序员觉得Py2是另一种语言….所以在刚开始学习的时候，我索性把Python3和Python2的文档都看了一遍。&lt;/p&gt;
&lt;p&gt;在之后写爬虫的过程中，我还是选择使用了Python2.x来写，原因嘛，emmmmm，可能就是因为一些好用的库或者框架的示例代码也是用旧一点的版本，所以为了效率，先用旧版本上手得了。在学习Python2之前，我还特意去比较了2和3的区别，其中着重被提及的就是字符串编码的问题，于是乎我在看旧版本文档的时候很仔细的去阅读了Python2的字符串部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="编码" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Rem布局的原理探究</title>
    <link href="http://yoursite.com/2018/01/09/Rem%E5%B8%83%E5%B1%80%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/01/09/Rem布局的原理探究/</id>
    <published>2018-01-09T13:16:22.000Z</published>
    <updated>2018-01-09T13:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在用前端给移动端页面写布局时，我接触到了Rem布局，但是老实说我也看了几篇手淘适配的文章，并且主要的目的是拿到代码写出demo，所以对于Rem我还是停留在只会使用的阶段，但是理解的并不透彻，所以要抽出时间，把rem布局的原理搞清楚。</p><a id="more"></a><h1 id="什么是em"><a href="#什么是em" class="headerlink" title="什么是em"></a>什么是em</h1><p>我相信所有接触学习过css布局的同学，一定在rem之前先听到过em的大名，但是大多数也许跟我一样，只是听过或者最多跟着W3C上的教程敲过一下demo，之后的工作学习中并没有使用em这个单位，那么在聊rem之前，我们先聊聊em，毕竟混淆这两个单位的同学还是存在的。</p><p>用户的浏览器渲染的默认字体大小是”16px”，换句话说，Web页面中“body”的文字大小在浏览器下默认渲染是”16px”。当然，如果用户愿意也可以改变这个字体大小。而”em”是一个相对的大小，它的大小是相对于元素父元素的font-size。比如在body下直接写一个p标签，并且设置这个p标签的字体大小是”2em”, 那么其文字大小计算出来就是相当于<code>2 * 16px = 32px</code>。一个例子就能明了，em是相对于当前元素的父元素的font-size。而之前的弹性设计，有一个关键地方就是Web的所有元素都使用“em”单位。</p><p>体验后，是不是觉得弹性布局的页面很灵活呀，而且也像“px”一样的精确。因此，只要我们掌握了“font-size”、“px”和“em”之间的基本关系，我们就可以快速使用CSS创建精确的布局。</p><h1 id="什么是Rem"><a href="#什么是Rem" class="headerlink" title="什么是Rem"></a>什么是Rem</h1><p>看完了刚才em的介绍，是不是对于em的概念逐渐清晰，并且希望用em去构建自己的弹性布局呢。且慢，心急吃不了热豆腐，不妨听我把rem也慢慢的介绍完，毕竟主角光环的都是最后才出场的。rem是css3引入的一个单位，那我们为什么要在有em这个可以充当弹性布局的单位时还要引入rem呢？</p><p>em可以让我们的页面更灵活，比起到处写死的px值，em显得更有张力，根据比例的变化来调节屏幕。有的人提出用em来做弹性布局的页面，但是还是兔内污！如果你想一边看着标注图，一边算着em值，那你可以试试哦。不过聪明的程序员是不会去做这么无脑的事情的，所以有人写过px和em转换的计算器。但是你有没有想过，如果有一天，你的父节点的字体大小发生了变化，那么对于全局可能会产生相当大的影响，手算的同学是不是要全部重新计算，唉，害怕的我直接去写px了。😨！</p><p>所以针对这种繁琐运算的情况，rem应运而生，我们是这样定义rem的：</p><blockquote><p>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小</p></blockquote><p>rem的取值有两种情况，就是设置根元素和非根元素的时候，下面看个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>html是我们html页面的根元素，之前介绍em的时候，我们就知道浏览器默认渲染的字体大小是16px，所以html的字体大小是2rem，那么rem作用于根元素的字体大小相当于其初始字体大小的定论的话，html的字体大小就是32px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上面p标签的这个例子中，我们之前已经知道html的字体大小是32px，那么p标签的字体大小就是<code>2 * 32px = 64px</code>。</p><p>所以如果我们能合理的设置根元素的字体大小，那么rem的计算就会变得非常容易，比如手淘提出的将屏幕等宽划分成100份，那么标注图上的10px，即为0.1rem。所有的标注值除以100即可，根本不需要有计算的过程。</p><p>其实rem布局的本质也就是等比缩放，一般是基于宽度，假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示。 <code>x = 屏幕宽度 / 100</code>, 如果将x作为单位，x前面的数值就代表屏幕宽度的百分比。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123; width: 50x &#125; //屏幕宽度的50%</span><br></pre></td></tr></table></figure><p>而理解到这里，其实我们也就知道我们让页面最上面跑的js代码到底是什么意思了，我们就是需要让html元素字体的大小，恒等于屏幕宽度的1/100。那1rem和1x就等价了。</p><p>rem我们就分析到这里，到这里，可能有人会觉得在这个比较之下，em似乎完全没有用武之地，但是一个技术的存在肯定是得到很多使用者的肯定的，也是设计者几经考量才能决定放出使用的，所以技术没有高低，只是他们适用的场景，rem可能更适合写布局，而em可能就更适合来表达字体大小。所以我们要探究原理，选择合适的技术，提高自己的工作效率和作品质量。</p><p>今天的探究就到这里，rem的代码我就不贴了，手淘的代码一搜一大把呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用前端给移动端页面写布局时，我接触到了Rem布局，但是老实说我也看了几篇手淘适配的文章，并且主要的目的是拿到代码写出demo，所以对于Rem我还是停留在只会使用的阶段，但是理解的并不透彻，所以要抽出时间，把rem布局的原理搞清楚。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="layout" scheme="http://yoursite.com/tags/layout/"/>
    
  </entry>
  
</feed>
