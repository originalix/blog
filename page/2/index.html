<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Leon的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="移动端,iOS,Android,javascript,html5,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验">
<meta property="og:type" content="website">
<meta property="og:title" content="Leon的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Leon的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leon的博客">
  
    <link rel="alternate" href="/atom.xml" title="Leon的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Leon的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">每多学一点知识，就少写一行代码</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ES6——扩展运算符使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/ES6——扩展运算符使用/" class="article-date">
  <time datetime="2018-03-14T12:46:31.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/14/ES6——扩展运算符使用/">ES6——扩展运算符使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近又开始把大量的时间花费在了夯实前端基础上了，看了很多的前端规范，书籍，并且敲了大量的前端代码。系统的在补习自己的前端基础，于是乎可能是日久生情，我对javascript这门语言的感情也在慢慢加深。系统的学习ES6标准一定是学习前端必要的一件事。ES6中增加了不少新特性新语法，一边学习，一边记录。</p>
<p>初看ES6的代码，或许有许多同学不了解那三个点的用法，扩展运算符(spread)是三个点(<code>...</code>)。它好比rest的逆运算，将一个数组转化为用逗号分隔的参数序列。扩展运算符允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组字面量）或多个变量（用于解构赋值）的位置扩展。</p>
<p>&lt;!--more--&gt;</p>
<p>来看一个用于函数调用的例子：</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunction(...iterableObj);</span><br></pre></td></tr></table></figure></p>
<p>用于数组字面量的例子:</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>[...iterableObj] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">[...iterableObj, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="comment">// [1, 3, 5, 7, 9, 0, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, ...iterableObj, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">// [0, 2, 1, 3, 5, 7, 9, 4, 6, 8]</span></span><br></pre></td></tr></table></figure></p>
<p>用于对象字面量：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objClone = &#123; ...obj&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里要注意，<strong>...rest</strong>必须是参数列表的最后一个参数！</p>
<p>但是 <strong>...spread</strong>无限制</p>
</blockquote>
<h2>扩展运算符的使用示例</h2>
<h3>替换apply方法</h3>
<p>在需要使用数组作为函数参数的情况下，通常使用<code>apply</code>方法：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">myFunction.apply(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure></p>
<p>如果使用了扩展运算符，我们可以这么来表示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">myFunction(...args);</span><br></pre></td></tr></table></figure></p>
<p>还可以同时展开多个数组:</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">v, w, x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">myFunction(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></p>
<h3>更方便的数组字面量</h3>
<p>如果已经有一个数组，此时还需要再新建一个数组，要求新数组包含已有数组的数组项的话，就要用push，splice，concat等数组方法，但是有了扩展运算符之后，这些麻烦似乎都不存在了。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parts = [<span class="string">'shoulder'</span>, <span class="string">'knees'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Tshirts = [<span class="string">'Lee'</span>, <span class="string">'Nike'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lyrics = [<span class="string">'head'</span>, ...parts, <span class="string">'and'</span>, <span class="string">'toes'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["head", "shoulder", "knees", "and", "toes"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lyrics = [<span class="string">'head'</span>, ...parts, <span class="string">'and'</span>, <span class="string">'toes'</span>, ...Tshirts];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["head", "shoulder", "knees", "and", "toes", "Lee", "Nike"]</span></span><br></pre></td></tr></table></figure></p>
<p>就像扩展参数列表一样， <code>...</code>可以在数组字面量中的任何地方使用，可以多次使用。</p>
<h3>复制数组</h3>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]; <span class="comment">// 就像是 arr.slice()</span></span><br><span class="line"></span><br><span class="line">arr2.push(<span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arr 不受影响</span></span><br></pre></td></tr></table></figure></p>
<h3>配合new运算符</h3>
<p>在ES5中，我们无法使用同时使用new运算符和apply方法（apply方法调用[[call]]而不是[[Construct]]）。在ES6中，我们可以使用扩展运算符，就和普通的函数调用一样。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFields = [<span class="number">1970</span>, <span class="number">0</span>, <span class="number">1</span>];  </span><br><span class="line"><span class="comment">// 1 Jan 1970</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateFields = readDateFields(database);</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/14/ES6——扩展运算符使用/" data-id="cjptr3x3n0007lyz9fk12namk" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python——爬虫实战-爬取淘宝店铺内所有宝贝图片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/Python——爬虫实战-爬取淘宝店铺内所有宝贝图片/" class="article-date">
  <time datetime="2018-03-06T23:04:01.000Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/Python——爬虫实战-爬取淘宝店铺内所有宝贝图片/">Python——爬虫实战 爬取淘宝店铺内所有宝贝图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>之前用四篇很啰嗦的入门级别的文章，带着大家一起去了解并学习在编写爬虫的过程中，最基本的几个库的用法。</p>
<p>那么今天，我们就正式开始我们的第一篇实战内容，爬取一整个淘宝店铺里的所有宝贝的详情页，并且把详情页里的宝贝图片保存下来。我自己刚开了一个小网店，当时写出这个爬虫，也是真真正正的为我自己服务了一回呢。</p>
<p>在写之前，我先把这个爬虫的代码分析一下，方便大家在看代码的时候，理解整个流程是怎么样的。</p>
<p>&lt;!--more--&gt;</p>
<p>爬虫框架我一直是使用Scrapy的，在用Scrapy抓取店铺信息的时候，因为淘宝的反爬机制，发现了机器人，所以获取不到任何信息，当时我赶着用宝贝图片，所以我使用了之前介绍的selenium来获取网页信息，并且通过我们上一篇介绍的lxml框架来提取信息。最主要的库就是这两个，那么我针对这个爬虫，编写了一个叫做<code>taobaoShop</code>的爬虫类。</p>
<p>之后，我们首先进入店铺的首页，抓取首页所有商品的资料，并用他们的宝贝名，来生成文件夹，方便存储对应的详情图片，然后爬虫进入宝贝的详情页，从详情页中提取详情照片，并且保存在宝贝名称对应的文件夹中，在该页面所有的宝贝爬取完成后，咱们后检查是否有分页，如果还有下一页的宝贝，那么进入下一页的宝贝接着爬，过程就和刚刚描述的一样了。</p>
<p>所以我们的淘宝店铺爬虫类的初始化代码是这样的：</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""初始化构造函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    self.site_url = <span class="string">'https://shop67309167.taobao.com/?spm=a230r.7195193.1997079397.2.xPZZS0'</span></span><br><span class="line">    self.driver = webdriver.Chrome()</span><br><span class="line">    self.sleep_time = <span class="number">10</span></span><br><span class="line">    self.save_img_path = <span class="string">'/Users/Lix/Documents/tbshop/'</span></span><br></pre></td></tr></table></figure></p>
<p>初始化中我们设置了要爬取的店铺url（这就是我的小店，如果可以的话，请各位大佬帮忙点个关注），另外是启动selenium中webdriver的代码，我用Chrome打开，静默的话可以选择Phantomjs打开，另外有个间歇时间，因为爬取的过快，会被淘宝判定为爬虫，弹出登录框，最后的<code>save_img_path</code>自然就是我保存图片的路径了。</p>
<p>在初始化的构造函数完成之后，我们首先获取的是淘宝店铺页面的网页信息：</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""获取淘宝店铺页面代码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    self.driver.get(self.site_url)</span><br><span class="line">    time.sleep(self.sleep_time)</span><br><span class="line">    content = self.driver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">print</span> self.driver.title</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存html代码debug</span></span><br><span class="line">    <span class="comment"># self.saveHtml('taobaoshop', content)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分析该页面的每个宝贝</span></span><br><span class="line">    self.getItem()</span><br></pre></td></tr></table></figure></p>
<p>在获取到店铺的网页信息后，我们调用<code>getItem()</code>函数，获取每个宝贝的信息:</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItem</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""爬取当前页面的每个宝贝，</span></span><br><span class="line"><span class="string">       提取宝贝名字，价格，标题等信息</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    html = self.driver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    selector = etree.HTML(html)</span><br><span class="line">    itemList = selector.xpath(<span class="string">"//div[@class='item3line1']"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环遍历该页所有商品</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item3line1 <span class="keyword">in</span> itemList:</span><br><span class="line">        dl = item3line1.xpath(<span class="string">"./dl"</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dl:</span><br><span class="line">            link = <span class="string">'https:'</span> + item.xpath(<span class="string">"./dt/a/@href"</span>)[<span class="number">0</span>]</span><br><span class="line">            photo = <span class="string">'https:'</span> + item.xpath(<span class="string">"./dt/a/img/@src"</span>)[<span class="number">0</span>]</span><br><span class="line">            title = item.xpath(<span class="string">"./dd/a/text()"</span>)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">            res = &#123;</span><br><span class="line">                <span class="string">'link'</span> : link,</span><br><span class="line">                <span class="string">'photo'</span> : photo,</span><br><span class="line">                <span class="string">'title'</span> : title</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 进入宝贝详情页 开始爬取里面的图片资料</span></span><br><span class="line">            self.getItemDetail(link, <span class="string">''</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取分页信息</span></span><br><span class="line">    pagination = selector.xpath(<span class="string">"//div[@class='pagination']/a[contains(@class, 'J_SearchAsync') and contains(@class, 'next')]/@href"</span>)</span><br><span class="line">    <span class="keyword">print</span> pagination</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'正在准备切换分页'</span></span><br><span class="line">    <span class="keyword">if</span> len(pagination) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'没有下一页了'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'加载下一页内容'</span></span><br><span class="line">        self.site_url = <span class="string">'https:'</span> + pagination[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> self.site_url</span><br><span class="line">        self.getPage()</span><br><span class="line">```            </span><br><span class="line"></span><br><span class="line">在这里，我们看到我们已经获取到了宝贝的链接，封面图，标题。并且执行了`getItemDetail(self, link, save_img_path)`函数去爬取宝贝的详情页了，最后我们还在循环结束之后，分析了分页数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么最后，我们就来看看最关键的`getItemDetail()`函数，看看是怎么爬取宝贝信息的:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItemDetail</span><span class="params">(self, link, save_img_path)</span>:</span></span><br><span class="line">    <span class="string">"""从宝贝的详情链接里 爬取图片</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        link &#123;String&#125; -- [宝贝详情链接]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    newDriver = webdriver.Chrome()</span><br><span class="line">    newDriver.get(link)</span><br><span class="line">    time.sleep(self.sleep_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> newDriver.title</span><br><span class="line"></span><br><span class="line">    img_dir_path = self.save_img_path + newDriver.title.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">True</span> == self.mkdir(img_dir_path):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'创建宝贝目录成功'</span></span><br><span class="line"></span><br><span class="line">    html = newDriver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    selector = etree.HTML(html)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 封面图</span></span><br><span class="line">    J_ULThumb = selector.xpath(<span class="string">"//div[@class='tb-gallery']/ul/li"</span>)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> J_ULThumb:</span><br><span class="line">        <span class="comment"># 替换图片 从50*50 至 400 * 400</span></span><br><span class="line">        <span class="keyword">if</span> len(li.xpath(<span class="string">"./div/a/img/@data-src"</span>)) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        small_pic = li.xpath(<span class="string">"./div/a/img/@data-src"</span>)[<span class="number">0</span>]</span><br><span class="line">        common_pic = <span class="string">'https:'</span> + small_pic.replace(<span class="string">'50x50'</span>, <span class="string">'400x400'</span>)</span><br><span class="line">        thumb_title = str(<span class="string">'封面图'</span>) + str(index)</span><br><span class="line">        <span class="keyword">print</span> thumb_title</span><br><span class="line">        <span class="comment"># self.saveImg(img_dir_path, common_pic, thumb_title.decode('utf-8'))</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬取里面所有图片</span></span><br><span class="line">    all_img = selector.xpath(<span class="string">"//div[@id='J_DivItemDesc']//descendant::img/@src"</span>)</span><br><span class="line">    <span class="keyword">print</span> all_img</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> all_img:</span><br><span class="line">        imglink = img</span><br><span class="line">        <span class="keyword">if</span> img.startswith(<span class="string">'http'</span>) <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">            imglink = img</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            imglink = <span class="string">'https:'</span> + img</span><br><span class="line"></span><br><span class="line">        self.saveImg(img_dir_path, imglink, str(index))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    newDriver.quit()</span><br></pre></td></tr></table></figure></p>
<p>注释都写在代码里了，大家看看就好，这里有很多地方的代码不够优雅，那是我当天急着用，所以后来也没有去优化了。</p>
<p>在这个核心解析代码的完成之后，宝贝图片就已经稳稳的存储到我们的硬盘上了，可以开箱即用了。完整的代码我也放在了<a href="https://github.com/originalix/Original/blob/master/python2.7/taobaoshop.py" target="_blank" rel="noopener">Github</a>上了，如果对您有帮助，请帮忙star一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/Python——爬虫实战-爬取淘宝店铺内所有宝贝图片/" data-id="cjptr3x46000xlyz9bdw94dsx" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python——爬虫入门XPath的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/Python——爬虫入门XPath的使用/" class="article-date">
  <time datetime="2018-02-27T12:30:35.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/Python——爬虫入门XPath的使用/">Python——爬虫入门XPath的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Xpath即为XML路径语言（XML Path Language）。它是一种用来确定XML文档中某部分位置的语言。</p>
<p>XPath基于XML的树状结构，提供在数据结构树种找寻节点的能力。起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型。但是XPath很快的被开发者采用来当做小型查询语言。</p>
<p>由于XPath确定XML文档中定位的能力，我们在用Python写爬虫时，常常使用XPath来确定HTML中的位置，辅助我们编写爬虫，抓取数据。</p>
<p>&lt;!--more--&gt;</p>
<h2>节点</h2>
<p>在Xpath中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或者称为根节点）。</p>
<p>下面举几个节点的例子来说明：</p>
<p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的XML文档中：</p>
<p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span>  (文档节点)</span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> (元素节点)</span><br><span class="line">lang="en" (属性节点)</span><br></pre></td></tr></table></figure></p>
<h2>表示法</h2>
<p>Xpath最常见的表达式就是路径表达式（XPath这一名称的另一来源）。路径表达式是从一个XML节点（当前的上下文节点）到另一个节点、或一组节点的书面步骤顺序。这些步骤以“/”字符分开，每一步有三个构成部分。</p>
<ul>
<li>轴描述（用最直接的方式接近目标节点）</li>
<li>节点测试（用于筛选节点位置和名称）</li>
<li>节点描述（用于筛选节点的属性和子节点特征）</li>
</ul>
<p>一般情况下，我们使用简写后的语法，虽然完整的轴描述是一种更加贴近人类语言，利用自然语言的单词和语法来书写的描述方式，但是相比之下也更加啰嗦。</p>
<h2>实例</h2>
<p>我们将在下面的例子中使用这个XML文档。</p>
<p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"eng"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"eng"</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们来使用路径表达式在上面的XML文档中选取节点。</p>
<p>节点是通过沿着路径或者step来选取的。</p>
<p>下面表格列举的是最有用的路径表达式:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodename</td>
<td>选取此结点的所有节点</td>
</tr>
<tr>
<td>/</td>
<td>从根节点选取</td>
</tr>
<tr>
<td>//</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>
<tr>
<td>.</td>
<td>选取当前节点</td>
</tr>
<tr>
<td>..</td>
<td>选取当前节点的父节点</td>
</tr>
<tr>
<td>@</td>
<td>选取属性</td>
</tr>
</tbody>
</table>
<p>而下面的这个表格，我已经列出了一些路径表达式以及表达式的结果</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>bookstore</td>
<td>选取 bookstore 元素的所有子节点</td>
</tr>
<tr>
<td>/bookstore</td>
<td>选取根元素bookstore ps: 假如路径起始于正斜杠(/),则此路径始终代表到某元素的绝对路径</td>
</tr>
<tr>
<td>bookstore/book</td>
<td>选取属于bookstore的子元素的所有book元素</td>
</tr>
<tr>
<td>//book</td>
<td>选取所有book子元素，而不管它们在文档中的位置</td>
</tr>
<tr>
<td>bookstore//book</td>
<td>选择属于bookstore元素的后代的所有book元素，而不管它们位于bookstore之下的什么位置</td>
</tr>
<tr>
<td>//@lang</td>
<td>选取名为lang的所有属性</td>
</tr>
</tbody>
</table>
<h2>通配符选用节点</h2>
<p>XPath通配符可用来选取未知的XML元素</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任何元素节点</td>
</tr>
<tr>
<td>@*</td>
<td>匹配任何属性节点</td>
</tr>
<tr>
<td>node()</td>
<td>匹配任何类型的节点</td>
</tr>
</tbody>
</table>
<h2>Python中的XPath库</h2>
<p>通过 Python 的 LXML 库利用 XPath 进行 HTML 的解析。</p>
<p>lxml用法源自 lxml python 官方文档，更多内容请直接参阅官方文档，本文对其进行翻译与整理。</p>
<p>安装lxml</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure></p>
<p>现在我们简单的介绍完了XPath的语法，对于爬虫的准备知识已经铺垫完毕了，从下一篇博客开始，就要进入爬虫的实战教程了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/Python——爬虫入门XPath的使用/" data-id="cjptr3x45000vlyz9rncgkwid" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XPath/">XPath</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python——爬虫入门Selenium的简单使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/22/Python——爬虫入门Selenium的简单使用/" class="article-date">
  <time datetime="2018-02-21T23:34:29.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/22/Python——爬虫入门Selenium的简单使用/">Python——爬虫入门Selenium的简单使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>之前的两篇我们讲解了Python内的urllib库的使用，不知道大家有没有在爬取一些动态网站的时候，发现自己用urllib爬取到的内容是不对的，无法抓取到自己想要的内容，比如淘宝的店铺宝贝等，它会用js动态的加载内容，此时selenium这个家伙就能派上用场了。</p>
<p>selenium是什么？简单的概括，它的初衷就是自动化测试工具。它支持各种浏览器，包括chrome，safari，firefox等主流界面式浏览器，如果你在这些浏览器里安装一个selenium的插件，那么便可以方便的实现Web界面的测试。换句话说selenium支持这些浏览器驱动，selenium支持多种语言开发，比如Python、Java、C、Ruby等等。</p>
<p>&lt;!--more--&gt;</p>
<p>而在爬虫这个领域，我们则用这个自动化测试工具来模拟我们是真实的浏览器用户，用他来爬取页面非常方便，只要按照访问步骤模拟人在操作就可以了，完全不用操心cookie，session的处理，它甚至可以帮助你输入账户、密码，然后点击登录按钮，这些功能在应对一些常见的反爬虫机制时非常有用。</p>
<p>在我们开始示例代码之前，首先你要在Python中安装selenium库</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure></p>
<p>安装好了之后，我们便开始探索抓取方法了。</p>
<p>那么我们就把一个淘宝店铺为示例，试着来爬取他里面的宝贝列表。你可以先用urllib来验证一下这个url，是不是爬取不到浏览器显示的dom内容。</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Lix'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selenium_example</span><span class="params">()</span>:</span></span><br><span class="line">    site_url = <span class="string">'https://elcjstyle.taobao.com/search.htm?spm=a1z10.1-c-s.0.0.68616fccLXsimv&amp;search=y'</span></span><br><span class="line"></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    driver.get(site_url)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    content = driver.page_source.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">print</span> driver.title</span><br><span class="line">    <span class="keyword">print</span> content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    selenium_example()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>执行完这段示例代码之后，不出意外会打印出店铺名字和整张页面的html代码。可以把这个代码和Chrome内调试环境下看到的html代码比较一下，是否完全一样了。</p>
<p>而在selenium中，更是有很多不同的策略可以定位到一个元素，实现它本身的自动化测试目的，而我们也可以配合<code>Beautiful Soup</code>或者<code>Xpath</code>来提取我们想要的内容。</p>
<p>一次查找多个元素 (这些方法会返回一个list列表):</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find_elements_by_name</span><br><span class="line">find_elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure></p>
<p>假如我们要通过name来查找一个元素:</p>
<p>页面元素如下所示：</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"loginForm"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"continue"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"continue"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Clear"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>name属性为 username &amp; password 的元素可以像下面这样查找:</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = driver.find_element_by_name(<span class="string">'username'</span>)</span><br><span class="line">password = driver.find_element_by_name(<span class="string">'password'</span>)</span><br></pre></td></tr></table></figure></p>
<p>通过这样的两句代码，我们就能提取到username和password的元素，所以selenium真的是一个很有用的工具呢。</p>
<p>关于selenium更多的用法，希望大家能认真阅读他的文档。这一定是一个会让你非常受用的工具的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/22/Python——爬虫入门Selenium的简单使用/" data-id="cjptr3x43000slyz9vs3q5ni9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Selenium/">Selenium</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python——爬虫入门-Urllib库的进阶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/07/Python——爬虫入门-Urllib库的进阶/" class="article-date">
  <time datetime="2018-02-07T13:06:30.000Z" itemprop="datePublished">2018-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/07/Python——爬虫入门-Urllib库的进阶/">Python——爬虫入门 Urllib库的进阶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>上一篇文章我们简单讲解了Urllib库的基础用法，包括如何获取请求之后的页面响应，如何使用POST请求上传数据，今天我们就来讲讲Urllib库的几个进阶用法。</p>
<p>&lt;!--more--&gt;</p>
<h2>Headers:</h2>
<p>我们先讨论关于请求头的使用，如何构造HTTP-Headers。我们先进入Chrome浏览器打开调试模式，</p>
<p><img src="http://originalix.github.io/images/python-urllib.png" alt=""></p>
<p>在network一栏中找到Headers，在里面我们能看到Request Headers，这就是我们发送当前页面请求所用的请求头。其中User-Agent就是请求的身份，如果没有写入这个信息，那么有可能初级的反爬虫策略就会识别我们不是基于浏览器的请求，这次的请求就不会被响应了。</p>
<p>所以我们今天的第一段代码就是展示如何构造这个User-Agent的请求头：</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib  </span><br><span class="line"><span class="keyword">import</span> urllib2  </span><br><span class="line"> </span><br><span class="line">url = <span class="string">'http://originalix.github.io/#blog'</span></span><br><span class="line">user_agent = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36'</span>  </span><br><span class="line">headers = &#123; <span class="string">'User-Agent'</span> : user_agent &#125;  </span><br><span class="line">request = urllib2.Request(url, <span class="keyword">None</span>, headers)  </span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">html = response.read()</span><br><span class="line"><span class="keyword">print</span> html</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中的请求，我们就构造了一个携带携带User-Agent字段的请求，以后如果没有响应的页面，可要记得检查检查是不是忘记了在请求头里做文章了。</p>
<h2>URLError：</h2>
<p>通常，URLError被抛出是因为网络请求出现了错误，比如服务器访问错误，或者访问的站点不存在，在这种情况下都会抛出一个URLError,这个错误是一个包含着reason和code的元组，分别对应着错误消息和错误代码。我们可以用try/except语句来捕获异常，例如:</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># URLError</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">req = urllib2.Request = (<span class="string">'http://www.lixxxxxxxx.com'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    urllib2.urlopen(req)</span><br><span class="line"><span class="keyword">except</span> urllib2.URLError <span class="keyword">as</span> e :</span><br><span class="line">    <span class="keyword">print</span> e.reason</span><br></pre></td></tr></table></figure></p>
<p>在接触URLError之前，大家一定更早的接触过HTTPError，每个来自服务器的HTTP应答都会携带着一个包含数值的状态码，例如我们耳熟能详的200、404(页面丢失)、403(请求被禁止)等等。HTTPError的异常实例拥有一个整型的code属性。</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时处理HTTPError和URLError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.lixxxxxxxx.com'</span></span><br><span class="line">req = urllib2.Request(url)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	response = urllib2.urlopen(req)</span><br><span class="line"><span class="keyword">except</span> urllib2.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">	<span class="keyword">print</span> e.code</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'we can not fulfill the request \n'</span></span><br><span class="line"><span class="keyword">except</span> urllib2.URLError <span class="keyword">as</span> e:</span><br><span class="line">	<span class="keyword">print</span> e.reason</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'we can not reach a server'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'No problem'</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是一个同时处理HTTPError和URLError的例子，记得一定要把HTTPError放在前面处理，因为HTTPError是URLError的子集。</p>
<p>最后诸如代理什么的也就不讲解了，因为我觉得使用到这些的时候，大家可能就不会使用urllib2这个库了，有更好的轮子在等着你们。放上urllib2库的官方文档，有不懂的可以速查哟。 <a href="https://docs.python.org/2/library/urllib2.html" target="_blank" rel="noopener">urllib2官方文档任意门</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/07/Python——爬虫入门-Urllib库的进阶/" data-id="cjptr3x42000rlyz9nzpd32bz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python——爬虫入门-Urllib库的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/28/Python——爬虫入门-Urllib库的使用/" class="article-date">
  <time datetime="2018-01-28T12:44:16.000Z" itemprop="datePublished">2018-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/28/Python——爬虫入门-Urllib库的使用/">Python——爬虫入门 Urllib库的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近在系统的学习Python爬虫，觉得还是比较有意思的，能够干很多的事情，所以也写点文章记录一下学习过程，帮助日后回顾。</p>
<p>网上关于Python的爬虫文章、教程特别多，尤其是喜欢刷知乎的用户，我总是感觉其他语言都是讨论xx框架如何，xx如何进阶，而Pythoner一开专栏，保准是xx爬虫入门教学，于是想零基础的入门Python爬虫也是非常容易的一件事，但是事实上会和达到工作要求，之间要学习补充的东西还是非常非常多的。</p>
<p>我在初学爬虫这段时间内，对于爬虫的流程，简单的概括为下面四步骤：网页 -&gt; 网页源代码 -&gt; 正则表达式 -&gt; 需要的内容。而针对这四个方面展开则有许多许多可以提升并完善的细节，例如一个网页，我们就可以从在浏览器的地址栏敲入url之后说起。当然，这里我是不准备展开来说的。</p>
<p>而目前的文章我打算从爬虫的入门开始写，看看是否可以写出一个系列来记录，完成品是争取带大家爬出一个动态js加载的妹子页面。</p>
<p>爬虫的功能往简单的说就是把网页源代码想办法爬下来，然后分析我们需要的内容，总结起来就是两个部分：</p>
<ul>
<li>
<p>爬！</p>
</li>
<li>
<p>提取。</p>
</li>
</ul>
<p>&lt;!-- more --&gt;</p>
<p>所以整个过程里需要掌握的技能就是如何爬，以及爬到之后如何处理。</p>
<p>所以今天的入门文章里，我们就不去介绍第三方库的工具如何使用，我们来看看Python自带的标准库——Urllib库。</p>
<h1>Urllib</h1>
<p>这个自带的标准库提供了诸如网页请求、响应获取、代理和cookie设置、异常处理、URL解析等等功能。</p>
<p>一个爬虫所需要的功能，基本上在urllib中都能找到，学习这个标准库，可以更加深入的理解之后要用到的第三方库，包括提高对于爬虫框架的理解。</p>
<p>那我们就从第一个网页的爬取入手，现在我们首先打开我们的编辑器，创建一个Python文件，并且在里面写入如下代码：</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">response = urllib2.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p>
<p>是的，就是这么简短的代码，现在我们来运行一下这个py文件。在命令行中能看到爬取到的百度网站的一堆html代码。是的，你没有看错，想抓到百度的html页面，只要这么简单的两行代码，看到命令行里反馈回来的这么多代码，是不是心里一阵痛快！</p>
<p>好，我们我们开始从头分析我们的三行代码，第一行，我们import了我们的urllib2的库。</p>
<p>第二行代码，我们使用urlopen的api，传入了url参数，执行urlopen方法后，就返回了一个response对象，我们打印的返回信息便保存在里面。</p>
<p>第三行代码，我们打印了response响应对象里的内容，并且转换成了utf-8编码，你可以试试如果去掉了utf-8的编码，是不是会乱码呢？</p>
<p>而我们请求之前，也可以根据urllib2提供的request的类，在发送请求前构造一个request的对象，然后通过urllib的urlopen函数来发送请求。例如上面请求百度的代码也可以写成这样：</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">url = <span class="string">r'http://www.baidu.com'</span></span><br><span class="line">req = urllib2.Request(url)</span><br><span class="line">html = urllib2.urlopen(req).read()</span><br><span class="line"><span class="keyword">print</span> html</span><br></pre></td></tr></table></figure></p>
<p>我们先用<code>req = urllib2.Request(url)</code>实例化了一个request对象，之后再请求打开这个网页。</p>
<p>而我们常用的HTTP协议里还有GET、POST等方法的请求，我们该如何实现呢，以Post请求为例，我们怎么发送一个携带着数据的请求呢。</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'http://www.baidu.com/'</span></span><br><span class="line">params = &#123;<span class="string">'name'</span> : <span class="string">'Lix'</span>, <span class="string">'location'</span> : <span class="string">'China'</span>&#125;</span><br><span class="line">data = urllib.urlencode(params)</span><br><span class="line">req = urllib2.Request(url,data)</span><br><span class="line">response = urllib2.urlopen(req)</span><br><span class="line">the_page = response.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> the_page</span><br></pre></td></tr></table></figure></p>
<p>这样就可以完成一个post请求，至于GET方法，我们举例的第一段代码就是get类型的哦。</p>
<p>根据现在讲解的一些基本知识，我们就可以抓取到一些简单的页面的数据了，之后更深的内容我们在之后的文章里接着分析哦。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/28/Python——爬虫入门-Urllib库的使用/" data-id="cjptr3x44000ulyz9s5xi5mg8" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python——搞定烦人的字符串编码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/17/Python——搞定烦人的字符串编码/" class="article-date">
  <time datetime="2018-01-17T12:31:36.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/Python——搞定烦人的字符串编码/">Python——搞定烦人的字符串编码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>注意：以下讨论为Python2.x版本</p>
<p>在学习Python之前，就听说过Python的版本圣战，最可怕的是有的写Py3的程序员觉得Py2是另一种语言....所以在刚开始学习的时候，我索性把Python3和Python2的文档都看了一遍。</p>
<p>在之后写爬虫的过程中，我还是选择使用了Python2.x来写，原因嘛，emmmmm，可能就是因为一些好用的库或者框架的示例代码也是用旧一点的版本，所以为了效率，先用旧版本上手得了。在学习Python2之前，我还特意去比较了2和3的区别，其中着重被提及的就是字符串编码的问题，于是乎我在看旧版本文档的时候很仔细的去阅读了Python2的字符串部分。</p>
<p>&lt;!--more--&gt;</p>
<p>然而结局证明，仔细阅读之后还是too young too simple，在读取文件，处理参数，以及处理http链接的过程中，经常一运行，发生两个对于Python的开发者熟悉的不能再熟悉的报错了。</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">'ascii'</span> codec can<span class="string">'t decode byte 0xe6 in position 0: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure></p>
<p>怎么样，是不是非常眼熟上面的两句话，好吧，我承认我这个小白一开始发现有这种编码问题的时候，就是调用encode/decode各种调试，期望这两个函数中有一个能够生效，救救我苟延残喘的程序，而在最初的时候，好像这样做还挺有效果的。</p>
<p>但是好运不长，在编写爬虫的过程中，随着处理字符串的量越来越大，http请求参数越来越多，往往一个参数是由好几个参数拼接而成的，而有时候你并不知道是哪个地方出了问题，盲目的替换和使用encode/decode方法效率非常低下。而造成这个问题的原因，就是没有明确的思考为什么会出现编码错误，授人以鱼不如授人以渔，所以我们今天要来从根上探究一下这个问题。</p>
<h1>编码的简介</h1>
<p>首先，作为一名程序员，我想ASCII、Unicode、UTF-8三种字符编码大家肯定是听到过的，而这三种编码到底有什么区别呢？</p>
<p>ASCII是美国信息交换标准代码，是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。</p>
<p>Unicode是电脑科学领域里的一项业界标准，它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用以更为简单的方式来呈现和处理文字。</p>
<p>UTF-8是一种正对Unicode的可变长度字元编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字元，且其编码中的第一个位元组仍与ASCII相容，这使得原来处理的ASCII的软体无须或只须少部分修改，即可以继续使用，因此，它逐渐成为了电子邮件、网页以及其他存储或传送文字的应用中，优先采用的编码。</p>
<h1>判断编码类型</h1>
<p>在简单的介绍了三种编码之后，我们首先在处理字符编码问题的时候，搞清楚我们到底处理的是什么类型的编码。因为在Python中str和unicode都是<code>basestring</code>的子类，所以我们可以用下面的方法判断我们处理的类型是否为字符串：</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool = isinstance(s, basestring)</span><br></pre></td></tr></table></figure></p>
<p>而str和unicode的转换也非常简单，总结一下就是如下的样子:</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">str  -&gt; decode('coding') -&gt; unicode</span><br><span class="line">unicode -&gt; encode('coding') -&gt; str</span><br></pre></td></tr></table></figure></p>
<p>可以看出，str这个字符串，是由unicode经过编码后的字节形成的。而在字符串前面加u，就是unicode类型了。
例如：</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'富强民主文明和谐'</span></span><br><span class="line">s = <span class="string">u'富强民主文明和谐'</span>.encode(<span class="string">'uft-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">'富强民主文明和谐'</span>)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>而分析str字符串长度的时候，可以看到返回的字节数:</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">u'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>每个中文在UTF-8编码中，通常占用三个字节，这个结果是正确的。值得注意的是，unicode的字符编码和utf-8的存储编码表示是不同的。</p>
<p>上面的代码是分析了utf-8字符串的编码，而接下来，我们要分析真正的unicode字符编码，</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">u'富强民主文明和谐'</span></span><br><span class="line">s = <span class="string">'富强民主文明和谐'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">s = unicode(<span class="string">'富强民主文明和谐'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u'富强民主文明和谐'</span>)</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>从长度来观察unicode字符串:</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span></span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">u'中文'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>上面的结果是unicode的字符分析结果。</p>
<p>所以我们在处理字符串的时候，要搞清楚我们处理的str还是unicode，使用正确的处理方法来处理。</p>
<p>教给大家一个简便的记忆方法，不要对str使用encode，而对于unicode也不要使用decode。其实是有特殊情况的，但是为了少出错，建议新手先这么处理呢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/17/Python——搞定烦人的字符串编码/" data-id="cjptr3x41000qlyz99pbscmfz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Rem布局的原理探究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/09/Rem布局的原理探究/" class="article-date">
  <time datetime="2018-01-09T13:16:22.000Z" itemprop="datePublished">2018-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/09/Rem布局的原理探究/">Rem布局的原理探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在用前端给移动端页面写布局时，我接触到了Rem布局，但是老实说我也看了几篇手淘适配的文章，并且主要的目的是拿到代码写出demo，所以对于Rem我还是停留在只会使用的阶段，但是理解的并不透彻，所以要抽出时间，把rem布局的原理搞清楚。</p>
<p>&lt;!--more--&gt;</p>
<h1>什么是em</h1>
<p>我相信所有接触学习过css布局的同学，一定在rem之前先听到过em的大名，但是大多数也许跟我一样，只是听过或者最多跟着W3C上的教程敲过一下demo，之后的工作学习中并没有使用em这个单位，那么在聊rem之前，我们先聊聊em，毕竟混淆这两个单位的同学还是存在的。</p>
<p>用户的浏览器渲染的默认字体大小是&quot;16px&quot;，换句话说，Web页面中“body”的文字大小在浏览器下默认渲染是&quot;16px&quot;。当然，如果用户愿意也可以改变这个字体大小。而&quot;em&quot;是一个相对的大小，它的大小是相对于元素父元素的font-size。比如在body下直接写一个p标签，并且设置这个p标签的字体大小是&quot;2em&quot;, 那么其文字大小计算出来就是相当于<code>2 * 16px = 32px</code>。一个例子就能明了，em是相对于当前元素的父元素的font-size。而之前的弹性设计，有一个关键地方就是Web的所有元素都使用“em”单位。</p>
<p>体验后，是不是觉得弹性布局的页面很灵活呀，而且也像“px”一样的精确。因此，只要我们掌握了“font-size”、“px”和“em”之间的基本关系，我们就可以快速使用CSS创建精确的布局。</p>
<h1>什么是Rem</h1>
<p>看完了刚才em的介绍，是不是对于em的概念逐渐清晰，并且希望用em去构建自己的弹性布局呢。且慢，心急吃不了热豆腐，不妨听我把rem也慢慢的介绍完，毕竟主角光环的都是最后才出场的。rem是css3引入的一个单位，那我们为什么要在有em这个可以充当弹性布局的单位时还要引入rem呢？</p>
<p>em可以让我们的页面更灵活，比起到处写死的px值，em显得更有张力，根据比例的变化来调节屏幕。有的人提出用em来做弹性布局的页面，但是还是兔内污！如果你想一边看着标注图，一边算着em值，那你可以试试哦。不过聪明的程序员是不会去做这么无脑的事情的，所以有人写过px和em转换的计算器。但是你有没有想过，如果有一天，你的父节点的字体大小发生了变化，那么对于全局可能会产生相当大的影响，手算的同学是不是要全部重新计算，唉，害怕的我直接去写px了。😨！</p>
<p>所以针对这种繁琐运算的情况，rem应运而生，我们是这样定义rem的：</p>
<blockquote>
<p>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小</p>
</blockquote>
<p>rem的取值有两种情况，就是设置根元素和非根元素的时候，下面看个例子：</p>
<p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>html是我们html页面的根元素，之前介绍em的时候，我们就知道浏览器默认渲染的字体大小是16px，所以html的字体大小是2rem，那么rem作用于根元素的字体大小相当于其初始字体大小的定论的话，html的字体大小就是32px。</p>
<p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而上面p标签的这个例子中，我们之前已经知道html的字体大小是32px，那么p标签的字体大小就是<code>2 * 32px = 64px</code>。</p>
<p>所以如果我们能合理的设置根元素的字体大小，那么rem的计算就会变得非常容易，比如手淘提出的将屏幕等宽划分成100份，那么标注图上的10px，即为0.1rem。所有的标注值除以100即可，根本不需要有计算的过程。</p>
<p>其实rem布局的本质也就是等比缩放，一般是基于宽度，假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示。 <code>x = 屏幕宽度 / 100</code>, 如果将x作为单位，x前面的数值就代表屏幕宽度的百分比。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123; width: 50x &#125; //屏幕宽度的50%</span><br></pre></td></tr></table></figure></p>
<p>而理解到这里，其实我们也就知道我们让页面最上面跑的js代码到底是什么意思了，我们就是需要让html元素字体的大小，恒等于屏幕宽度的1/100。那1rem和1x就等价了。</p>
<p>rem我们就分析到这里，到这里，可能有人会觉得在这个比较之下，em似乎完全没有用武之地，但是一个技术的存在肯定是得到很多使用者的肯定的，也是设计者几经考量才能决定放出使用的，所以技术没有高低，只是他们适用的场景，rem可能更适合写布局，而em可能就更适合来表达字体大小。所以我们要探究原理，选择合适的技术，提高自己的工作效率和作品质量。</p>
<p>今天的探究就到这里，rem的代码我就不贴了，手淘的代码一搜一大把呢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/09/Rem布局的原理探究/" data-id="cjptr3x490014lyz97qbi8rpa" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/layout/">layout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-从Yii2的源码来分析框架的QueryParamAuth的鉴权过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/27/从Yii2的源码来分析框架的QueryParamAuth的鉴权过程/" class="article-date">
  <time datetime="2017-12-27T11:26:29.000Z" itemprop="datePublished">2017-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/27/从Yii2的源码来分析框架的QueryParamAuth的鉴权过程/">从Yii2的源码来分析框架的QueryParamAuth的鉴权过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Yii是基于PHP语言打造的一款框架，了解PHP的同学对这款框架肯定也不会陌生。而我在最近使用yii2写App接口的时，查看官方了的RESTful Web服务文档，文档中对于授权验证的过程有这样一个介绍:</p>
<p>&lt;!--more--&gt;</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">如果你系那个支持以上3个认证方式，可以使用CompositeAuth，如下所示：</span><br><span class="line"></span><br><span class="line">use yii\filters\auth\CompositeAuth;</span><br><span class="line">use yii\filters\auth\HttpBasicAuth;</span><br><span class="line">use yii\filters\auth\HttpBearerAuth;</span><br><span class="line">use yii\filters\auth\QueryParamAuth;</span><br><span class="line"></span><br><span class="line">public function behaviors()</span><br><span class="line">&#123;</span><br><span class="line">    $behaviors = parent::behaviors();</span><br><span class="line">    $behaviors[&apos;authenticator&apos;] = [</span><br><span class="line">        &apos;class&apos; =&gt; CompositeAuth::className(),</span><br><span class="line">        &apos;authMethods&apos; =&gt; [</span><br><span class="line">            HttpBasicAuth::className(),</span><br><span class="line">            HttpBearerAuth::className(),</span><br><span class="line">            QueryParamAuth::className(),</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">    return $behaviors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">authMethods 中每个单元应为一个认证方法名或配置数组。</span><br><span class="line"></span><br><span class="line">findIdentityByAccessToken()方法的实现是系统定义的， 例如，一个简单的场景，当每个用户只有一个access token, 可存储access token 到user表的access_token列中， 方法可在User类中简单实现，如下所示：</span><br><span class="line"></span><br><span class="line">use yii\db\ActiveRecord;</span><br><span class="line">use yii\web\IdentityInterface;</span><br><span class="line"></span><br><span class="line">class User extends ActiveRecord implements IdentityInterface</span><br><span class="line">&#123;</span><br><span class="line">    public static function findIdentityByAccessToken($token, $type = null)</span><br><span class="line">    &#123;</span><br><span class="line">        return static::findOne([&apos;access_token&apos; =&gt; $token]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是官方文档的原文，而我当时结合我的API接口，感觉最适合我使用的是第三种<code>QueryParamAuth</code>类型的验证，就是在请求的url中拼接上<code>AccessToken</code>。这也是常见的一种鉴权方式，而实现这些验证，框架又需要我们完成<code>findIdentityByAccessToken()</code>函数，所以为了不稀里糊涂的跟着文档弄完了，我决定从源码里探究一下实现鉴权的过程中究竟发生了什么。</p>
<p>至于如何实现这个过程，以及完成认证，我之前在网上已经看到有大量博客写这个了，所以在此我也不再赘述。</p>
<p>首先我们进入<code>QueryParamAuth</code>类里,里面有一个<code>authenticate($user, $request, $response)</code>函数,这个函数的代码是这样的:</p>
<p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">authenticate</span><span class="params">($user, $request, $response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取get参数里的access-token, $this-&gt;tokenParam的具体名称，可以在类中指定</span></span><br><span class="line">    $accessToken = $request-&gt;get(<span class="keyword">$this</span>-&gt;tokenParam);</span><br><span class="line">    <span class="keyword">if</span> (is_string($accessToken)) &#123;</span><br><span class="line">        <span class="comment">//存在登录令牌的情况下，执行yii\web\user类里的loginByAccessToken方法</span></span><br><span class="line">        $identity = $user-&gt;loginByAccessToken($accessToken, get_class(<span class="keyword">$this</span>));</span><br><span class="line">        <span class="keyword">if</span> ($identity !== <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> $identity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有accessToken直接报错</span></span><br><span class="line">    <span class="keyword">if</span> ($accessToken !== <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handleFailure($response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我把这段源码的注释直接附在代码中，在这里我们能大致知道这个函数做了哪些事情，但是其中<code>$user, $request, $response</code>这三个参数又是如何获取传递进来的呢。我们再进入<code>QueryParamAuth</code>的父类<code>AuthMethod</code>里一探究竟。</p>
<p>打开这个父类，我们能看到<code>$user, $request, $response</code>这三个参数是父类中定义的三个公开属性。而在父类中的<code>beforeAction()</code>中，获取到这三个方法，</p>
<p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeAction</span><span class="params">($action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $response = <span class="keyword">$this</span>-&gt;response ?: Yii::$app-&gt;getResponse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是重点，父类获取三个参数，传入我们之前的authenticate()函数中。</span></span><br><span class="line">        $identity = <span class="keyword">$this</span>-&gt;authenticate(</span><br><span class="line">            <span class="keyword">$this</span>-&gt;user ?: Yii::$app-&gt;getUser(),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;request ?: Yii::$app-&gt;getRequest(),</span><br><span class="line">            $response</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnauthorizedHttpException $e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isOptional($action)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> $e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($identity !== <span class="keyword">null</span> || <span class="keyword">$this</span>-&gt;isOptional($action)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;challenge($response);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;handleFailure($response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，在<code>beforeAction()</code>函数中获取了参数，并且调用了<code>authenticate</code>函数,开始执行认证过程。现在我们知道了参数的由来，那么我们接着回到<code>QueryParamAuth</code>类里的<code>authenticate()</code>函数中，探究鉴权过程。</p>
<p>在<code>authenticate()</code>函数中我们看到有这样一行代码:</p>
<p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$identity = $user-&gt;loginByAccessToken($accessToken, get_class(<span class="keyword">$this</span>));</span><br></pre></td></tr></table></figure></p>
<p>在这里我提醒大家，这个<code>$user</code>指的是<code>yii\web\user</code>这个类，而我之前看到很多网上教程让大家去实现<code>loginByAccessToken()</code>这个函数，很多人在实现了这个函数之后问，为什么不调用这个函数，其实这个函数是没有必要实现的，如果你一定要实现这个函数，那么你就得把这里使用的<code>$user</code>替换成你自己的User类，因为在这个时候，还不会调用你在config里配置的user类，很多同学有了问题，还是要先看看源码，而不是发现这篇博客不行，就换另一个博客试试。。。</p>
<p>我们来一起看看<code>loginByAccessToken()</code>函数的代码:</p>
<p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">loginByAccessToken</span><span class="params">($token, $type = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> $class IdentityInterface */</span></span><br><span class="line">    <span class="comment">// 这里的identityClass才是我们在config中配置的那个User类</span></span><br><span class="line">    $class = <span class="keyword">$this</span>-&gt;identityClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里开始执行我们在User类中实现的findIdentityByAccessToken()函数</span></span><br><span class="line">    $identity = $class::findIdentityByAccessToken($token, $type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的条件，在鉴权之前，我们得是登录状态</span></span><br><span class="line">    <span class="keyword">if</span> ($identity &amp;&amp; <span class="keyword">$this</span>-&gt;login($identity)) &#123;</span><br><span class="line">        <span class="keyword">return</span> $identity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则 就算有这个用户，但是不是登录状态 一样不能通过验证</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我已经把整个函数的分析写在注释里了，在这个函数里会调用我们在config里配置的User类，并且去执行文档中让我们配置的<code>findIdentityByAccessToken()</code>函数，所以我们写的函数在此时才会派上用场，同时我们还得是登录状态才能通过鉴权，登录的话这里先不展开讲了，可以先用yii框架默认页面的登录就能通过。</p>
<p>至此，我们的登录鉴权就已经通过了，如果不通过的小伙伴，可以再消化一下上面的源码分析，相信你一定能查到问题究竟出现在哪一步的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/27/从Yii2的源码来分析框架的QueryParamAuth的鉴权过程/" data-id="cjptr3x5h003glyz9jwl7x8e2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP/">PHP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Yii2/">Yii2</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Vim——使用NerdTree来畅快的打开文件吧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/19/Vim——使用NerdTree来畅快的打开文件吧/" class="article-date">
  <time datetime="2017-12-18T23:11:50.000Z" itemprop="datePublished">2017-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/19/Vim——使用NerdTree来畅快的打开文件吧/">Vim——使用NerdTree来畅快的打开文件吧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在上一章我介绍完用<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle</a>来管理Vim中所有的插件后，今天我又要强推一个Vim的文件管理插件<a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">Nerdtree</a>,相信所有使用Vim的同学都知道文件管理插件NerdTree,这个几乎是所有拥护Vim的开发人员都会使用的插件，今天就总结一下如何合理的使用NerdTree。</p>
<p>&lt;!--more--&gt;</p>
<p>首先我们来看一下NerdTree的官方效果图:</p>
<p><img src="https://github.com/scrooloose/nerdtree/raw/master/screenshot.png" alt="Nerdtree"></p>
<p>安装的话就使用咱们上一篇讲的Vundle插件进行安装，至于安装这样的小细节咱们在此就不再赘述。</p>
<p>当安装完成后，我们会有疑惑，如何召唤神龙打开NerdTree的文件列表呢？</p>
<p>答案非常简单，在你的<code>.vimrc</code>文件中添加<code>map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;</code>这样一行语句，那么你便能通过<code>ctrl+n</code>来开启关闭Nerdtree了。</p>
<p>而如果你对Nerdtree已经到达爱不释手的地步，希望只要打开了vim，就能看到Nerdtree的可爱界面，那么你可以增加自动启动的配置语句:</p>
<p><code>autocmd StdinReadPre * let s:std_in=1 autocmd VimEnter * if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(&quot;s:std_in&quot;) | exe 'NERDTree' argv()[0] | wincmd p | ene | endif</code></p>
<p>ok，把它写入到你的<code>.vimrc</code>文件中，nerdtree就会跟着你的vim自动启动了。</p>
<p>在增加了自动启动之后，我们也会碰到比较烦人的事情，就是有时我们编辑完文件退出后，窗口里就留下来nerdtree，还需要自己再退出一次，除非用:qall。该怎么解决这个问题呢？</p>
<p><code>autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif</code></p>
<p>那么将上面的配置语句添加好之后，nerdtree就会在孤零零一个人的时候，悄悄地退去。</p>
<p>Nerdtree的基本操作，附上给你哟：</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">?: 快速帮助文档</span><br><span class="line">o: 打开一个目录或者打开文件，创建的是buffer，也可以用来打开书签</span><br><span class="line">go: 打开一个文件，但是光标仍然留在NERDTree，创建的是buffer</span><br><span class="line">t: 打开一个文件，创建的是Tab，对书签同样生效</span><br><span class="line">T: 打开一个文件，但是光标仍然留在NERDTree，创建的是Tab，对书签同样生效</span><br><span class="line">i: 水平分割创建文件的窗口，创建的是buffer</span><br><span class="line">gi: 水平分割创建文件的窗口，但是光标仍然留在NERDTree</span><br><span class="line">s: 垂直分割创建文件的窗口，创建的是buffer</span><br><span class="line">gs: 和gi，go类似</span><br><span class="line">x: 收起当前打开的目录</span><br><span class="line">X: 收起所有打开的目录</span><br><span class="line">e: 以文件管理的方式打开选中的目录</span><br><span class="line">D: 删除书签</span><br><span class="line">P: 大写，跳转到当前根路径</span><br><span class="line">p: 小写，跳转到光标所在的上一级路径</span><br><span class="line">K: 跳转到第一个子路径</span><br><span class="line">J: 跳转到最后一个子路径</span><br><span class="line">&lt;C-j&gt;和&lt;C-k&gt;: 在同级目录和文件间移动，忽略子目录和子文件</span><br><span class="line">C: 将根路径设置为光标所在的目录</span><br><span class="line">u: 设置上级目录为根路径</span><br><span class="line">U: 设置上级目录为跟路径，但是维持原来目录打开的状态</span><br><span class="line">r: 刷新光标所在的目录</span><br><span class="line">R: 刷新当前根路径</span><br><span class="line">I: 显示或者不显示隐藏文件</span><br><span class="line">f: 打开和关闭文件过滤器</span><br><span class="line">q: 关闭NERDTree</span><br><span class="line">A: 全屏显示NERDTree，或者关闭全屏</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/19/Vim——使用NerdTree来畅快的打开文件吧/" data-id="cjptr3x4e001blyz9hjpvahlu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/">Vim</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-使用Vundle管理Vim插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/13/使用Vundle管理Vim插件/" class="article-date">
  <time datetime="2017-12-13T12:47:27.000Z" itemprop="datePublished">2017-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/13/使用Vundle管理Vim插件/">使用Vundle管理Vim插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>编辑器流派的划分在程序员群体中一直存在着，而我也在尝试了SublimeText、VSCode和Atom这些代表着现代时尚功能的编辑器之后试着使用Vim，其实说到学习使用Vim那已经是很早之前的事情了，但是每次看到各种配置，各种插件，总感觉把折腾Vim的配置是一件很要命的事情，如果把时间用在看书上或许会提高的更多，在这种阿Q的想法下，我始终没有认真的去研究过Vim的配置。</p>
<p>但是最近也算突然心血来潮，一直在敲前端和PHP的代码，因为有了一点嫌弃移动鼠标的麻烦，开始折腾起了Vim，也想配置出一个自己用得顺手的编辑器。虽然网上有很多完善强大的Vim配置文件，但是总感觉不是自己配置的，再怎么用也不舒服。所以一点一点折腾，一点一点爬坑，总算配置出了一个自己满足自己敲敲前端代码和日常编辑文本功能的编辑器。</p>
<p>&lt;!--more--&gt;</p>
<p>而折腾完才发现，Vim的代码补全，编译及错误跳转等插件功能其实还是足够使用的，尤其是我经常在家中和办公室切换电脑使用，各种系统之间跨平台支持做的非常的好，希望是一个可以终生使用的工具。</p>
<p>对于Vim中如此众多的插件，一个好的插件管理工具是必不可少的，所以今天在这里，我们来讲解一下Vundle这款插件管理器的使用。首先如果你不适用插件管理工具的话，那么你对插件的安装、配置和管理相对会麻烦很多，曾经没使用Vundle的时候，我经常遇到无法安装一些vim插件，但是使用Vundle后你只要在文件中添加一行你的插件名就ok了。</p>
<p>首先我们要去<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle的github库</a>下载安装Vundle。</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure></p>
<p>执行上面的命令，将Vundle库下载到本地的<code>~/.vim/bundle/</code>目录下。</p>
<p>之后编辑我们的<code>.vimrc</code>文件，将下面的文本拷贝到你的<code>.vimrc</code>文件中，并且你可以选择性的删除你暂时不想安装的插件。</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible              <span class="string">" be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                  "</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">" set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">"</span> alternatively, pass a path <span class="built_in">where</span> Vundle should install plugins</span><br><span class="line"><span class="string">"call vundle#begin('~/some/path/here')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> <span class="built_in">let</span> Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" The following are examples of different formats supported.</span></span><br><span class="line"><span class="string">"</span> Keep Plugin commands between vundle<span class="comment">#begin/end.</span></span><br><span class="line"><span class="string">" plugin on GitHub repo</span></span><br><span class="line"><span class="string">Plugin 'tpope/vim-fugitive'</span></span><br><span class="line"><span class="string">"</span> plugin from http://vim-scripts.org/vim/scripts.html</span><br><span class="line"><span class="string">" Plugin 'L9'</span></span><br><span class="line"><span class="string">"</span> Git plugin not hosted on GitHub</span><br><span class="line">Plugin <span class="string">'git://git.wincent.com/command-t.git'</span></span><br><span class="line"><span class="string">" git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="string">Plugin 'file:///home/gmarik/path/to/plugin'</span></span><br><span class="line"><span class="string">"</span> The sparkup vim script is <span class="keyword">in</span> a subdirectory of this repo called vim.</span><br><span class="line"><span class="string">" Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="string">Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;</span></span><br><span class="line"><span class="string">"</span> Install L9 and avoid a Naming conflict <span class="keyword">if</span> you<span class="string">'ve already installed a</span></span><br><span class="line"><span class="string">" different version somewhere else.</span></span><br><span class="line"><span class="string">" Plugin '</span>ascenator/L9<span class="string">', &#123;'</span>name<span class="string">': '</span>newL9<span class="string">'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">" All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            " required</span></span><br><span class="line"><span class="string">filetype plugin indent on    " required</span></span><br><span class="line"><span class="string">" To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="string">"filetype plugin on</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" Brief help</span></span><br><span class="line"><span class="string">" :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="string">" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">" :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="string">" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">" Put your non-Plugin stuff after this line</span></span><br></pre></td></tr></table></figure></p>
<p>类似于<code>Plugin 'tpope/vim-fugitive'</code>这样的一行语句，就是安装一个新的插件，例如此行为安装<code>vim-fugitive</code>插件，例如这是一个Vim的Git相关插件，利用他可以很方便的查看对于文件的改动，还是很推荐安装使用的。</p>
<p>之后在我们的终端键入<code>vim</code>跳进vim编辑器的乌干达主界面，并且输入<code>:PluginInstall</code>，则会开始自动的执行插件安装过程，我们说的毫不费劲便是在此体现，一行语句对应一个插件。</p>
<p>在执行完毕后输入<code>qall</code>退出我们的插件安装界面，至此插件便安装完毕了。</p>
<p>至于怎么移除插件呢，同样是在<code>.vimrc</code>文件中删除对应的语句，并且在vim编辑器的界面，输入<code>PluginClean</code>就完成插件的清理了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/13/使用Vundle管理Vim插件/" data-id="cjptr3x5n003slyz9bv24fcb7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/">Vim</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-反转单向链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/24/反转单向链表/" class="article-date">
  <time datetime="2017-11-24T11:06:51.000Z" itemprop="datePublished">2017-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/24/反转单向链表/">反转单向链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>单向链表的反转是一个非常常见的链表类面试题，我在刷leetcode的过程中，发现了有许多链表题目的解法，都是以反转链表为基础进行的。所以我觉得有必要记录一下。</p>
<p>首先先用一张图来理解单链表的反转。</p>
<p><img src="https://originalix.github.io/assets/img/1.png" alt=""></p>
<p><img src="https://originalix.github.io/assets/img/2.png" alt=""></p>
<p>单链表的反转，就如上图一样，而单链表的反转也有几种方式，今天我主要是想记录我用得最频繁的迭代的方式。</p>
<p>&lt;!-- more --&gt;</p>
<p>先来看一下链表节点的定义:</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是最基础的一个链表节点，而反转链表的代码，其实非常的短，关键点就在于理解这几行代码究竟让链表产生了什么变化。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到四行代码：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">next = head.next; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">head.next = pre;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">pre = head;       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">head = next;      <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>第一行代码：<code>next = head.next;</code>
将head.next赋值给next变量，也就是说next指向了节点2，先将节点2保存起来。</p>
<p>第二行代码： <code>head.next = pre;</code>
将pre变量赋值给了head.next，即节点1指向了null。</p>
<p>第三行代码: <code>pre = head;</code>
将head赋值给了pre，即pre指向节点1，将节点1设为“上一个节点”。</p>
<p>第四行代码：<code>head = next;</code>
将next赋值给head，即head指向了节点2。将节点2设置为“头结点”。</p>
<p>一次循环的具体过程就是这样。</p>
<p>所以总结一下单链表的反转：</p>
<ul>
<li>保存当前头结点的下个节点。</li>
<li>将当前头结点的下一个节点指向“上一个节点”，这一步是实现了反转。</li>
<li>将当前头结点设置为“上一个节点”。</li>
<li>将保存的下一个节点设置为头结点。</li>
</ul>
<p>这样说起来确实有点拗口，但是我推荐大家在做链表类题目和理解链表的具体行为时，用一张纸和笔来辅助自己写写画画，相信很快你就会弄懂链表的具体思路的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/24/反转单向链表/" data-id="cjptr3x5o003ulyz9pzxqfhf4" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链表/">链表</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——最短路径Dijkstra算法(C++和Java实现)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/16/数据结构——最短路径Dijkstra算法(C++和Java实现)/" class="article-date">
  <time datetime="2017-10-16T13:52:48.000Z" itemprop="datePublished">2017-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/16/数据结构——最短路径Dijkstra算法(C++和Java实现)/">数据结构——最短路径Dijkstra算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在上一篇博文里，我记录了最小生成树的算法实现，而在这篇里，我们来讲讲查找最短路径的算法，Dijkstra算法。</p>
<p>Dijkstra's algorithm常用于路由算法或者作为其他图算法的一个子模块。距离来说，如果我们将图的顶点理解为每个城市，而边上的权重表示城市间开车行径的路径，该算法可以用来找到两个城市之间的最短路径。</p>
<p>&lt;!--more--&gt;</p>
<p>Dijkstra算法是通过为每个顶点v保留目前为止所找到的从s到v的最短路径来工作的。初始时，原点s的路径权重被赋为0(d[s] = 0)。若对于顶点s存在能直接到达的边，则比较路径的长度，如果路径更短则更新存储的值，当算法结束时，d[v]中存储的便是从s到v的最短路径，或者如果路径不存在的话则是无法访问，用marked数组来记录从s到点v是否存在路径。下面我们来看Dijkstra算法的代码实现，首先是C++版本：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IndexMinHeap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法求最短路径</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                        <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">int</span> s;                           <span class="comment">// 起始点</span></span><br><span class="line">    Weight *distTo;                  <span class="comment">// distTo[i]存储从起始点s到i的最短路径长度</span></span><br><span class="line">    <span class="keyword">bool</span> *marked;                    <span class="comment">// 标记数组，在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt; from;     <span class="comment">// from[i]记录最短路径中，到达i点的边是哪一条</span></span><br><span class="line">                                     <span class="comment">// 可以用来恢复整个最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用Dijkstra算法求最短路径</span></span><br><span class="line">    Dijkstra(Graph &amp;graph, <span class="keyword">int</span> s):G(graph) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() );</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Weight[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            distTo[i] = Weight();</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            from.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用索引堆记录当前找到的到达每个顶点的最短距离</span></span><br><span class="line">        IndexMinHeap&lt;Weight&gt; ipq(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于起始点s进行初始化</span></span><br><span class="line">        distTo[s] = Weight();</span><br><span class="line">        from[s] = <span class="keyword">new</span> Edge&lt;Weight&gt;(s, s, <span class="number">0</span>);</span><br><span class="line">        ipq.insert(s, distTo[s]);</span><br><span class="line">        marked[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>( !ipq.isEmpty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            <span class="comment">// distTo[v] 就是s到v的最短距离</span></span><br><span class="line">            marked[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 对v的所有相邻节点进行更新</span></span><br><span class="line">            <span class="keyword">typename</span> Graph::<span class="function">adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> ( Edge&lt;Weight&gt; *e = adj.begin(); !adj.end(); e = adj.next() ) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = e-&gt;other(v);</span><br><span class="line">                <span class="comment">// 如果从s点到w点的最短路径还没有找到</span></span><br><span class="line">                <span class="keyword">if</span> ( !marked[w] ) &#123;</span><br><span class="line">                    <span class="comment">// 如果w点以前没有访问过</span></span><br><span class="line">                    <span class="comment">// 或者访问过，但是通过当前的v点到w点距离更短，则进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> ( from[w] == <span class="literal">NULL</span> || distTo[v] + e-&gt;wt() &lt; distTo[w] ) &#123;</span><br><span class="line">                        distTo[w] = distTo[v] + e-&gt;wt();</span><br><span class="line">                        from[w] = e;</span><br><span class="line">                        <span class="keyword">if</span> ( ipq.contain(w) )</span><br><span class="line">                            ipq.change( w, distTo[w] );</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            ipq.insert( w, distTo[w] );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Dijkstra() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] distTo;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">        <span class="keyword">delete</span> from[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function">Weight <span class="title">shortestPathTo</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        assert( hasPathTo(w) );</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathTo</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找从s到w的最短路径，将整个路径经过的边存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shortestPath</span><span class="params">( <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; &amp;vec )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        assert( hasPathTo(w) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径，存放在栈中</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">        Edge&lt;Weight&gt; *e = from[w];</span><br><span class="line">        <span class="keyword">while</span>(e-&gt;v() != <span class="keyword">this</span>-&gt;s) &#123;</span><br><span class="line">            s.push(e);</span><br><span class="line">            e = from[e-&gt;v()];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.push(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素，获得顺序的从s到w的路径</span></span><br><span class="line">        <span class="keyword">while</span>( !s.empty() ) &#123;</span><br><span class="line">            e = s.top();</span><br><span class="line">            vec.push_back(*e);</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        assert( hasPathTo(w) );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; vec;</span><br><span class="line">        shortestPath( w, vec );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i].v() &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">            <span class="keyword">if</span> ( i == vec.size() - <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vec[i].w() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>之后是java版本的:</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra算法求最短路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph G;      <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;                <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">private</span> Number[] distTo;      <span class="comment">// distTo[i]存储从起始点s到点i的最短路径长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;     <span class="comment">// 标记数组，在算法运行过程中标记节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[] from;  <span class="comment">// 可以用来恢复整个最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用Dijkstra算法求最短路径</span></span><br><span class="line">    Dijkstra(WeightedGraph graph, <span class="keyword">int</span> s) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        <span class="keyword">this</span>.G = graph;</span><br><span class="line">        <span class="keyword">assert</span> s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V();</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Number[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            distTo[i] = <span class="number">0.0</span>;</span><br><span class="line">            marked[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用索引堆记录当前找到的每个到达顶点的最短距离                                                                     iikkkkkk</span></span><br><span class="line">        IndexMinHeap&lt;Weight&gt; ipq = <span class="keyword">new</span> IndexMinHeap&lt;Weight&gt;(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于起始点s进行初始化</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        from[s] = <span class="keyword">new</span> Edge&lt;Weight&gt;(s, s, (Weight)(Number)(<span class="number">0.0</span>));</span><br><span class="line">        ipq.insert(s, (Weight) distTo[s]);</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!ipq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// distTo[v]就是s到v的最短距离</span></span><br><span class="line">            marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对v的所有相邻节点进行更新</span></span><br><span class="line">            <span class="keyword">for</span> (Object item : G.adj(v)) &#123;</span><br><span class="line">                Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">                <span class="keyword">int</span> w = e.other(v);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果s点到w点的最短路径还没有找到</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果w点以前没有访问过</span></span><br><span class="line">                    <span class="comment">// 或者访问过，但是通过当前v点到w点的距离g更短，则进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> (from[w] == <span class="keyword">null</span> || distTo[v].doubleValue() + e.wt().doubleValue() &lt; distTo[w].doubleValue()) &#123;</span><br><span class="line">                        distTo[w] = distTo[v].doubleValue() + e.wt().doubleValue();</span><br><span class="line">                        from[w] = e;</span><br><span class="line">                        <span class="keyword">if</span> ( ipq.contain(w) ) &#123;</span><br><span class="line">                            ipq.change(w, (Weight) distTo[w]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ipq.insert(w, (Weight) distTo[w]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">shortestPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasPathTo</span><span class="params">(w)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找从s点到w点的最短路径，将整个路径存放在vec中</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; shortestPath(<span class="keyword">int</span> w) &#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasPathTo</span><span class="params">(w)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过from数组逆向查找从s到w的路径，存放到栈中</span></span><br><span class="line">        Stack&lt;Edge&lt;Weight&gt;&gt; s = <span class="keyword">new</span> Stack&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">        Edge&lt;Weight&gt; e = from[w];</span><br><span class="line">        <span class="keyword">while</span> (e.v() != <span class="keyword">this</span>.s) &#123;</span><br><span class="line">            s.push(e);</span><br><span class="line">            e = from[e.v()];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.push(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素，获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; res = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            e = s.pop();</span><br><span class="line">            res.add(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasPathTo</span><span class="params">(w)</span></span>;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; path =  shortestPath(w);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; path.size() ; i ++ )&#123;</span><br><span class="line">            System.out.print( path.elementAt(i).v() + <span class="string">" -&gt; "</span>);</span><br><span class="line">            <span class="keyword">if</span>( i == path.size()-<span class="number">1</span> )</span><br><span class="line">                System.out.println(path.elementAt(i).w());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/16/数据结构——最短路径Dijkstra算法(C++和Java实现)/" data-id="cjptr3x8x00eklyz9gng54dk3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dijkstra/">Dijkstra</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——最小生成树(C++和Java实现)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/09/数据结构——最小生成树(C++和Java实现)/" class="article-date">
  <time datetime="2017-10-09T13:30:33.000Z" itemprop="datePublished">2017-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/09/数据结构——最小生成树(C++和Java实现)/">数据结构——最小生成树(C++和Java实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>快要一整个月没有更新博客了，之前的几周每周都想着要写，但是最后时间还是排不开，最近的状态是一直在写代码，一直在怼工作的需求，顺便刷刷算法题，国庆则是没心没肺的玩了七八天，时间这么一分摊，写博客的时间总是挤不出来，罪过罪过。</p>
<p>其实数据结构的系列一直也没有写到头，之后还打算写一个<code>Leetcode</code>刷题系列，最近刷的题越多，越是感叹某些题目的解法精妙。</p>
<p>今天就接着上个月的来讲讲最小生成树的算法吧。</p>
<p>&lt;!--more--&gt;</p>
<p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。最小生成树其实是最小权重生成树的简称。</p>
<p>一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或等于其他生成树的边的权值之和。广义上而言，对于非联通无向图来说，它的每一连通分量同样有最小生成树。</p>
<p>以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有意最小的生成树能使布线成本最低。</p>
<p>简单点说有几个城市你要设计一个线路，这个线路能走完所有的这几个城市，而且路程最短，这个线路就是最小生成树的含义。</p>
<p>所以从上面的例子可以看出来，最小生成树这个算法，对于解决生活实际问题，是一个很重要的存在。下面我们看看最小生成树的算法：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IndexMinHeap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用优化的Prim算法求图的最小生成树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                         <span class="comment">// 图的引用</span></span><br><span class="line">    IndexMinHeap&lt;Weight&gt; ipq;         <span class="comment">// 最小索引堆，算法辅助数据结构</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt;* &gt; edgeTo;   <span class="comment">// 访问的点所对应的边，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">bool</span>* marked;                     <span class="comment">// 标记数组，在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; mst;       <span class="comment">// 最小生成树所包含的所有边</span></span><br><span class="line">    Weight mstWeight;                 <span class="comment">// 最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点v</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">( <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">        assert( !marked[v] );</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typename</span> Graph::<span class="function">adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.begin(); !adj.end(); e = adj.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e-&gt;other(v);</span><br><span class="line">            <span class="comment">// 如果另一个端点未被访问</span></span><br><span class="line">            <span class="keyword">if</span> ( !marked[w] ) &#123;</span><br><span class="line">                <span class="comment">// 如果从没有考虑过这个端点，直接将这个端点和与之相连的边加入索引堆</span></span><br><span class="line">                <span class="keyword">if</span> ( !edgeTo[w] ) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.insert(w, e-&gt;wt());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果曾经考虑过这个端点，但现在的边比之前的边更短，则进行替换</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( e-&gt;wt() &lt; edgeTo[w]-&gt;wt() ) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.change(w, e-&gt;wt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    PrimMST(Graph &amp;graph):G(graph), ipq(IndexMinHeap&lt;<span class="keyword">double</span>&gt;(graph.V())) &#123;</span><br><span class="line"></span><br><span class="line">        assert( graph.E() &gt;= <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            edgeTo.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mst.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>( !ipq.isEmpty() ) &#123;</span><br><span class="line">            <span class="comment">// 使用最小索引堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            <span class="comment">// 最小索引堆中存储的是点的索引，通过点的索引找到相对应的边</span></span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            assert ( edgeTo[v] );</span><br><span class="line">            mst.push_back( *edgeTo[v] );</span><br><span class="line">            visit( v );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mstWeight = mst[<span class="number">0</span>].wt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mst.size(); i++) &#123;</span><br><span class="line">            mstWeight += mst[i].wt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~PrimMST() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt; Edge&lt;Weight&gt; &gt; mstEdges() &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的是C++版本的最小生成树Prim MST算法，其中我引进了<code>Edge</code>这个类的数据结构：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EDGE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDGE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b;       <span class="comment">// 边的两个端点</span></span><br><span class="line">    Weight weight;  <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Weight weight) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空的构造函数，所有的成员变量都取默认值</span></span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Edge() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">v</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;  <span class="comment">// 返回第一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> b; &#125;  <span class="comment">// 返回第二个顶点</span></span><br><span class="line">    <span class="function">Weight <span class="title">wt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> weight; &#125;  <span class="comment">// 返回权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定一个顶点，返回另一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">        assert( x == a || x == b);</span><br><span class="line">        <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出边的信息</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Edge &amp;e) &#123;</span><br><span class="line">        os &lt;&lt; e.a &lt;&lt; <span class="string">"-"</span> &lt;&lt; e.b &lt;&lt; <span class="string">": "</span> &lt;&lt; e.weight;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的大小比较，是对边的权值的大小比较</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt;= e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt;= e.wt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight == e.wt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//EDGE_H</span></span></span><br></pre></td></tr></table></figure></p>
<p>接下来放上<code>Java</code>版本:</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeightedGraph&lt;Weight&gt; G;        <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinHeap&lt;Weight&gt; ipq;       <span class="comment">// 最小索引堆，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[] edgeTo;          <span class="comment">// 访问的点所对应的边，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst;       <span class="comment">// 标记数组，在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;               <span class="comment">// 最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;               <span class="comment">// 最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(WeightedGraph graph)</span> </span>&#123;</span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">assert</span> graph.E() &gt;= <span class="number">1</span>;</span><br><span class="line">        ipq = <span class="keyword">new</span> IndexMinHeap&lt;Weight&gt;(graph.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            marked[i] = <span class="keyword">false</span>;</span><br><span class="line">            edgeTo[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mst = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!ipq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 使用最小索引堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            <span class="comment">// 最小索引堆中存储的是点的索引，通过点的索引找到相对应的边</span></span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            <span class="keyword">assert</span> (edgeTo[v] != <span class="keyword">null</span>);</span><br><span class="line">            mst.add(edgeTo[v]);</span><br><span class="line">            visit(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mst.size(); i++) &#123;</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点v</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (!marked[v]);</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将和节点v相连接的未访问的另一端点，和与之相连接的边，放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span> (Object item : G.adj(v)) &#123;</span><br><span class="line">            Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;)item;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="comment">// 如果边的另一个端点未被访问</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                <span class="comment">// 如果从没有考虑过这个端点，直接将这个端点和与之相连接的边加入索引堆</span></span><br><span class="line">                <span class="keyword">if</span> (edgeTo[w] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.insert(w, e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果曾经考虑过这个端点，但现在的边比之前考虑的边更短，则进行替换</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e.wt().compareTo(edgeTo[w].wt()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.change(w, e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges() &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中Edge的数据结构如下:</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&lt;<span class="title">Weight</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;          <span class="comment">// 边的两个端点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span> Weight weight;  <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Weight weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Edge&lt;Weight&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = e.a;</span><br><span class="line">        <span class="keyword">this</span>.b = e.b;</span><br><span class="line">        <span class="keyword">this</span>.weight = e.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">v</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;  <span class="comment">// 返回第一个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;  <span class="comment">// 返回第二个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weight <span class="title">wt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; <span class="comment">// 返回权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定一个顶点，返回另一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (x == a || x == b);</span><br><span class="line">        <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出边的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> + a + <span class="string">"-"</span> + b + <span class="string">": "</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 边之间的比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> that 另一个边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weight.compareTo(that.wt()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight.compareTo(that.wt()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后只要找到txt格式的测试用例，就能很轻易的测试出我们的最小生成树是否合格, 并且能很清晰的打印出最小成成树的路径，具体的测试用例可以去我的Github里找到。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/09/数据结构——最小生成树(C++和Java实现)/" data-id="cjptr3x8v00ehlyz9449qwvpo" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——无权图的路径问题(C++和java实现)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/11/数据结构——无权图的路径问题(C++和java实现)/" class="article-date">
  <time datetime="2017-09-11T06:20:32.000Z" itemprop="datePublished">2017-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/11/数据结构——无权图的路径问题(C++和java实现)/">数据结构——无权图的路径问题(C++和java实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>好像又是接近半个月没有更新，这半个月忙着结婚的各项事情，本来预计的学习任务也拖拖拉拉，进度缓慢。吐槽一句，拍婚纱照真的是最非常非常累的一件事情，不想再有下次了。</p>
<p>好吧，言归正传，今天就在这周缓慢的学习进度中，抽取出来一个比较有代表性的知识点，记录一下吧。</p>
<p>首先，首次接触图这个类型的数据结构，我们先来看一下图的定义，了解一下到底什么是图。</p>
<p>&lt;!--more--&gt;</p>
<p>图是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为:G(V,E), 其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<p>接下来我们把图的定义与线性表定义的进行一下对比，让我们来更好的体会一下图的各种定义与其他数据结构的差异:</p>
<ul>
<li>线性表中，我们把数据元素叫做元素，树种将数据元素叫结点，在图中的数据元素，我们则称之为顶点。</li>
<li>线性表中没有数据元素，称为空表。树种可以没有结点，叫做空树。但是在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V是有穷非空的。</li>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li>
</ul>
<p>图的定义我们就暂时讲到这里，更细致的定义希望大家自己在网络或者书籍中获取资料，毕竟我写的再多，也不如教科书详尽，今天我们就来讲一个图的应用，关于路径查找的问题。在这里我想先说明，我们的路径查找是一种针对无向图的路径查找，比如给出起始点A，查询顶点A至顶点B是否有路径，若是有路径，则打印出A至B的路径。而这个路径，我们寻找的不一定是最短路径。</p>
<p>其实分析这个问题就可以知道，这是对图的深度优先遍历(Depth-First-Search 简称DFS)的一个应用，若是我们能实现了图的深度优先遍历，那么查找路径的问题也就迎刃而解。</p>
<p>接下来就先给出C++的代码，来展示解决查询路径问题的思路：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径查询</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G; <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">int</span> s;    <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">bool</span>* visited; <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">int</span>* from; <span class="comment">// 记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typename</span> Graph::<span class="function">adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数、寻路算法、寻找图graph从s点到其他点的路径</span></span><br><span class="line">    Path(Graph &amp;graph, <span class="keyword">int</span> s): G(graph) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻路算法</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Path() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询s点到w点的路径，存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">( <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec )</span> </span>&#123;</span><br><span class="line">        assert( hasPath(w) );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径，存放在栈中</span></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素，获得顺序从s到w的路径</span></span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span> ( !<span class="built_in">stack</span>.empty() ) &#123;</span><br><span class="line">            vec.push_back( <span class="built_in">stack</span>.top() );</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">( <span class="keyword">int</span> w )</span> </span>&#123; </span><br><span class="line">        assert( hasPath(w) );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w, vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span> (i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>
通过上面的代码可以得知，我们首先在构造函数中传入我们的图数据结构graph，以及我们标记的起始点S。而通过<code>showPath()</code>函数我们能够展示起始点S至任意点的路径，测试代码就如下所示:</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    ReadGraph&lt;SparseGraph&gt; readGraph(g, filename);</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较使用深度优先遍历和广度优先遍历获得路径的不同</span></span><br><span class="line">    <span class="comment">// 广度优先遍历获得的是无权图的最短路径</span></span><br><span class="line">    Path&lt;SparseGraph&gt; dfs(g, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS : "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    ShortestPath&lt;SparseGraph&gt; bfs(g, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS : "</span>;</span><br><span class="line">    bfs.showPath(<span class="number">6</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而Java版本的代码也是类似，只是某些函数的返回值变化了一点，代码如下:</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Graph G;  <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;  <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] from;  <span class="comment">// 记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，寻路算法，寻找图graph从点s到其他点的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 寻路起始点s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Path</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> s &gt;= <span class="number">0</span> &amp;&amp; s &lt; graph.V();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.G = graph;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 从v点开始深度优先遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点是否存在路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V();</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询点s到点w的路径，存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector&lt;Integer&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>(hasPath(w));</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span> (p != -<span class="number">1</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            vec.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从点s到点w的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (hasPath(w));</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = path(w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            System.out.print(vec.elementAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i == vec.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">" -&gt; "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>今天的无权图的路径问题就讲解到这里，之后的知识点等学习整理之后，再行记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/11/数据结构——无权图的路径问题(C++和java实现)/" data-id="cjptr3x65004mlyz92h1tsgko" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图/">图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——最大索引堆(C++和Java实现)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/27/数据结构——最大索引堆(C++和Java实现)/" class="article-date">
  <time datetime="2017-08-27T13:17:46.000Z" itemprop="datePublished">2017-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/27/数据结构——最大索引堆(C++和Java实现)/">数据结构——最大索引堆(C++和Java实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在上一篇博客中，记录了优先队列——堆这个数据结构的实现，并且关于堆的性质我也在上文中介绍过，堆能用来进行排序，堆排序具有快速(复杂度O(NlogN))，稳定的特点，尤其是非常稳定，因此适用于某些需要排序稳定性的场合。</p>
<p>但是呢，普通的二叉堆有两个缺陷：</p>
<ul>
<li>在对的元素体积非常大的情况下，经常性的移动元素是低效的。</li>
<li>如果在堆的使用过程中，堆中的元素的值要改变，则普通堆对此无能为力，简单的说，如果一个元素如果进入堆之后，它的值就不能改变了，否则会影响堆的性质。</li>
</ul>
<p>第一个缺陷还能用类似于指针排序的技术解决，但是第二个缺陷不采用特殊的技术是没有办法解决的，然而在一些场合，堆中元素的值确实需要改变。于是乎，索引堆这个数据结构就在这里应运而生了。</p>
<p>&lt;!--more--&gt;</p>
<p>所谓索引堆，简单的说，就是在堆里头存放的不是数据，而是数据所在的数组的索引，也就是下标，根据数据的某种优先级来调整各个元素对应的下标在堆中的位置。本质上来说，索引堆也是堆，提供堆的接口。</p>
<p>那么接下来，我们就来尝试用<code>C++</code>和<code>Java</code>两种语言来实现索引堆，注释在代码中写的比较详细。</p>
<p>C++版如下:</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> *indexes;</span><br><span class="line">    <span class="keyword">int</span> *reverse;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[ indexes[k/<span class="number">2</span>] ] &lt; data[ indexes[k] ]) &#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>], indexes[k] );</span><br><span class="line">            reverse[indexes[k / <span class="number">2</span>]] = k / <span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[ indexes[j] ] &lt; data[ indexes[j+<span class="number">1</span>] ])</span><br><span class="line">                <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[ indexes[k] ] &gt; data[ indexes[j] ])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap( indexes[k], indexes[j] );</span><br><span class="line">            reverse[ indexes[k] ] = k;</span><br><span class="line">            reverse[ indexes[j] ] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity + <span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IndexMaxHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~IndexMaxHeap() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span> </span>&#123;</span><br><span class="line">        assert(count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        assert(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        assert( !contain(i) );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Item ret = data[ indexes[<span class="number">1</span>] ];</span><br><span class="line"></span><br><span class="line">        swap( indexes[<span class="number">1</span>], indexes[count] );</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        shiftDown( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>], indexes[count] );</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">        assert(contain(i));</span><br><span class="line">        <span class="keyword">return</span> data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i, Item newItem )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        assert(contain(i));</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到indexes[j] = i, j 表示 data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line">        <span class="comment">// for ( int j = 1; j &lt;= count; j++ ) &#123;</span></span><br><span class="line">        <span class="comment">//     if (indexes[j] == i) &#123;</span></span><br><span class="line">        <span class="comment">//         shiftUp(j);</span></span><br><span class="line">        <span class="comment">//         shiftDown(j);</span></span><br><span class="line">        <span class="comment">//         return;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有了 reverse 之后,</span></span><br><span class="line">        <span class="comment">// 我们可以非常简单的通过reverse直接定位索引i在indexes中的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = reverse[i];</span><br><span class="line">        shiftUp(j);</span><br><span class="line">        shiftDown(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index和反向数组reverse</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">testIndexesAndReverseIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> *copyReverseIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ )&#123;</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line">            copyReverseIndexes[i] = reverse[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = copyReverseIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(copyIndexes, copyIndexes + count + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(copyReverseIndexes, copyReverseIndexes + count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引和反向索引进行排序后,</span></span><br><span class="line">        <span class="comment">// 两个数组都应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyIndexes[i] ||</span><br><span class="line">                    copyReverseIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyReverseIndexes[i] )&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] copyIndexes;</span><br><span class="line">        <span class="keyword">delete</span>[] copyReverseIndexes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( reverse[ indexes[i] ] != i )&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Java版本的代码如下:</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大索引堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;    <span class="comment">// 最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] indexes;  <span class="comment">// 最大索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] reverse;  <span class="comment">// 最大索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = (Item[]) <span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="keyword">assert</span> (i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        <span class="keyword">assert</span> ( !contain(i) );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count + <span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Item ret = data[ indexes[<span class="number">1</span>] ];</span><br><span class="line">        swap(indexes, <span class="number">1</span>, count);</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap(indexes, <span class="number">1</span>, count);</span><br><span class="line">        reverse[ indexes[<span class="number">1</span>] ] = <span class="number">1</span>;</span><br><span class="line">        reverse[ indexes[count] ] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[ indexes[k / <span class="number">2</span>] ].compareTo( data[ indexes[k] ] ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(indexes, k / <span class="number">2</span>, k);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[ indexes[j] ].compareTo( data[ indexes[j+<span class="number">1</span>] ] ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data[ indexes[k] ].compareTo(data[ indexes[j] ]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(indexes, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换索引堆中的索引i和j</span></span><br><span class="line">    <span class="comment">// 由于有了反向索引reverse数组，</span></span><br><span class="line">    <span class="comment">// indexes数组发生改变以后， 相应的就需要维护reverse数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line"></span><br><span class="line">        reverse[ indexes[i] ] = i;</span><br><span class="line">        reverse[ indexes[j] ] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (contain(i));</span><br><span class="line">        <span class="keyword">return</span> data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, Item newItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>(contain(i));</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = reverse[i];</span><br><span class="line">        shiftUp(j);</span><br><span class="line">        shiftDown(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index和反向数组reverse</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">testIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] copyReverseIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ ) &#123;</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line">            copyReverseIndexes[i] = reverse[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        copyReverseIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(copyIndexes);</span><br><span class="line">        Arrays.sort(copyReverseIndexes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引和反向索引进行排序后,</span></span><br><span class="line">        <span class="comment">// 两个数组都应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i-<span class="number">1</span>] + <span class="number">1</span> != copyIndexes[i] ||</span><br><span class="line">                    copyReverseIndexes[i-<span class="number">1</span>] + <span class="number">1</span> != copyReverseIndexes[i] )&#123;</span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            System.out.println(<span class="string">"Error!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">        IndexMaxHeap&lt;Integer&gt; indexMaxHeap = <span class="keyword">new</span> IndexMaxHeap&lt;Integer&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            indexMaxHeap.insert(i, (<span class="keyword">int</span>) (Math.random() * N));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> indexMaxHeap.testIndexes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/27/数据结构——最大索引堆(C++和Java实现)/" data-id="cjptr3x8y00emlyz9qpsr51tn" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/索引堆/">索引堆</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——优先队列-C-和Java实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/18/数据结构——优先队列-C-和Java实现/" class="article-date">
  <time datetime="2017-08-18T13:10:11.000Z" itemprop="datePublished">2017-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/18/数据结构——优先队列-C-和Java实现/">数据结构——优先队列(C++和Java实现)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>十几天没有更新自己的博客了，因为目前在算法和数据结构的学习中，碰到了一些问题，例如之前就在优先队列，堆这个数据结构面前，感觉到有点吃不透概念，而使用的那本书上写的实在太抽象了，所以又查找了很多资料，最终对优先队列这个数据结构有了一定的了解。花了点时间才啃下来的知识，当然要把它记录下来了，所以今天就来回顾一下优先队列。</p>
<p>&lt;!--more--&gt;</p>
<p>优先队列也是一种抽象数据类型。优先队列中的每个元素都有各自的优先级。这个概念其实打几个比方会理解的比较快一点。比如我们人人都用过的windows系统，当我们打开任务管理器的时候，每个任务的优先级别是不同的，而操作系统会选择优先级别最高的任务先执行，同时我们也能在选项里标记任务的优先级。再比如夜班的急诊大夫，如果之前来了两三个感冒发烧的病人正在排队看病，这时候，匆匆忙忙抬进来一个心脏病突发的病人，那我们的大夫当然要先去治疗心脏病突发的病人了。优先队列也是一个道理，优先处理优先级别高的数据或者任务。</p>
<p>优先级最高的元素最先得到服务，优先级别相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。</p>
<p>优先队列至少要支持这些操作：</p>
<ul>
<li>插入带优先级的元素。</li>
<li>取出具有最高优先级的元素。</li>
<li>查看最高优先级的元素。（O(1)的时间复杂度）</li>
</ul>
<p>出于性能的考虑，优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(log n),构造二叉树的时间复杂度为O(nlogn)。</p>
<p>而从时间复杂度的角度，优先队列其实等价于排序算法。而接下来我们就要用C++和Java两种编程语言来实现优先队列。为什么现在要用两种语言呢，其实仅仅是我在使用了C++写完了数据结构之后，改换Java又实现了一遍，经过测试，代码是通过并满足优先队列的性质的，所以一起放出来了。</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k]) &#123;</span><br><span class="line">            swap( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[j] &lt; data[j+<span class="number">1</span>])</span><br><span class="line">                <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[k] &gt; data[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k], data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MaxHeap() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像最大堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        assert(count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        data[ count + <span class="number">1</span> ] = item;</span><br><span class="line">        count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>], data[count] );</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        shiftDown( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上是C++版本的实现，接下来是Java版本的实现，测试代码写在java里面，C++的测试也是一样的用例。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Item[] data;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，构造一个空堆，可容纳capacity个元素</span></span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值，表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大堆中插入一个新元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count + <span class="number">1</span> &lt;= capacity);</span><br><span class="line">        data[count + <span class="number">1</span>] = item;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        shiftUp( count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素，即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line">        swap(<span class="number">1</span>, count);</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown( <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Item item = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="comment">//* 最大堆核心辅助函数</span></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>].compareTo(data[k]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(k/<span class="number">2</span>, k);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; data[j].compareTo(data[j+<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data[k].compareTo(data[j]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试MaxHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaxHeap&lt;Integer&gt; maxHeap = <span class="keyword">new</span> MaxHeap&lt;Integer&gt;(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            maxHeap.insert( <span class="keyword">new</span> Integer((<span class="keyword">int</span>) (Math.random() * M)) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[N];</span><br><span class="line">        <span class="comment">// 将maxHeap中的数据使用extractMax()取出来</span></span><br><span class="line">        <span class="comment">// 取出来的顺序应该是从大到小排序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保arr数组是从大到小排序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">assert</span> arr[i-<span class="number">1</span>] &gt;= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/18/数据结构——优先队列-C-和Java实现/" data-id="cjptr3x64004jlyz9ajljkray" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优先队列/">优先队列</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——AVL树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/06/数据结构——AVL树/" class="article-date">
  <time datetime="2017-08-06T01:30:12.000Z" itemprop="datePublished">2017-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/06/数据结构——AVL树/">数据结构——AVL树(C语言)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>AVL(Adelson-Velskii 和 Landis)树是带有平衡条件的二叉查找树。在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(lngn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或-1的结点被认为是平衡的。带有平衡因子-2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
<p>&lt;!--more--&gt;</p>
<p>AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的&quot;AVL旋转&quot;。</p>
<p>以下图标表示的四种情况，就是AVL旋转中常见的四种。（图片用了维基百科的，不确定不开vpn图是否会挂）。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png" alt=""></p>
<p>下面来看AVL树的操作有哪些:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _AvlTree_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">AvlTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">MakeEmpty</span><span class="params">( AvlTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, AvlTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( AvlTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( AvlTree T )</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">( ElementType X, AvlTree T )</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">( ElementType X, AvlTree T )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">( Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _AvlTree_H */</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面是对于上面操作定义的实现:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AvlTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    AvlTree Left;</span><br><span class="line">    AvlTree Right;</span><br><span class="line">    <span class="keyword">int</span> Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">MakeEmpty</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MakeEmpty(T-&gt;Left);</span><br><span class="line">        MakeEmpty(T-&gt;Right);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算Avl节点高度</span></span><br><span class="line"><span class="comment"> * @param  P 节点P</span></span><br><span class="line"><span class="comment"> * @return 树高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Height</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> P-&gt;Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向左单旋 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotateWithLeft</span><span class="params">(Position K2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position K1;</span><br><span class="line"></span><br><span class="line">    K1 = K2-&gt;Left;</span><br><span class="line">    K2-&gt;Left = K1-&gt;Right;</span><br><span class="line">    K1-&gt;Right = K2;</span><br><span class="line"></span><br><span class="line">    K2-&gt;Height = Max(Height(K2-&gt;Left), Height(K2-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    K1-&gt;Height = Max(Height(K1-&gt;Left), K2-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K1; <span class="comment">/* New Root */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向右单旋  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotateWithRight</span><span class="params">(Position K2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position K1;</span><br><span class="line"></span><br><span class="line">    K1 = K2-&gt;Right;</span><br><span class="line">    K2-&gt;Right = K1-&gt;Left;</span><br><span class="line">    K1-&gt;Left = K2;</span><br><span class="line"></span><br><span class="line">    K2-&gt;Height = Max(Height(K2-&gt;Left), Height(K2-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    K1-&gt;Height = Max(K2-&gt;Height, Height(K1-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K1; <span class="comment">/*New root */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向左双旋 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotateWithLeft</span><span class="params">(Position K3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Rotate between K1 and K2 */</span></span><br><span class="line">    K3-&gt;Left = SingleRotateWithRight(K3-&gt;Left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rotate between K3 and K2 */</span></span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithLeft(K3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向右双旋 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotateWithRight</span><span class="params">(Position K3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    K3-&gt;Right = SingleRotateWithLeft(K3-&gt;Right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithRight(K3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">(ElementType X, AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( struct AvlNode ) );</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Out of space!!!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Element = X;</span><br><span class="line">            T-&gt;Height = <span class="number">0</span>;</span><br><span class="line">            T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element) <span class="comment">/* 左子树插入新节点 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Left = Insert(X, T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;Left) - Height(T-&gt;Right) == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (X &lt; T-&gt;Left-&gt;Element)</span><br><span class="line">                T = SingleRotateWithLeft(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRotateWithLeft(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element) <span class="comment">/* 右子树插入新节点 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Right = Insert(X, T-&gt;Right);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;Right) - Height(T-&gt;Left) == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (X &gt; T-&gt;Right-&gt;Element)</span><br><span class="line">                T = SingleRotateWithRight(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRotateWithRight(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Else X is in the tree alredy; we'll do nothing */</span></span><br><span class="line">    T-&gt;Height = Max(Height(T-&gt;Left), Height(T-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">(ElementType X, AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line">     <span class="keyword">if</span>(T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没找到该元素，无法删除！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element)</span><br><span class="line">         T-&gt;Left = Delete(X, T-&gt;Left);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">         T-&gt;Right = Delete(X, T-&gt;Right);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Left &amp;&amp; T-&gt;Right) &#123; <span class="comment">//要删除的树左右都有儿子</span></span><br><span class="line">         TmpCell = FindMin(T-&gt;Right);   <span class="comment">//用该结点右儿子上最小结点替换该结点，然后与只有一个儿子的操作方法相同</span></span><br><span class="line">         T-&gt;Element = TmpCell-&gt;Element;</span><br><span class="line">         T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         TmpCell = T;        <span class="comment">//要删除的结点只有一个儿子</span></span><br><span class="line">         <span class="keyword">if</span>(T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">             T = T-&gt;Right;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">             T = T-&gt;Left;</span><br><span class="line">         <span class="built_in">free</span>(TmpCell);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找X元素所在的位置 */</span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (X &lt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* search the min element in AvlTree*/</span></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(T-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* search the max element in AvlTree */</span></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMax(T-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> P-&gt;Element;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTravel</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        PreorderTravel(T-&gt;Left);</span><br><span class="line">        PreorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTravel</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InorderTravel(T-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        InorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTravel</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostorderTravel(T-&gt;Left);</span><br><span class="line">        PostorderTravel(T-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印二叉树信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(AvlTree T, ElementType Element, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is root\n"</span>, T-&gt;Element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is %2d's %6s child\n"</span>, T-&gt;Element, Element, direction == <span class="number">1</span> ? <span class="string">"right"</span> : <span class="string">"left"</span>);</span><br><span class="line"></span><br><span class="line">        PrintTree(T-&gt;Left, T-&gt;Element, <span class="number">-1</span>);</span><br><span class="line">        PrintTree(T-&gt;Right, T-&gt;Element, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实现完成这些函数后，我们在<code>main</code>函数中对AVL树进行测试:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line"></span><br><span class="line">    AvlTree T;</span><br><span class="line">    Position P;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    T = MakeEmpty(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    T = Insert(<span class="number">21</span>, T);</span><br><span class="line">    T = Insert(<span class="number">2150</span>, T);</span><br><span class="line">    T = Insert(<span class="number">50</span>, T);</span><br><span class="line">    T = Insert(<span class="number">12</span>, T);</span><br><span class="line">    T = Insert(<span class="number">1201</span>, T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Root: %d\n"</span>, T-&gt;Element);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的详细信息: \n"</span>);</span><br><span class="line">    PrintTree(T, T-&gt;Element, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树: \n"</span>);</span><br><span class="line">    PreorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树: \n"</span>);</span><br><span class="line">    InorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树: \n"</span>);</span><br><span class="line">    PostorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大值: %d\n"</span>, FindMax(T)-&gt;Element);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最小值: %d\n"</span>, FindMin(T)-&gt;Element);</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">50</span>, T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的详细信息: \n"</span>);</span><br><span class="line">    PrintTree(T, T-&gt;Element, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/06/数据结构——AVL树/" data-id="cjptr3x61004flyz9kc7f42q2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AVL树/">AVL树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——二叉查找树(C语言)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/29/数据结构——二叉查找树(C语言)/" class="article-date">
  <time datetime="2017-07-29T13:08:33.000Z" itemprop="datePublished">2017-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/29/数据结构——二叉查找树(C语言)/">数据结构——二叉查找树(C语言)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>二叉查找树，也称作二叉搜索树，有序二叉树，排序二叉树，而当一棵空树或者具有下列性质的二叉树，就可以被定义为二叉查找树：</p>
<ul>
<li>
<p>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值。</p>
</li>
<li>
<p>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值。</p>
</li>
<li>
<p>任意节点的左、右子树也分别为二叉查找树。</p>
</li>
<li>
<p>没有键值相等的节点。</p>
</li>
</ul>
<p>二叉查找树相比于其他数据结构的优势在查找、插入的时间复杂度较低，为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构,如集合、multiset、关联数组等。对于大量的输入数据，链表的线性访问时间太慢，不宜使用。</p>
<p>&lt;!--more--&gt;</p>
<p>下面来看我们为二叉查找树定义的抽象行为：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Tree_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">SearchTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">( SearchTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, SearchTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( SearchTree T )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( SearchTree T )</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">( ElementType X, SearchTree T )</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">( ElementType X, SearchTree T )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">( Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>而对于上述抽象行为的实现，我们先来给出实现代码:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    SearchTree Left;</span><br><span class="line">    SearchTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MakeEmpty(T-&gt;Left);</span><br><span class="line">        MakeEmpty(T-&gt;Right);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (X &lt; T-&gt;Element )</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">        <span class="keyword">return</span> Find(X, T-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> ( T-&gt; Left == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin( T-&gt;Left );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( T != <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">while</span>(T-&gt;Right != <span class="literal">NULL</span>)</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create and return a one-node tree */</span></span><br><span class="line">        T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( struct TreeNode ));</span><br><span class="line">        <span class="keyword">if</span> ( T == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Out of space!!!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Element = X;</span><br><span class="line">            T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element)</span><br><span class="line">        T-&gt;Left = Insert(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">        T-&gt;Right = Insert(X, T-&gt;Right);</span><br><span class="line">    <span class="comment">/* Else X is in the tree already; we'll do nothing */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(ElementType X, SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Element not found\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element) <span class="comment">/* Go left */</span></span><br><span class="line">        T-&gt;Right = Delete(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element) <span class="comment">/* Go Right */</span></span><br><span class="line">        T-&gt;Right = Delete(X, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Left &amp;&amp; T-&gt;Right) <span class="comment">/* Two Children */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Replace with smallest in right subtree */</span></span><br><span class="line">        TmpCell = FindMin(T-&gt;Right);</span><br><span class="line">        T-&gt;Element = TmpCell-&gt;Element;</span><br><span class="line">        T-&gt;Right = Delete(T-&gt;Element, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* One or zero children */</span></span><br><span class="line">    &#123;</span><br><span class="line">        TmpCell = T;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;Left == <span class="literal">NULL</span>) <span class="comment">/* Also handles 0 children */</span></span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        <span class="built_in">free</span>( TmpCell );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P-&gt;Element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTravel</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        PreorderTravel(T-&gt;Left);</span><br><span class="line">        PreorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历"二叉树"</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTravel</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InorderTravel(T-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">        InorderTravel(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树</span></span><br><span class="line"><span class="comment"> * @param T Tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTravel</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostorderTravel(T-&gt;Left);</span><br><span class="line">        PostorderTravel(T-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(SearchTree T, ElementType Element, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is root\n"</span>, T-&gt;Element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d is %2d's %6s child\n"</span>, T-&gt;Element, Element, direction == <span class="number">1</span> ? <span class="string">"right"</span> : <span class="string">"left"</span>);</span><br><span class="line"></span><br><span class="line">        PrintTree(T-&gt;Left, T-&gt;Element, <span class="number">-1</span>);</span><br><span class="line">        PrintTree(T-&gt;Right, T-&gt;Element, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们对我们的实现代码，在<code>main</code>函数中进行测试:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello Leon\n"</span>);</span><br><span class="line">    SearchTree T;</span><br><span class="line">    MakeEmpty(T);</span><br><span class="line"></span><br><span class="line">    T = Insert(<span class="number">21</span>, T);</span><br><span class="line">    T = Insert(<span class="number">2150</span>, T);</span><br><span class="line">    T = Insert(<span class="number">127</span>, T);</span><br><span class="line">    T = Insert(<span class="number">121</span>, T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树的详细信息: \n"</span>);</span><br><span class="line">    PrintTree(T, T-&gt;Element, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树: \n"</span>);</span><br><span class="line">    PreorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树: \n"</span>);</span><br><span class="line">    InorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树: \n"</span>);</span><br><span class="line">    PostorderTravel(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大值: %d\n"</span>, FindMax(T)-&gt;Element);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最小值: %d\n"</span>, FindMin(T)-&gt;Element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行这个C文件，控制台打印的信息如下:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Hello wsx</span><br><span class="line">树的详细信息:</span><br><span class="line"><span class="number">21</span> is root</span><br><span class="line"><span class="number">2150</span> is <span class="number">21'</span>s  right child</span><br><span class="line"><span class="number">127</span> is <span class="number">2150'</span>s   left child</span><br><span class="line"><span class="number">121</span> is <span class="number">127'</span>s   left child</span><br><span class="line">前序遍历二叉树:</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">2150</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">121</span></span><br><span class="line">中序遍历二叉树:</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">121</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">2150</span></span><br><span class="line">后序遍历二叉树:</span><br><span class="line"><span class="number">121</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">2150</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line">最大值: <span class="number">2150</span></span><br><span class="line">最小值: <span class="number">21</span></span><br></pre></td></tr></table></figure></p>
<p>测试成功。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/29/数据结构——二叉查找树(C语言)/" data-id="cjptr3x63004hlyz98k9nnj8g" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉查找树/">二叉查找树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——链表的游标实现-C语言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/20/数据结构——链表的游标实现-C语言/" class="article-date">
  <time datetime="2017-07-20T00:14:12.000Z" itemprop="datePublished">2017-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/20/数据结构——链表的游标实现-C语言/">数据结构——链表的游标实现(C语言)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>上一篇博文我们用指针实现了链表，但是诸如BASIC和FORTRAN等许多语言都不支持指针。如果需要链表而又不能使用指针，这时我们可以使用游标（cursor）实现法来实现链表。</p>
<p>在链表的实现中有两个重要的特点：</p>
<ul>
<li>
<p>数据存储在一组结构体中。每一个结构体包含有数据以及指向下一个结构体的指针。</p>
</li>
<li>
<p>一个新的结构体可以通过调用malloc而从系统全局内存（global memory）得到，并可以通过free而被释放。</p>
</li>
</ul>
<p>游标法必须能够模仿实现这两条特性 。 下面给出实现代码:</p>
<p>&lt;!--more--&gt;</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CursorList_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> PtrToNode;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeCursorSpace</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">( List L )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLast</span><span class="params">( <span class="keyword">const</span> Position P, <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">( ElementType X, List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">( ElementType X, <span class="keyword">const</span> List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( ElementType X, List L, Position P )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">( <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Header</span><span class="params">( <span class="keyword">const</span> List L )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">First</span><span class="params">( <span class="keyword">const</span> List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Advance</span><span class="params">( <span class="keyword">const</span> Position P )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">( <span class="keyword">const</span> Position P )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*_CUrsor_H */</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以从上面的代码上看到，链表的游标实现跟链表的接口定义几乎是一样的。</p>
<p>下面放上实现代码:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CursorList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SpaceSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Position Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">CursorSpace</span>[ <span class="title">SpaceSize</span> ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the CursorSpace */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitCursorSpace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SpaceSize; i++)</span><br><span class="line">        CursorSpace[i].Next = i == SpaceSize<span class="number">-1</span> ? <span class="number">0</span> : i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">CursorAlloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = CursorSpace[<span class="number">0</span>].Next;</span><br><span class="line">    CursorSpace[<span class="number">0</span>].Next = CursorSpace[P].Next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CursorFree</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CursorSpace[P].Next = CursorSpace[<span class="number">0</span>].Next;</span><br><span class="line">    CursorSpace[<span class="number">0</span>].Next = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if L is empty */</span></span><br><span class="line"><span class="function">Status <span class="title">IsEmpty</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CursorSpace[L].Next == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if P is the last position in list L */</span></span><br><span class="line"><span class="comment">/* Parameter L is unused in this implementation */</span></span><br><span class="line"><span class="function">Status <span class="title">IsLast</span><span class="params">(Position P, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CursorSpace[P].Next == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return Position of X in L; 0 if not found */</span></span><br><span class="line"><span class="comment">/* Uses a header node */</span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = CursorSpace[L].Next;</span><br><span class="line">    <span class="keyword">while</span>(P &amp;&amp; CursorSpace[P].Element != X) &#123;</span><br><span class="line">        P = CursorSpace[P].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete first occurrence of X from a list */</span></span><br><span class="line"><span class="comment">/* Assume use of a header node */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(ElementType X, List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P, TmpCell;</span><br><span class="line"></span><br><span class="line">    P = FindPrevious(X, L);</span><br><span class="line">    <span class="keyword">if</span> (!IsLast(P, L))</span><br><span class="line">        TmpCell = CursorSpace[P].Next;</span><br><span class="line">        CursorSpace[P].Next = CursorSpace[TmpCell].Next;</span><br><span class="line">        CursorFree(TmpCell);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the front of the first X of The list */</span></span><br><span class="line"><span class="comment">/* Return 0 if not found */</span></span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">(ElementType X, <span class="keyword">const</span> List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position P;</span><br><span class="line">    P = L;</span><br><span class="line">    <span class="keyword">while</span>(P &amp;&amp; CursorSpace[CursorSpace[P].Next].Element != X)</span><br><span class="line">    &#123;</span><br><span class="line">        P = CursorSpace[P].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert(after legal position P) */</span></span><br><span class="line"><span class="comment">/* Header implementation assumed */</span></span><br><span class="line"><span class="comment">/* Parameter L is unused in this implemention */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X, List L, Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = CursorAlloc();</span><br><span class="line">    <span class="keyword">if</span> (TmpCell == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Out of space!\n"</span>);</span><br><span class="line">    CursorSpace[TmpCell].Element = X;</span><br><span class="line">    CursorSpace[TmpCell].Next = CursorSpace[P].Next;</span><br><span class="line">    CursorSpace[P].Next = TmpCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_list</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = L;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print_list: 链表为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = CursorSpace[L].Next;</span><br><span class="line">    <span class="keyword">while</span>(P != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, \n"</span>, CursorSpace[P].Element);</span><br><span class="line">        P = CursorSpace[P].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitCursorSpace();</span><br><span class="line">    List L = CursorAlloc();</span><br><span class="line">    CursorSpace[L].Next = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">1</span>, L, L);</span><br><span class="line">    Insert(<span class="number">0</span>, L, L);</span><br><span class="line">    Insert(<span class="number">21</span>, L, L);</span><br><span class="line">    Insert(<span class="number">1201</span>, L, L);</span><br><span class="line">    Position P;</span><br><span class="line">    P = Find(<span class="number">21</span>, L);</span><br><span class="line">    <span class="keyword">if</span> (P)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找到元素: %d\n"</span>, CursorSpace[P].Element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"未找到21元素\n"</span>);</span><br><span class="line">    Delete(<span class="number">0</span>, L);</span><br><span class="line">    Delete(<span class="number">1</span>, L);</span><br><span class="line">    print_list(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"检查链表是否为空: %d\n"</span>, IsEmpty(L));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现过程比较简单，最后的main函数是对游标链表的测试。代码直接开箱即用，可以看到测试过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/20/数据结构——链表的游标实现-C语言/" data-id="cjptr3x6a004qlyz9ida2p1ce" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链表/">链表</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/18/Nodejs中编写异步的单元测试代码/">Nodejs中编写异步的单元测试代码</a>
          </li>
        
          <li>
            <a href="/2018/11/30/理解JavaScript中的浮点数/">理解JavaScript中的浮点数</a>
          </li>
        
          <li>
            <a href="/2018/11/21/理解prototype、getPrototypeOf和-proto-之间的不同/">理解prototype、getPrototypeOf和 _proto _之间的不同</a>
          </li>
        
          <li>
            <a href="/2018/11/14/javascript——为自己的库编写更健壮的API函数/">javascript——为自己的库编写更健壮的API函数</a>
          </li>
        
          <li>
            <a href="/2018/10/09/服务器的Mysql初始化设置/">服务器的Mysql初始化设置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 李晓&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;xiao.liunit@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>