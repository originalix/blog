<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Leon的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="移动端,iOS,Android,javascript,html5,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验">
<meta property="og:type" content="website">
<meta property="og:title" content="Leon的博客">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Leon的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leon的博客">
  
    <link rel="alternate" href="/atom.xml" title="Leon的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Leon的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">每多学一点知识，就少写一行代码</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-判断设备型号、屏幕尺寸、系统版本、设备朝向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/iOS-判断设备型号、屏幕尺寸、系统版本、设备朝向/" class="article-date">
  <time datetime="2016-04-07T02:52:55.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/iOS-判断设备型号、屏幕尺寸、系统版本、设备朝向/">iOS 判断设备型号、屏幕尺寸、系统版本、设备朝向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>现在的iOS开发中，因为iPhone的尺寸越来越多，有时候自动布局也很难适配出很精美的UI界面，难免有时候想根据机型来适配界面，所以在这里教大家一种很简单的来判断机型的方法。就是根据屏幕尺寸来判断。</p>
<p>&lt;!--more--&gt;</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断设备型号</span></span><br><span class="line"><span class="meta">#define UI_IS_LANDSCAPE         ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft || [UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeRight)</span></span><br><span class="line"><span class="meta">#define UI_IS_IPAD              ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)</span></span><br><span class="line"><span class="meta">#define UI_IS_IPHONE            ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPhone)</span></span><br><span class="line"><span class="meta">#define UI_IS_IPHONE4           (UI_IS_IPHONE &amp;&amp; [[UIScreen mainScreen] bounds].size.height <span class="meta-string">&lt; 568.0)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define UI_IS_IPHONE5           (UI_IS_IPHONE &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 568.0)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define UI_IS_IPHONE6           (UI_IS_IPHONE &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 667.0)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define UI_IS_IPHONE6PLUS       (UI_IS_IPHONE &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 736.0 || [[UIScreen mainScreen] bounds].size.width == 736.0) // Both orientations</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define UI_IS_IOS8_AND_HIGHER   ([[UIDevice currentDevice].systemVersion floatValue] &gt;</span>= 8.0)</span></span><br></pre></td></tr></table></figure></p>
<p>使用方法：</p>
<p>1、在你喜欢的头文件或地方中加入 上面的预定义。</p>
<p>2、举个栗子，在代码中使用if(UI_IS_IPHONE4)</p>
<p>用过之后才发现真的是特别简单的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/iOS-判断设备型号、屏幕尺寸、系统版本、设备朝向/" data-id="cjptr3x4i001jlyz9nlnlww33" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS判断设备型号/">iOS判断设备型号</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-UINavigationBar使用总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/UINavigationBar使用总结/" class="article-date">
  <time datetime="2016-04-05T12:28:40.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/UINavigationBar使用总结/">UINavigationBar使用总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>UINavigationBar是一个我们在开发中必定会碰到的控件，用好它能帮助我们自定义导航栏的样式，所以今天讲解一下UINavigationBar的用法。</p>
<p>&lt;!--more--&gt;</p>
<h3>设置导航栏的标题</h3>
<p>这个直接是很简单的设置，一行代码搞定</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationItem.title = <span class="string">@"导航栏标题"</span>;</span><br></pre></td></tr></table></figure></p>
<h3>设置导航栏背景颜色</h3>
<p>导航栏的背景颜色，也是很简单的 自己替换代码中的颜色即可</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationBar.barTintColor =[<span class="built_in">UIColor</span> blackColor];</span><br></pre></td></tr></table></figure></p>
<h3>设置导航栏的背景图片</h3>
<p>这里虽然一行代码很简单，但是要来简单的说一下BarMetrics这个枚举值</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.navigationBar setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123.jpg"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示横屏竖屏都显示</span></span><br><span class="line"><span class="built_in">UIBarMetricsDefault</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示在只横屏下才显示，和UIBarMetricsLandscapePhone功效一样，不过iOS8已经弃用了</span></span><br><span class="line"><span class="built_in">UIBarMetricsCompact</span>,</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIBarMetricsDefaultPrompt</span>和<span class="built_in">UIBarMetricsCompactPrompt</span></span><br></pre></td></tr></table></figure></p>
<h3>更改顶部状态栏的颜色</h3>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIStatusBarStyle</span>) &#123;</span><br><span class="line">   <span class="built_in">UIStatusBarStyleDefault</span> = <span class="number">0</span>, <span class="comment">// Dark content, for use on light backgrounds</span></span><br><span class="line">    <span class="built_in">UIStatusBarStyleLightContent</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0) = <span class="number">1</span>, <span class="comment">// Light content, for use on dark backgrounds</span></span><br></pre></td></tr></table></figure></p>
<p>这个一个是默认的，黑色颜色，用于亮色背景，一个是白色用于深色背景</p>
<h3>设置返回按钮</h3>
<p>有时候我们会发现，我们设置的返回按钮都是蓝色的默认颜色，那么到底该怎么更改这些按钮的颜色呢</p>
<ul>
<li>设置返回按钮的颜色，只设置tintColor的颜色就好了</li>
</ul>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationController.navigationBar.tintColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure></p>
<ul>
<li>只设置返回按钮的图片</li>
</ul>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)goToBack &#123;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBackButtonWithImage &#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *leftButtonIcon = [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"LeftButton_back_Icon"</span>]imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysOriginal</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBarButtonItem</span> *leftButton = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:leftButtonIcon</span><br><span class="line">                                                                   style:<span class="built_in">UIBarButtonItemStyleBordered</span></span><br><span class="line">                                                                  target:<span class="keyword">self</span></span><br><span class="line">                                                                  action:<span class="keyword">@selector</span>(goToBack)];</span><br><span class="line">    <span class="keyword">self</span>.navigationItem.leftBarButtonItem = leftButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修复navigationController侧滑关闭失效的问题</span></span><br><span class="line">    <span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer.delegate = (<span class="keyword">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的地方有三点：</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要自己实现返回按钮的事件。</span><br><span class="line">特别的解释下<span class="built_in">UIImage</span>的imageWithRenderingMode:方法，参数<span class="built_in">UIImageRenderingModeAlwaysOriginal</span> 表示总是用原图渲染，如果不这么设置，返回按钮将会显示tintColor的颜色(默认为蓝色)。<span class="built_in">UITabbarItem</span>也存在同样地问题。</span><br><span class="line">我们自己设置返回按钮，会导致系统的侧滑关闭效果失效。添加上面代码中最后一句代码即可修复。</span><br></pre></td></tr></table></figure></p>
<ul>
<li>仅仅设置返回按钮的文字</li>
</ul>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBackButtonTitle &#123;</span><br><span class="line">    <span class="built_in">UIBarButtonItem</span> *leftButton = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"取消"</span>, <span class="literal">nil</span>)</span><br><span class="line">                                                                   style:<span class="built_in">UIBarButtonItemStylePlain</span></span><br><span class="line">                                                                  target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(goToBack)];</span><br><span class="line">    leftButton.tintColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="keyword">self</span>.navigationItem.leftBarButtonItem = leftButton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>自定义返回按钮</li>
</ul>
<p>如果你对返回按钮实在不满意，你可以自定义一个按钮，并把它设置为navigation的leftButton</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCustomLeftButton &#123;</span><br><span class="line">    <span class="built_in">UIView</span>* leftButtonView = [[<span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">40</span>)];</span><br><span class="line">    <span class="built_in">UIButton</span>* leftButton = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeSystem</span>];</span><br><span class="line">    leftButton.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    leftButton.frame = leftButtonView.frame;</span><br><span class="line">    [leftButton setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"LeftButton_back_Icon"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [leftButton setTitle:<span class="string">@"返回"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    leftButton.tintColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    leftButton.autoresizesSubviews = <span class="literal">YES</span>;</span><br><span class="line">    leftButton.contentHorizontalAlignment = <span class="built_in">UIControlContentHorizontalAlignmentLeft</span>;</span><br><span class="line">    leftButton.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>;</span><br><span class="line">    [leftButton addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(goToBack) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [leftButtonView addSubview:leftButton];</span><br><span class="line">    <span class="built_in">UIBarButtonItem</span>* leftBarButton = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:leftButtonView];</span><br><span class="line">    <span class="keyword">self</span>.navigationItem.leftBarButtonItem = leftBarButton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>设置导航栏底部线条的颜色</h3>
<p>有了上面的基础，设置导航栏线条的颜色就变得很简单了。
首先，我做了个UIImage的分类：通过颜色转成UIImage；
然后，用上面的方案来设置导航栏底部线条。</p>
<p>颜色转图片的代码：</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">ColorImage</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(rect.size);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [color <span class="built_in">CGColor</span>]);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>设置导航栏底部线条颜色的代码:</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UINavigationBar</span> *navigationBar = <span class="keyword">self</span>.navigationController.navigationBar;</span><br><span class="line">    [navigationBar setBackgroundImage:[[<span class="built_in">UIImage</span> alloc] init]</span><br><span class="line">                       forBarPosition:<span class="built_in">UIBarPositionAny</span></span><br><span class="line">                           barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">    <span class="comment">//此处使底部线条颜色为红色</span></span><br><span class="line">    [navigationBar setShadowImage:[<span class="built_in">UIImage</span> imageWithColor:[<span class="built_in">UIColor</span> redColor]]];</span><br></pre></td></tr></table></figure></p>
<p>关于navigation的用法，就先写到这里，以后碰到更多的问题再接着更新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/UINavigationBar使用总结/" data-id="cjptr3x4d0019lyz9qkzdr31n" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UINavigationBar/">UINavigationBar</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——定制UITextField" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/02/iOS开发——定制UITextField/" class="article-date">
  <time datetime="2016-04-02T13:07:27.000Z" itemprop="datePublished">2016-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/02/iOS开发——定制UITextField/">iOS开发——定制UITextField</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在iOS中UITextField这个控件作为文本输入控件一定是使用率最高的几个控件之一，而iOS提供的默认的原始TextField的造型肯定在开发时很难满足我们的要求，原因很简单，不够美观，实在太单调。所以今天我们从一些简单的复写UITextField方法开始，来讲一讲如何定制一个属于自己的UITextField。</p>
<p>&lt;!--more--&gt;</p>
<p>之前的文章我们讲过UITextField中，如何设置leftView，圆角以及控制文字输入时的距离。今天我们主要从UITextField的键盘收起、placeholder的设置以及自定义距离、字体，以及控制输入文本时，距离UITextField边框的距离和UITextField中一些常用的方法和枚举变量等方面来阐述如何定制自己的UITextField。</p>
<h3>键盘的收起</h3>
<p>首先我们先来看UITextField的键盘弹出和回收，UITextField在默认的情况下，键盘在输入完成后是不会自动回收的，这里我们讲解如何在按下Return键时，键盘自动回收。首先我们要遵循&lt;UITextFieldDelegate&gt;协议，之后在后面写入</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)textFieldShouldReturn:(<span class="built_in">UITextField</span> *)textField</span><br><span class="line">&#123;</span><br><span class="line">    [textField resignFirstResponder];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过写入这个方法，来实现按下Return按钮回收键盘。</p>
<h3>placeholder的设置</h3>
<p>在一些特定功能的文本输入框，我们常常要设置placeholder属性来指明当期UITextField的功能，例如：请在此处输入密码。可是placeholde的默认属性是紧贴文本输入框的，而且字体以及字体大小也不美观，于是我们可以这么来设置placeholder</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//控制placeHolder的位置，左右缩20</span></span><br><span class="line">-(<span class="built_in">CGRect</span>)placeholderRectForBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGRectInset</span>(bounds, <span class="number">20</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制左视图位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)leftViewRectForBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectInset</span>(bounds,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制编辑文本的位置</span></span><br><span class="line">-(<span class="built_in">CGRect</span>)editingRectForBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectInset</span>( bounds, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制显示文本的位置</span></span><br><span class="line">-(<span class="built_in">CGRect</span>)textRectForBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectInset</span>(bounds, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以先如上面的代码一样，设置placeholder的位置，同时要注意的一点是，在设置了placeholder的位置之后，我们也要相应的调整文本显示的位置，以及在编辑完成后，文本显示在输入框的位置。</p>
<p>至于placeholder的字体和字体大小设置 可以用如下方法设置，记住这个方法写在子类化的UITextField中是没有效果的，一定要写在创建UITextField的过程中。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    [TextField setValue:[<span class="built_in">UIFont</span> fontWithName:<span class="string">@"Arial"</span> size:<span class="number">12</span>]   forKeyPath:<span class="string">@"_placeholderLabel.font"</span>];</span><br></pre></td></tr></table></figure></p>
<h3>UITextField中一些常用的属性以及枚举变量</h3>
<p>####UITextFieldBorder 边框设置</p>
<p>设置TextField的边框效果，一定要设置了才有效果，类型如下</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITextBorderStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UITextBorderStyleNone</span>,</span><br><span class="line">    <span class="built_in">UITextBorderStyleLine</span>,</span><br><span class="line">    <span class="built_in">UITextBorderStyleBezel</span>,</span><br><span class="line">    <span class="built_in">UITextBorderStyleRoundedRect</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>####UITextFieldViewMode</p>
<p>此属性用来定义我们之前讲的leftView和rightView的存在时机</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITextFieldViewMode</span>) &#123;</span><br><span class="line">    <span class="built_in">UITextFieldViewModeNever</span>,</span><br><span class="line">    <span class="built_in">UITextFieldViewModeWhileEditing</span>,</span><br><span class="line">    <span class="built_in">UITextFieldViewModeUnlessEditing</span>,</span><br><span class="line">    <span class="built_in">UITextFieldViewModeAlways</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4>UIReturnKeyType返回按钮类型</h4>
<p>在键盘上的返回按键，系统也给我们提供了一些常用的类型</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIReturnKeyType</span>) &#123;</span><br><span class="line">    <span class="built_in">UIReturnKeyDefault</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyGo</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyGoogle</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyJoin</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyNext</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyRoute</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeySearch</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeySend</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyYahoo</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyDone</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyEmergencyCall</span>,</span><br><span class="line">    <span class="built_in">UIReturnKeyContinue</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_0),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4>UIKeyboardType键盘类型</h4>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIKeyboardType</span>) &#123;</span><br><span class="line">    <span class="built_in">UIKeyboardTypeDefault</span>,       </span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeASCIICapable</span>,      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeNumbersAndPunctuation</span>, </span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeURL</span>,    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeNumberPad</span>,  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypePhonePad</span>,             </span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeNamePhonePad</span>, </span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeEmailAddress</span>,</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">UIKeyboardTypeDecimalPad</span> ,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeWebSearch</span> ,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIKeyboardTypeAlphabet</span> = <span class="built_in">UIKeyboardTypeASCIICapable</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容</span></span><br><span class="line">  text.clearButtonMode = <span class="built_in">UITextFieldViewModeAlways</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每输入一个字符就变成点 用语密码输入</span></span><br><span class="line">  text.secureTextEntry = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否纠错</span></span><br><span class="line">  text.autocorrectionType = <span class="built_in">UITextAutocorrectionTypeNo</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="built_in">UITextAutocorrectionTypeDefault</span>, 默认</span><br><span class="line">    <span class="built_in">UITextAutocorrectionTypeNo</span>,   不自动纠错</span><br><span class="line">    <span class="built_in">UITextAutocorrectionTypeYes</span>,  自动纠错</span><br><span class="line">&#125; <span class="built_in">UITextAutocorrectionType</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//再次编辑就清空</span></span><br><span class="line">  text.clearsOnBeginEditing = <span class="literal">YES</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动  </span></span><br><span class="line">  textFied.adjustsFontSizeToFitWidth = <span class="literal">YES</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//首字母是否大写</span></span><br><span class="line">  text.autocapitalizationType = <span class="built_in">UITextAutocapitalizationTypeNone</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="built_in">UITextAutocapitalizationTypeNone</span>, 不自动大写</span><br><span class="line">    <span class="built_in">UITextAutocapitalizationTypeWords</span>,  单词首字母大写</span><br><span class="line">    <span class="built_in">UITextAutocapitalizationTypeSentences</span>,  句子的首字母大写</span><br><span class="line">    <span class="built_in">UITextAutocapitalizationTypeAllCharacters</span>, 所有字母都大写</span><br><span class="line">&#125; <span class="built_in">UITextAutocapitalizationType</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//键盘外观</span></span><br><span class="line">textView.keyboardAppearance=<span class="built_in">UIKeyboardAppearanceDefault</span>；</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line"><span class="built_in">UIKeyboardAppearanceDefault</span>， 默认外观，浅灰色</span><br><span class="line"><span class="built_in">UIKeyboardAppearanceAlert</span>，     深灰 石墨色</span><br><span class="line"> </span><br><span class="line">&#125; <span class="built_in">UIReturnKeyType</span>;</span><br></pre></td></tr></table></figure></p>
<p>大体属性已经罗列完毕，以后想到再来补充</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/02/iOS开发——定制UITextField/" data-id="cjptr3x4z002klyz9blg1crp3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UITextField/">UITextField</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——制作圆形头像" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/30/iOS开发——制作圆形头像/" class="article-date">
  <time datetime="2016-03-29T18:11:16.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/iOS开发——制作圆形头像/">iOS开发——制作圆形头像</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在iOS7之后，我们能发现许多应用都开始使用圆形来作为用户头像的形状，代表App就是腾讯QQ了，QQ的头像就是圆形的。</p>
<p>在今天看到美工给的登陆效果图时，我发现也是要求做一个圆形的头像显示效果，在晚上琢磨之后，我打算把这段经验记录一下，因为以后肯定会用到的次数也很多，为此我也专门Category一个类目以便日后使用。效果图如下 :</p>
<p>&lt;!--more--&gt;</p>
<p><img src="https://raw.githubusercontent.com/originalix/OuGeV1/master/OuGeV1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-30%20%E4%B8%8A%E5%8D%881.22.18.png" alt="圆形头像效果图"></p>
<p>这里可能看得不是特别清楚，实际的效果，在圆形头像的外部还有一个外框，用暗淡的阴影显示。</p>
<p>制作这个圆形头像，我的大体思路就是直接用Core graphic直接绘制，将原本的非圆形图片直接裁剪为圆形，之后再绘制上外面的阴影。</p>
<p>如果对外边框没有要求的同学，可以直接用最简单的方式来设置，我把简单的方法先贴出来:</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"icon_huo"</span>]; </span><br><span class="line"><span class="built_in">UIImageView</span> * imageV = <span class="keyword">self</span>.imageView; </span><br><span class="line">imageV.layer.masksToBounds = <span class="literal">YES</span>; </span><br><span class="line">imageV.layer.cornerRadius =imageV.frame.size.width / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**如果需要边框，请把下面2行注释去掉*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// imageV.layer.borderColor = [UIColor purpleColor].CGColor;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// imageV.layer.borderWidth = 10; </span></span><br><span class="line"></span><br><span class="line">imageV.image= image;</span><br></pre></td></tr></table></figure></p>
<p>为了之后代码的复用，以及提高开发效率，我把这个方法做了封装，我直接把封装好的代码贴出来，注释很全，很容易理解，对照着上面的效果图一起看吧。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  圆形头像的绘制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param icon 头像文件名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return image</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)imageWithIconName:(<span class="built_in">NSString</span> *)icon&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//边框大小</span></span><br><span class="line">    <span class="built_in">CGFloat</span> border = <span class="number">113.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里不用管实现的方法，只要你设置一张你想使用的边框图片就可以了</span></span><br><span class="line">    <span class="built_in">UIImage</span> *borderImg = [<span class="keyword">self</span> createImageWithColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">53</span> green:<span class="number">53</span> blue:<span class="number">68</span> alpha:<span class="number">0.32</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//头像图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:icon];</span><br><span class="line">    <span class="comment">//设置头像白色边框 像素6px</span></span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(image.size.width + border, image.size.height + border);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建图片上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制边框的圆</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剪切可视范围</span></span><br><span class="line">    <span class="built_in">CGContextClip</span>(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制边框图片</span></span><br><span class="line">    [borderImg drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置头像</span></span><br><span class="line">    <span class="built_in">CGFloat</span> iconX = border/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> iconY = border/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> iconW = image.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> iconH = image.size.height;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制圆形头像范围</span></span><br><span class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(context, <span class="built_in">CGRectMake</span>(iconX, iconY, iconW, iconH));</span><br><span class="line">    <span class="comment">//剪切可视范围</span></span><br><span class="line">    <span class="built_in">CGContextClip</span>(context);</span><br><span class="line">    <span class="comment">//绘制头像</span></span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(iconX, iconY, iconW, iconH)];</span><br><span class="line">    <span class="comment">//取出整个头像上下文的图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *iconImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> iconImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/30/iOS开发——制作圆形头像/" data-id="cjptr3x4v002blyz9djpw4nrr" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI/">UI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/圆形头像/">圆形头像</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-UITextField设置leftView、圆角以及文字距离" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/30/UITextField设置leftView、圆角以及文字距离/" class="article-date">
  <time datetime="2016-03-29T17:56:37.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/UITextField设置leftView、圆角以及文字距离/">UITextField设置leftView、圆角以及文字距离</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>今天在工作中，搭建一个登录界面，因为涉及到用户名和密码的输入，所以在iOS中我们免不了要用到UITextField这个常见的输入控件。首先来看一下美工给我的效果图，这里我仅仅截出了UITextField这个部分的效果：</p>
<p>&lt;!--more--&gt;</p>
<p><img src="https://raw.githubusercontent.com/originalix/OuGeV1/master/OuGeV1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-30%20%E4%B8%8A%E5%8D%881.27.27.png" alt="UITextField效果"></p>
<p>这里我们能看到这个UITextField的基本要求有如下几个：</p>
<ul>
<li>输入框内有提示图片</li>
<li>之后输入的文字与输入框内的图片有间距</li>
<li>输入框有圆角</li>
</ul>
<p>大致分为上面的三个特殊要求，那么我们一个一个来分析，首先是输入框内的提示图片，这里我们要讲UITextField里的两个属性，leftview和rightview，这两个属性分别能设置textField内的左右两边的视图，可以插入图片,我用最简单的代码来展示textField的leftview怎么实现。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="built_in">UIImageView</span> *imgView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"github.jpg"</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UITextField</span> *textField = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">20</span>)];</span><br><span class="line">    textField.leftView =imgView;</span><br><span class="line">    textField.leftViewMode = <span class="built_in">UITextFieldViewModeAlways</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addSubview:textField];</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，我们能很清楚的看到首先定义一个UIImageView，之后把这个imageView设置成textField的leftview，之后设置leftview的样式，就可以很简单的定义一个leftview。</p>
<p>UITextFieldViewMode是一个枚举类型，有如下属性:</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITextFieldViewMode</span>) &#123;</span><br><span class="line">    <span class="built_in">UITextFieldViewModeNever</span>,</span><br><span class="line">    <span class="built_in">UITextFieldViewModeWhileEditing</span>,</span><br><span class="line">    <span class="built_in">UITextFieldViewModeUnlessEditing</span>,</span><br><span class="line">    <span class="built_in">UITextFieldViewModeAlways</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是这样设置的TextField我们会发现，图片是紧紧贴在输入框的边缘的，看起来特别别扭不舒服，那么该怎么设置呢？我们可以子类化一个TextField，去复写它的一个方法来设置leftView的位置</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGRect</span>)leftViewRectForBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> iconRect = [<span class="keyword">super</span> leftViewRectForBounds:bounds];</span><br><span class="line">    iconRect.origin.x += <span class="number">15</span>; <span class="comment">//像右边偏15</span></span><br><span class="line">    <span class="keyword">return</span> iconRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在继承与UITextField中复写这个方法，得到的结果是leftView像右偏移15，是不是很简单呢。</p>
<p>如果这时候我们在输入框中打字，会发现leftview确实跟最初的输入框产生的距离，但是我们打出来的字还是紧紧的黏在图片上，用户体验也极差，根据上面的思路，我们可以接着在这个子类中复写它的设置方法来实现。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//UITextField 文字与输入框的距离</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)textRectForBounds:(<span class="built_in">CGRect</span>)bounds&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectInset</span>(bounds, <span class="number">45</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制文本的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)editingRectForBounds:(<span class="built_in">CGRect</span>)bounds&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectInset</span>(bounds, <span class="number">45</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前的图片是20大小，加上偏移的15那么一共是35，所以我们设置偏移45的量，即为文本比leftView的图片的最右边向右15。至此，我们已经完成了textField的文本和图片设置，最后来看一下圆角。</p>
<p>圆角有两种实现方式，一种是在layer层处理，来渲染绘制圆角</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    textField.layer.cornerRadius = <span class="number">4</span>;</span><br><span class="line">    textField.layer.masksToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure></p>
<p>第二种是设置UITextfield的样式，也能实现自带圆角，但是这个圆角的值是固定的</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textField.borderStyle = <span class="built_in">UITextBorderStyleRoundedRect</span>;</span><br></pre></td></tr></table></figure></p>
<p>写到这里，这个UITextField在界面上的要求就已经基本完成了，一般我们用到的常用属性也就是这些。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/30/UITextField设置leftView、圆角以及文字距离/" data-id="cjptr3x4c0017lyz9c7uhdsne" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UITextField/">UITextField</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-数据结构——队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/26/数据结构——队列/" class="article-date">
  <time datetime="2016-03-26T14:37:41.000Z" itemprop="datePublished">2016-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/26/数据结构——队列/">数据结构——队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>我们在使用手机的时候，偶尔都会碰到过卡住的时候，比如一个地方怎么点都没有用，屏幕也卡住不显示其他东西，但当你把卡住的App关闭掉之后，手机的操作显示就又恢复正常了，其实这就是因为操作系统中的各个程序的指令堆积在一起排队执行，而某一个App卡住的时候，大家都卡住了。</p>
<p>操作系统中是应用了一种数据结构来实现刚才提到的先到先执行的排队功能，这就是队列。</p>
<p>&lt;!--more--&gt;</p>
<h3>队列的定义</h3>
<blockquote>
<p>队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
</blockquote>
<p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端称为队头。假设队列 q = (q1,q2,q3,....qn)，那么我们一般定义q1就是队头，而qn自然为队尾了。这样我们在删除操作时，就从q1开始，而插入操作时则从qn开始。这也比较符合我们的生活习惯，我们在排队的时候，就是先到的人先出列，而晚到的人就在队尾排队。</p>
<h3>循环队列</h3>
<p>以前的文章，我写了线性表有顺序存储结构和链式存储结构，而同样，队列作为一种特殊的线性表，自然也存在这两种存储方式。首先我们先来看队列的顺序存储结构。</p>
<h4>队列顺序存储结构的不足</h4>
<p>和线性表的顺序存储结构的缺点一样，队列的若是采用常规的顺序存储结构，那么它在插入和删除时，每个元素都要依次向前或向后移动位置，此时的时间复杂度为O(n)。而当队列中队头之前的位置空出来，而队尾的元素已满时，明明在队头之前可能还有空间，但是按照顺序存储结构的判断，此时已经不能插入数据，再插入数据的话，整个数组就会溢出，而这种之前有空位，却插入到后面溢出位置的做法，我们称为 <strong>假溢出</strong> 。</p>
<h4>循环队列的定义</h4>
<p>所以为了解决这种假溢出的办法就是后面满了，就再从头开始，寻找之前空出来的空间，把数据存储进去，也就是头尾相接的循环。我们把队列这种头尾相接的顺序存储结构称为循环队列。</p>
<p>循环队列的顺序存储结构代码如下：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10   <span class="comment">//循环队列的最大存储空间</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  函数运行状态代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR   0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status ; <span class="comment">//函数的运行状态 假设为int类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType; <span class="comment">//QElemType的类型根据实际情况而定，这里假设为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义一个循环队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    QElemType data[MAXSIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> front; <span class="comment">//循环队列的头指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rear;  <span class="comment">//循环队列的尾指针</span></span><br><span class="line">    </span><br><span class="line">&#125;sqQueue;</span><br></pre></td></tr></table></figure></p>
<p>循环队列的初始化代码如下:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  初始化一个循环队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param Q 循环队列的线性表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return Status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span> <span class="params">(sqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来实现求一个循环队列的长度的功能，其实很简单，只要返回尾指针与头指针相减的数据就可以,当然，这里我们要考虑当循环了一遍之后头尾交换位置的情况</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  求循环队列的队列长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param Q 循环队列的线性表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span> <span class="params">(sqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front +MAXSIZE) %MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟线性表一样，我们一般要完成插入和删除功能的代码，而实现部分如下:</p>
<p>循环队列的入队列操作代码:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  循环队列的入队操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param Q 循环队列的线性表</span></span><br><span class="line"><span class="comment"> *  @param e 将要插入的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return Sataus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span> <span class="params">(sqQueue * Q ,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) %MAXSIZE == Q-&gt;front) &#123;    <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;              <span class="comment">//将元素e赋值给队尾</span></span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) %MAXSIZE;  <span class="comment">//将rear尾指针后移一位</span></span><br><span class="line">                                       <span class="comment">//若到队尾则转到数组头部</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环队列的出队列的操作代码 :</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  循环队列的出队列操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param Q 循环队列的线性表</span></span><br><span class="line"><span class="comment"> *  @param e 存储队头数据的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return Status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span> <span class="params">(sqQueue * Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;               <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];                  <span class="comment">//将队头元素赋值给e</span></span><br><span class="line">    Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) %MAXSIZE;      <span class="comment">//front指针后移一位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码，我们能够分析出，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但是循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下不需要担心队列长度的链式存储结构。</p>
<h3>队列的链式存储结构及实现</h3>
<p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了操作上的方便，我们将队列的头指针指向链队列的头结点，而尾指针指向终点结点。</p>
<p>空队列时，front和rear都指向头结点。</p>
<p>链队列的结构为:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  结点结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  队列的链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front, rear;    <span class="comment">//队头队尾指针</span></span><br><span class="line">    </span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></p>
<p>链队列的入队操作:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  插入元素e为链队列的新的队尾元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param Q 链队列</span></span><br><span class="line"><span class="comment"> *  @param e 将要插入的元素e</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return Status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">EnLinkQueue</span> <span class="params">(LinkQueue * Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;                    <span class="comment">//存储分配失败</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = s;      <span class="comment">//把拥有元素e的新节点s赋值给原队尾结点的后继</span></span><br><span class="line">    </span><br><span class="line">    Q-&gt;rear = s;            <span class="comment">//把当前的s设置为队尾的结点，rear指向s</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>链队列的出队操作，其实就是头结点的后继结点出队，将头结点的后继改成它后面的结点，之后再释放要删除元素的内存，若链表除了头结点之外只剩下一个元素时，则要将rear指向头结点。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  若队列不空，删除链队列的队头元素，并用e返回其值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param Q 链队列</span></span><br><span class="line"><span class="comment"> *  @param e 删除的元素的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return Status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">DeLinkeQueue</span> <span class="params">(LinkQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = Q-&gt;front-&gt;next;             <span class="comment">//将欲删除的队头结点暂存给p</span></span><br><span class="line">    *e = p-&gt;data;                   <span class="comment">//将欲删除的队头结点赋值给e</span></span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;       <span class="comment">//将原队头的结点后继p-&gt;next赋值给队头结点的后继</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p) &#123;             <span class="comment">//若队头是队尾，则删除后继后将rear指向头结点</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放p</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>循环队列和链队列的比较</h3>
<p>循环队列和链队列的比较可以从两个方面来比较，首先从时间上，其实它们的基本操作都是常数时间，时间复杂度都为O(1)，不过循环队列是事先申请好空间的，而链队列是即时申请空间的所以链队列的每次申请和释放操作都会带来一定的性能消耗和时间开销。</p>
<p>从空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间的浪费的问题，而链队列则不存在这个问题。</p>
<p>总得来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p>
<h3>总结</h3>
<p>我们在这里的总结，将栈和队列拿来比较。</p>
<ul>
<li>栈（stack）是限定进在表尾进行插入和删除操作的线性表</li>
<li>队列（Queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</li>
</ul>
<p>他们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端，因此它们各自有各自的技巧来解决这个问题。</p>
<p>对于栈来说，如果存储的数据类型相同的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化的利用数组的空间。</p>
<p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除的时间复杂度从O(n)变成了O(1)。</p>
<p>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/26/数据结构——队列/" data-id="cjptr3x9000eplyz9j9bz90ul" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/栈/">栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线性表/">线性表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/队列/">队列</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Objective-C开发编码规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/25/Objective-C开发编码规范/" class="article-date">
  <time datetime="2016-03-25T09:16:30.000Z" itemprop="datePublished">2016-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/25/Objective-C开发编码规范/">Objective-C开发编码规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>其实大多数的时间，我们写出来的代码并不仅仅是给自己看的，在协同开发中还有很多人会来Review你的代码，因此，为了不让别人吐槽自己的代码，必须要养成良好的习惯，让自己去学习一些非常好的编码风格，因此这里来罗列一下Objectiv-C常用的编码规范。</p>
<p>&lt;!--more--&gt;</p>
<p>【1】命名规则</p>
<ul>
<li>仿照Cocoa的风格来，使用长命名风格</li>
<li>变量命名推荐的命名语素顺序是：最开头的是命名空间的简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围 + 限定修饰 + 类型。</li>
</ul>
<p>【2】 在每个方法的定义前留白一行，也就是在方法与方法之间留空一行。</p>
<p>【3】 功能相近的方法要放在一起，比如一些协议的方法，这里推荐用 #pragma mark - *** 的格式来导航代码，切分代码块。这样可以方便方法的查找，并且可以用快捷键control + 6来快速查找方法的位置。</p>
<p>【4】 在用property定义变量时，建议写全所有参数，尤其是如果想定义成只读的（那么一定要加上readonly），这也是代码安全性的一个习惯。在定义变量名时，使*号靠着变量名，不要留空格。例如：</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *myString;</span><br></pre></td></tr></table></figure></p>
<p>【5】 定义长的变量值应该拆分成多行。尤其体现在使用数组或字典。以下也分别是快速声明数组@[] 和 字典@{}的方法。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"Lin"</span>,</span><br><span class="line">                      <span class="string">@"Hong"</span>,</span><br><span class="line">                      <span class="string">@"is"</span>,</span><br><span class="line">                      <span class="string">@"my"</span>,</span><br><span class="line">                      <span class="string">@"sweet"</span></span><br><span class="line">                      ];</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">NSDictionary</span> *dic = @&#123;</span><br><span class="line">                         <span class="string">@"name"</span>:<span class="string">@"LinH"</span>,</span><br><span class="line">                         <span class="string">@"height"</span>:<span class="string">@"168cm"</span>,</span><br><span class="line">                         <span class="string">@"weight"</span>:<span class="string">@"secret"</span>,</span><br><span class="line">                         <span class="string">@"lover"</span>:<span class="string">@"Lix"</span></span><br><span class="line">                         &#125;;</span><br></pre></td></tr></table></figure></p>
<p>【6】 二元运算符和参数之间要留一个空格，如赋值号=左右两边各留一个空格。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.myString = <span class="string">@"Lin,i love u"</span>;</span><br></pre></td></tr></table></figure></p>
<p>【7】 一元运算符和参数之间不放置空格，比如 ！非运算符，&amp;按位运与，|按位或。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> isOpen = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">BOOL</span> isClose = !isOpen;</span><br></pre></td></tr></table></figure></p>
<p>【8】 强制类型转换和参数之间不放置空格。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str3 = (<span class="built_in">NSString</span>*)<span class="keyword">self</span>.myString;</span><br></pre></td></tr></table></figure></p>
<p>【9】 尽量使用有意义的名字命名，拒绝使用i，j等无意义字符命名。命名时采用驼峰命名法，类的首字母大写，使用大驼峰命名，变量的首字母小写，使用小驼峰命名。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSManagedObjectContext</span>  <span class="comment">//类 (大驼峰)</span></span><br><span class="line">managedObjectContext    <span class="comment">//变量（小驼峰）</span></span><br></pre></td></tr></table></figure></p>
<p>【10】 尽量减少在代码中直接使用数字常亮，而使用宏定义等方式。如MAX_NUMBER_PHONE代替8等等。这样我们搜索和后期的修改维护代码也比较方便。</p>
<p>【11】 尽量减少代码中的重复使用，比如代码中多处要使用屏幕宽度，然后计算[UIScreen mainScreen].bounds.size.width很多次，很繁琐，代码也很长，不如直接宏定义。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width</span></span><br></pre></td></tr></table></figure></p>
<p>【12】 合理使用约定俗成的缩略词：</p>
<ul>
<li>alloc:分配；</li>
<li>alt:轮流，交替；</li>
<li>app:应用程序;</li>
<li>calc:计算;</li>
<li>dealloc:销毁；</li>
<li>func:函数、方法;</li>
<li>horiz:水平的;</li>
<li>info:信息;</li>
<li>init:初始化;</li>
<li>max:最大的;</li>
<li>min:最小的;</li>
<li>msg:消息;</li>
<li>nib:Interface Builder;</li>
<li>rect:矩形;</li>
<li>temp:暂时的;</li>
<li>vert:垂直的;</li>
</ul>
<p>【13】 函数长度不要超过50行，小函数比大函数的可读性更强。函数的参数不宜过多，零元函数最好，一元函数也不错，高于三元的函数需重构。</p>
<p>【14】 合理范围内使用链式编程</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *myView = [[<span class="built_in">UIView</span> alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>但是嵌套不宜超过3层，超过3层需进行重构。</p>
<p>【15】 函数调用时所有参数在同一行。如果参数过多，则可以每行一个参数，每个参数以冒号对齐。</p>
<p>【16】 对传入参数的保护或者说是否为空的判断，尽量不要使用if(!obj),而使用NSAssert断言来处理。NSAssert是系统定义的宏。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAssert</span>(myView != <span class="literal">nil</span>, <span class="string">@"myView参数为空"</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果条件判断为真，则程序继续执行</li>
<li>如果判断条件为假，则抛出异常，异常内容为后面定义的字符串</li>
</ul>
<p>【17】 if-else超过四层的时候，就要考虑重构，多层的if-else结构很难维护。</p>
<p>【18】 当需要一定条件才执行某项操作时，最左边的应该是最重要的代码，不要将最重要的代码内嵌到if中。如良好的风格是:</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) someMethod &#123;  </span><br><span class="line"><span class="keyword">if</span>(![someOther boolValue]) &#123;  </span><br><span class="line">   <span class="keyword">return</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//最重要的代码写在这里；  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反面教材:</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) someMethod &#123;  </span><br><span class="line"><span class="keyword">if</span>([someOther boolValue]) &#123;   </span><br><span class="line">     <span class="comment">//重要代码；  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【19】 所有的逻辑块都使用{}花括号包围，就算只是一行代码。在写方法或者函数时，把花括号的开头放在跟方法名的同一行。</p>
<p>【20】 明确指定构造函数，并有适当的注释。</p>
<p>【21】 不要在init方法中把变量或者说属性初始化为0或者nil，因为没有必要。</p>
<p>【22】 UIView的子类化初始化的时候，不要进行任何的布局操作。布局操作应该在layoutSubviews里面做；需要重新布局的时候调用setNeedsLayout，而不要直接调用layoutSubviews。</p>
<p>【23】 保持公共API简单，也就是保持.h文件简单。放在.h中声明的函数都是会被公开的，如果根本就没必要对其他类公开，再不要在.h中声明。OC中的方法都是共有方法，没有私有方法一说。</p>
<p>【24】 一个文件只实现一个类，同一个文件中不要有多个类。</p>
<p>【25】 布局时尽量使用相对布局，比如使用子View在父View中的相对位置。</p>
<p>【26】 protocol单独用一个文件来创建，尽量不要与相关类混在一个文件中。</p>
<p>【27】 在类定义中使用到自己定义类的时候，尽量不要在头文件中引入自己定义类的头文件，使用@class替代。而在实现文件中引入头文件。</p>
<p>【28】 推荐方法的第一个花括号直接跟在方法体后，而不是另起一行，这样可以减少代码行。</p>
<p>【29】 <code>block</code>中第一行也要留空，同方法体中的第一行留空。使代码清晰。</p>
<p>【30】 代表类方法和实例方法的&quot;+&quot;加号，&quot;-&quot;减号后需要一个空格。这是一个非常小的细节，系统默认的方法都是这样的，我们自己声明或者实现一个方法的时候也需要这样。</p>
<p>【31】 不要用点语法来调用方法，只用来访问属性。这样是为了防止代码可读性问题。</p>
<p>【32】 一个类的<strong>Delegate</strong>对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的Delegate属性要设置为弱引用。</p>
<p>【33】 好的代码应该是&quot;自解释的&quot;，但仍然需要详细的注释来说明参数的意义、返回值、功能以及可能的副作用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/25/Objective-C开发编码规范/" data-id="cjptr3x40000nlyz9poothkvf" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C编码规范/">Objective-C编码规范</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码规范/">编码规范</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-初窥Masonry" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/24/初窥Masonry/" class="article-date">
  <time datetime="2016-03-24T10:01:23.000Z" itemprop="datePublished">2016-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/24/初窥Masonry/">初窥Masonry</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在早期，iPhone尺寸比较固定，都是4英寸屏幕的时候，在计算App的尺寸时，只要稍微根据Window的size稍微计算一下就可以了，但是前年iPhone6以及iPhone6Plus的推出，作为开发者就会警觉为了多机型的适配，使用AutoLayout是势在必行的一件事情了，但是说实话，我在用了AutoLayout之后真的觉得挺不方便的。</p>
<p>一直以来可能是一个coder的矫情情怀，我喜欢用纯代码来搭建界面，因为那样思路清晰，而且日后维护的时候也能很清楚的知道问题究竟出在哪里。于是，一个第三方框架Masonry就自然而然的进入了视线，Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法来封装自动布局，简洁明了，具有高的可读性。</p>
<p>于是我今天就从Masonry最简单的demo入手，来学习Masonry的使用。&lt;!--more--&gt;</p>
<h3>居中显示一个View</h3>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:view];</span><br><span class="line">    </span><br><span class="line">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.center.equalTo(<span class="keyword">self</span>);</span><br><span class="line">        make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">300</span> , <span class="number">300</span>));</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>运行结果:</p>
<p><img src="https://raw.githubusercontent.com/originalix/MasonryDemo/master/basic.png" alt="居中显示View"></p>
<p>我们可以看到View已经按我们的要求设置成了预期大小，并且居中，那么我们回过头来看看代码。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//因为Masonry有设置尺寸的功能，以后基本能抛弃initWithFrame方法了</span></span><br><span class="line"> <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是个重点，要记得设置autoLayout之前一定要把view添加到父视图上，不然会报错</span></span><br><span class="line">    [<span class="keyword">self</span> addSubview:view];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//mas_makConstraints就是Masnory的添加AutoLayout函数了 把内容加入到中间的block块中就好了</span></span><br><span class="line">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将View居中到父视图上 很好理解吧</span></span><br><span class="line">        make.center.equalTo(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将size设置成300*300</span></span><br><span class="line">        make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">300</span> , <span class="number">300</span>));</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>看完上面的这段注释后的代码，一定觉得很简单对不对。</p>
<p>这里要注意的一点就是Masonry中能够添加AutoLayout的一共有三个函数。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="keyword">void</span>(^(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span>*) mas_remakeConstraints(<span class="keyword">void</span>(^(MASConstraintMaker *make))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束  三种函数善加利用 就可以应对各种情况了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h3>让一个View略小于SuperView</h3>
<p>这里我们假定让一个View小于它的SuperView每个边界的距离都是10，那么代码可以这么写</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.edges.equalTo(<span class="keyword">self</span>).with.insets(<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>).with.offset(<span class="number">10</span>);</span><br><span class="line">        make.left.equalTo(<span class="keyword">self</span>).with.offset(<span class="number">10</span>);</span><br><span class="line">        make.right.equalTo(<span class="keyword">self</span>).with.offset(<span class="number">-10</span>);</span><br><span class="line">        make.bottom.equalTo(<span class="keyword">self</span>).with.offset(<span class="number">-10</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//也等价于</span></span><br><span class="line">        make.top.left.bottom.and.right.equalTo(<span class="keyword">self</span>).with.insets(<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>上面的例子给出了三种实现方式，他们能实现的效果是相同的。我个人的意见是使用第一种，毕竟一句话能完成的代码何必用四句话呢。</p>
<p>那么为什么bottom和right里的offset是负数呢？因为这里的计算是绝对的数值，计算bottom需要小于superView的高度，所以要-10，同理用于right。</p>
<h3>让两个高度为150的view垂直居中且等宽等间隔排列 间隔为10（自动计算其宽度）</h3>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">int</span> padding1 = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    </span><br><span class="line">    view1.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addSubview:view1];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> * view2 = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    view2.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:view2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//让两个高度为150的View垂直居中且等宽且等间隔排列 间隔为10（自动计算其宽度）</span></span><br><span class="line">    [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerY.mas_equalTo(<span class="keyword">self</span>.mas_centerY);</span><br><span class="line">        make.left.equalTo(<span class="keyword">self</span>.mas_left).with.offset(padding1);</span><br><span class="line">        make.right.equalTo(view2.mas_left).with.offset(-padding1);</span><br><span class="line">        make.height.mas_equalTo(@<span class="number">150</span>);</span><br><span class="line">        make.width.equalTo(view2);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerY.mas_equalTo(<span class="keyword">self</span>.mas_centerY);</span><br><span class="line">        make.left.equalTo(view1.mas_right).with.offset(padding1);</span><br><span class="line">        make.right.equalTo(<span class="keyword">self</span>.mas_right).with.offset(-padding1);</span><br><span class="line">        make.height.mas_equalTo(@<span class="number">150</span>);</span><br><span class="line">        make.width.equalTo(view1);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>效果如图:</p>
<p><img src="https://raw.githubusercontent.com/originalix/MasonryDemo/master/padding.png" alt="两个View等间隔排列"></p>
<p>这里我们在两个子View之间相互约束，可以看到他们的宽度在约束下被计算出来。</p>
<h3>在UIScrollView顺序排列一些View并自动计算contentSize</h3>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在UIScrollView顺序排列一些View并自动计算contentSize</span></span><br><span class="line">    <span class="built_in">UIScrollView</span> *scrollView = [[<span class="built_in">UIScrollView</span> alloc]init];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:scrollView];</span><br><span class="line">    [scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.edges.equalTo(<span class="keyword">self</span>).with.insets(<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *container = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    [scrollView addSubview:container];</span><br><span class="line">    </span><br><span class="line">    [container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.edges.equalTo(scrollView);</span><br><span class="line">        make.width.equalTo(scrollView);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *lastView = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; ++i) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *subView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">        [container addSubview:subView];</span><br><span class="line">        subView.backgroundColor = [<span class="built_in">UIColor</span> colorWithHue:(arc4random()%<span class="number">256</span> / <span class="number">256.0</span>)</span><br><span class="line">                                             saturation:(arc4random()%<span class="number">128</span> / <span class="number">256.0</span>) + <span class="number">0.5</span></span><br><span class="line">                                             brightness:(arc4random()%<span class="number">128</span> / <span class="number">256.0</span>) + <span class="number">0.5</span></span><br><span class="line">                                                  alpha:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        [subView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.left.and.right.equalTo(container);</span><br><span class="line">            make.height.mas_equalTo(@(<span class="number">20</span>*i));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (lastView) &#123;</span><br><span class="line">                make.top.mas_equalTo(lastView.mas_bottom);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                make.top.mas_equalTo(container.mas_top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        lastView = subView;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.bottom.equalTo(lastView.mas_bottom);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>效果图:</p>
<p><img src="https://raw.githubusercontent.com/originalix/MasonryDemo/master/ScrollView1.png" alt="ScrollView1"></p>
<p><img src="https://raw.githubusercontent.com/originalix/MasonryDemo/master/ScrollView2.png" alt="ScrollView2"></p>
<p>从scrollView的scrollIndicator可以看出 scrollView的内部已如我们所想排列好了</p>
<p>这里的关键就在于container这个view起到了一个中间层的作用 能够自动的计算UIScrollView的contentSize</p>
<h3>横向或者纵向排列等间隙的一组view</h3>
<p>Masonry并没有向我们提供这样的方法，所以为了等间隙的排列，我们首先对UIView类扩展一个类目</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">Masonry_Lix</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)distributeSpacingHorizontallyWith:(<span class="built_in">NSArray</span> *)views</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *spaces = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:views.count+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; views.count+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">        [spaces addObject:view];</span><br><span class="line">        [<span class="keyword">self</span> addSubview:view];</span><br><span class="line">        </span><br><span class="line">        [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.width.equalTo(view.mas_height);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> * view0 = spaces[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    [view0 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.equalTo(<span class="keyword">self</span>.mas_left);</span><br><span class="line">        make.centerY.equalTo(((<span class="built_in">UIView</span>*)views[<span class="number">0</span>]).mas_centerY);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *lastSpace = view0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; views.count; i++) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *obj = views[i];</span><br><span class="line">        <span class="built_in">UIView</span> *space = spaces[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.left.equalTo(lastSpace.mas_right);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [space mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.left.equalTo(obj.mas_right);</span><br><span class="line">            make.centerY.equalTo(obj.mas_centerY);</span><br><span class="line">            make.width.equalTo(view0);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        lastSpace = space;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.right.equalTo(<span class="keyword">self</span>.mas_right);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)distributeSpacingVerticallyWith:(<span class="built_in">NSArray</span> *)views</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *spaces = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:views.count+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; views.count+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> * view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">        [spaces addObject:view];</span><br><span class="line">        [<span class="keyword">self</span> addSubview:view];</span><br><span class="line">        </span><br><span class="line">        [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.width.equalTo(view.mas_height);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *view0 = spaces[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    [view0 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.mas_top);</span><br><span class="line">        make.centerX.equalTo(((<span class="built_in">UIView</span> *)views[<span class="number">0</span>]).mas_centerX);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *lastSpace = view0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; views.count; i++) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *obj = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">        <span class="built_in">UIView</span> *space = spaces[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.top.equalTo(lastSpace.mas_bottom);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [space mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.top.equalTo(obj.mas_bottom);</span><br><span class="line">            make.centerX.equalTo(obj.mas_centerX);</span><br><span class="line">            make.height.equalTo(view0);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        lastSpace = space;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.bottom.equalTo(<span class="keyword">self</span>.mas_bottom);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>category写好之后 我们来随便写几个view测试一下</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIView</span> *sv1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *sv2 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *sv3 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *sv14 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *sv15 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    sv1.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    sv2.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    sv3.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    sv14.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    sv15.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addSubview:sv1];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:sv2];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:sv3];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:sv14];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:sv15];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给予每个视图不同大小 测试效果</span></span><br><span class="line">    </span><br><span class="line">    [sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerY.equalTo(@[sv2,sv3]);</span><br><span class="line">        make.centerX.equalTo(@[sv14,sv15]);</span><br><span class="line">        make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">40</span>, <span class="number">40</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [sv2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">70</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [sv3 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [sv14 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [sv15 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">40</span>, <span class="number">70</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> distributeSpacingHorizontallyWith:@[sv1,sv2,sv3]];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> distributeSpacingVerticallyWith:@[sv1,sv14,sv15]];</span><br></pre></td></tr></table></figure></p>
<p>效果图：</p>
<p><img src="https://raw.githubusercontent.com/originalix/MasonryDemo/master/spaceView.png" alt="view等间隙排列"></p>
<p>在这个效果图上我们已经能看到我们写的view按照我们设定的水平或者垂直方向排列了，所以这个类目也可以保留下来以后使用。</p>
<h3>小结</h3>
<p>通过上面5个demo的学习，我感觉已经把masonry常用的操作搞清楚了，如果你觉得还不清楚 也可以<a href="https://github.com/originalix/MasonryDemo" target="_blank" rel="noopener">在这里下载</a> Demo来学习。</p>
<p>总而言之Masonry是一个非常优秀的AutoLayout库，能够节省大量的开发时间，适合我这种喜欢纯代码的iOSer。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/24/初窥Masonry/" data-id="cjptr3x8u00eflyz9wu5ev1hv" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AutoLayout/">AutoLayout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Masonry/">Masonry</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动布局/">自动布局</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-蔺老师烧脑系列（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/蔺老师烧脑系列（一）/" class="article-date">
  <time datetime="2016-03-21T09:37:10.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/蔺老师烧脑系列（一）/">蔺老师烧脑系列（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在一个月之前，蔺老师给我出了一道题目，据说是可以吹一年的题目，所以我当时压根就没觉得我这么蠢的人能答得出来蔺老师给我出的题目，也就一直没回答，拖了将近一个月，才终于被老师想起来。先把题目放出来，具体的题目是这样的：</p>
<p>&lt;!--more--&gt;</p>
<p><img src="https://raw.githubusercontent.com/originalix/ListSequentialDemo/master/IMG_4525.JPG" alt="图1"></p>
<p><img src="https://raw.githubusercontent.com/originalix/ListSequentialDemo/master/IMG_4526.JPG" alt="图2"></p>
<p><img src="https://raw.githubusercontent.com/originalix/ListSequentialDemo/master/IMG_4527.JPG" alt="图3"></p>
<p>我来大致整理一下图片内的题目内容：外星人侵略地球，要毁灭地球，抓走了10个地球人，告诉这10个地球人，你们每个人代表6亿地球人，你们每个人头顶上戴着一顶帽子。有的人是红色，有的人时绿色，你们站成一列，每个人可以看到排在他前面所有人的颜色，但是不能提醒，如果你回答对了你自己头顶帽子的颜色，你就拯救了6亿人，如果错了，你和那6亿人都得死（蔺老师果然脑洞大，一死死6亿，任重而道远，宝宝当天智商直接吓瘫痪，难怪回答不出来）。外星人给这10个人一晚上的商量时间，第二天就要回答这个问题，问最多有几个人活下来，要采取怎样的回答方式，才能让更多人活下来。</p>
<p>还是得感叹下蔺老师的脑洞够大，然后感谢我在昨天完整的看完了线性表的顺序结构，分析得出，这10个人刚好构成一个线性表，而第十个人的回答刚好是1/2的概率，但是第十个人必须要做出贡献，让我们假定他们商量好第十个人提供的答案，就是前面9个人中颜色为基数的颜色。那么第九个人在回答时，只需要判断他之前的8个人头顶颜色的数量就可以回答出自己的。而之前的人，只需要牢牢记住后面的回答，并把后面的答案带入自己观察前面的人的颜色的数量中即可。最后10个人里能活下来9个人，人品好的话，第十个人也是能够侥幸活下来的。由此可见，蔺老师虽然脑洞大，但是心地还是善良的，一死死60亿，活该找不到男朋友。</p>
<p>从线性表的性质来分析，这10个人排成一列正好构成线性表的基本结构，有最大的存储容量为10，数据元素是每一个人，或者说每顶帽子是一个数据元素，每个人的前后都对应一个数据元素，且位置不做改变。</p>
<p>所以我就尝试是否能用算法来实现这个线性表。</p>
<p>首先因为我使用的是Objective-C语言，所以我可以直接用一个一维数组来定义这张线性表，不需要像昨天的C语言一样来定义。</p>
<p>即：</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  定义一个数组，里面有十个对象，类比为十个人，R代表该对象头上戴着red帽子，G代表该对象头上戴着Green帽子，颜色随机。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSArray</span> * array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"R"</span>,<span class="string">@"G"</span>,<span class="string">@"R"</span>,<span class="string">@"R"</span>,<span class="string">@"G"</span>,<span class="string">@"R"</span>,<span class="string">@"R"</span>,<span class="string">@"G"</span>,<span class="string">@"G"</span>,<span class="string">@"R"</span>,<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<p>这里我们就不直接定义人了，直接用帽子来表示数据元素，里面的帽子颜色也是我随机输入的，没有什么规律性。R为红色的帽子red，G为绿色的帽子green。</p>
<p>接下来我们遍历这个线性表，并定义两个  <strong>NSInteger</strong>  的数据类型来充当计数器，分别为r和g，r统计红帽子的数量，g统计绿帽子的数量。这里我们就假设我们就是第十个人，站在队列的最后面，统计帽子颜色数量。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSInteger</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> g = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([array[i] isEqualToString:<span class="string">@"R"</span>]) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([array[i]isEqualToString:<span class="string">@"G"</span>])&#123;</span><br><span class="line">            g++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们判断之前的九个数据元素中，帽子的颜色的奇偶性，最后系统输出的结构为，第10个人回答帽子的颜色是红色的。这项输出也是正确的，因为我们虚构的线性表中前九个数据元素，有5个红帽子，4个绿帽子。而第10个人又碰巧被我定义成了红帽子，很幸运的第10个人也活了下来。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define Green NSLog(@&quot;第10个人的帽子是绿色的&quot;)</span><br><span class="line">#define Red   NSLog(@&quot;第10个人的帽子是红色的&quot;)</span><br><span class="line">    g % 2 == 0 ? Red : Green;    //这是第十个人的回答</span><br></pre></td></tr></table></figure></p>
<p>接下来我们来看这道题目的核心算法部分，即在输出了第十个人的回答之后，怎么让前9个人依次判断他们的帽子，我的想法是定义两对计数器，分别为beforeG和beforeR，用来记录之前还剩余的红帽子数和绿帽子数。另一组是deleteG和deleteR，用来记录已经退出队列的红帽子数和绿帽子数。</p>
<p>用一个嵌套循环，来完整的遍历数组。讲简单一点，里面的for循环，可以理解为当前这个人，在轮到他回答问题时，他对排在他之前的人认真的数了帽子的个数，毕竟一次死6亿，蔺老师玩的有点大。而外层的循环，可以理解为，每个人依次回答问题，第九个回答完，会轮到第八个回答，以此类推。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">//定义deleteR和deleteG分别为排除掉的人的帽子数量 R为红色 G为绿色</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> deleteR = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> deleteG = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  n为在第九个人之前的八个人，因为第十个人已经回答完，从第九个人开始观察之前的8个人。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">8</span>; n &gt;= <span class="number">0</span> ; n--) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计数器，记录排在前面的人的红帽子和绿帽子的数量</span></span><br><span class="line">        <span class="built_in">NSInteger</span> beforeR = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">NSInteger</span> beforeG = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每一个人在回答前，都统计遍历一遍自己之前的数据，完成计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([array[i] isEqualToString:<span class="string">@"R"</span>]) &#123;</span><br><span class="line">                beforeR++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([array[i]isEqualToString:<span class="string">@"G"</span>])&#123;</span><br><span class="line">                beforeG++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断自己到底是什么颜色的帽子 条件很简单 就是判断奇偶性</span></span><br><span class="line">        <span class="keyword">if</span> ( (beforeG + deleteG) % <span class="number">2</span> != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"第%d个人的帽子是绿色的"</span>,n+<span class="number">1</span>);</span><br><span class="line">            ++deleteG;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((beforeR + deleteR) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"第%d个人的帽子是红色的"</span>,n+<span class="number">1</span>);</span><br><span class="line">            ++deleteR;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后让我们来运行这段代码，看看运行结果</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.229</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">10</span>个人的帽子是红色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.230</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">9</span>个人的帽子是绿色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.230</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">8</span>个人的帽子是绿色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.230</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">7</span>个人的帽子是红色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.231</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">6</span>个人的帽子是红色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.231</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">5</span>个人的帽子是绿色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.231</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">4</span>个人的帽子是红色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.231</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">3</span>个人的帽子是红色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.232</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">2</span>个人的帽子是绿色的</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">45.232</span> 外星人入侵地球[<span class="number">21432</span>:<span class="number">3513416</span>] 第<span class="number">1</span>个人的帽子是红色的</span><br></pre></td></tr></table></figure></p>
<p>我们可以把这里的红绿对照之前一位数组中的R和G来看，输出结果完全正确。当然这并不是最优算法，按照这个方法写的算法，时间复杂度为O(n2)，是一个平方阶的复杂度，所以有更优化的方案还会继续更新。 代码上传到了Github上，有需要的可以下载。</p>
<p><a href="https://github.com/originalix/-" target="_blank" rel="noopener">蔺老师烧脑系列（一）Demo</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/21/蔺老师烧脑系列（一）/" data-id="cjptr3x6n0056lyz9katagrcq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线性表/">线性表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/蔺老师烧脑系列/">蔺老师烧脑系列</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-线性表的顺序存储结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/线性表的顺序存储结构/" class="article-date">
  <time datetime="2016-03-20T17:25:08.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/线性表的顺序存储结构/">线性表的顺序存储结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3>顺序存储定义</h3>
<p>今天来总结一下线性表的顺序存储结构。首先来看下顺序存储结构的定义。</p>
<blockquote>
<p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
</blockquote>
<p>举个简单的例子，蔺老师在给九班学生安排座位之前，会让学生们从矮到高按照身高的高矮升序排列，假如蔺老师的班上只有十个学生，而全班共有50个座位，那蔺老师会把这10个学生，连续的安排在教室的前两排之内，每个人都有自己的同桌，连续的10个座位，那么这10个学生所占用的就是一片连续的座位。相当于内存中有50个数据元素的空间，而10个学生只占用了中间的连续十个大小的空间。</p>
<p>&lt;!--more--&gt;</p>
<p>因为线性表中，存储的数据元素的类型都相同，而存储空间又是连续的，那么我们可以用一维数组来实现线性表的存储结构。</p>
<p>因为班上一共有50个座位，所以蔺老师在安排座位时，也没必要一定从第一个座位开始安排，可以从第二排或者第三排来安排座位，选定座位之后，学生一个挨一个的坐进去就可以了。所以选定线性表时，在内存中找一块地，于是这块地的第一个位置就非常关键，它为存储空间的起始位置。</p>
<p>每天放学回家，蔺老师会要求这10个学生排队走出校门，而并不是每个学生每天都会上学，比如彤彤这样的学生，每天放学要去等蔺老师下班，那么队伍里可能只有九个人，而这九个人还是排成了一列，谁在前谁在后关系依旧很明确，只是少了彤彤而已。而这个例子，就表示了线性表一一对应的特点，就像排队，在整队的时候随着每天的放学排队，大家很清楚自己该出现在哪个位置。</p>
<h3>顺序存储结构的代码</h3>
<p>我们来看线性表顺序存储结构的结构代码：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10          <span class="comment">//存储空间的初始化分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;    <span class="comment">//定义线性表元素数据类型 这里假设为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType data[MAXSIZE];      <span class="comment">//线性表存储数据元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length;                     <span class="comment">//线性表的长度</span></span><br><span class="line">    </span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure></p>
<p>这里我们能看到顺序存储结构所需要的三个属性：</p>
<ul>
<li>
<p>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置</p>
</li>
<li>
<p>线性表的最大容量，数组长度MAXSIZE</p>
</li>
<li>
<p>线性表的当前长度： length</p>
</li>
</ul>
<p>我们对每个线性表位置的存入或取出的数据，对于计算机来说都是相等的时间，也就是一个常数。因此用上一次讨论的算法时间复杂度的概念来说，线性表的时间复杂度为O(1)。我们通常把具有这一特点的存储结构称为随机存储结构。</p>
<h3>顺序存储结构的插入或删除</h3>
<p>在讨论顺序存储结构的实现方式之前，我们先来定义一下函数运行的状态代码，用来返回线性表运行的状态。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  函数运行的状态代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR   0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;  <span class="comment">//状态代码的类型</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码我们定义了Status为状态代码的类型，返回SUCCESS代表1，返回ERROR代表0。本文之后的所有状态代码就不再详述了。</p>
<h5>创建线性表（初始化）</h5>
<p>在上面我们已经定义好了线性表的属性，并确定了线性表的最大存储容量，那么我们在刚开始时，对线性表进行初始化，创建一个线性表。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 线性表的初始化 并分配存储单元</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> - returns: SqList*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SqList * <span class="title">initSqList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList * <span class="built_in">list</span> = (SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还是用C语言来操作，创建了一张线性表，用malloc分配存储空间，定义当前线性表长度为0，最后返回值为本张线性表。</p>
<h5>获得元素操作</h5>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取线性表中的元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span> <span class="params">(SqList * L , <span class="keyword">int</span> i , ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L-&gt;length ) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    e = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在获取元素的操作中呢，我们定义了一个e，用来返回L中第i个元素的值。</p>
<h5>插入操作</h5>
<p>在这里先不放代码，先来讨论一下线性表的插入概念。比如我在火车站排队等着取票，排了很久的队终于快轮到我了，这时候有一个很漂亮的姑娘过来，可怜兮兮的对我说：帅哥，我的车还有几分钟
就开了，能让我先取一下么。可能我会“以貌取人”，答应了这个漂亮姑娘的要求，于是这个姑娘排到了我的前面，可是我毕竟有女朋友，再加上男女授受不亲，我又不想回家跪键盘，于是我得往后退一步，让出一个空间给姑娘排在我前面，我后面的人也得跟着我的步伐往后退一步。这时候，就类似于线性表的插入算法的思路：</p>
<ul>
<li>
<p>如果插入的位置不合理，抛出异常</p>
</li>
<li>
<p>如果线性表的长度大于数组长度，抛出异常或者动态增加存储空间</p>
</li>
<li>
<p>从最后一个元素，向前遍历到第i个位置，分别将它们都向后移动一个位置。</p>
</li>
<li>
<p>将要插入的元素插入到位置i</p>
</li>
<li>
<p>表长+1</p>
</li>
</ul>
<p>代码的话，我用了两种方式，一种是线性表以栈的方式加入数据元素，即为每一次都加在队列的最后面，一种是按照要求，添加到指定的位置中。</p>
<p>栈的方式插入数据元素的实现代码：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表以栈的方式加入数据</span></span><br><span class="line"><span class="function">Status <span class="title">pushElement</span><span class="params">(ElementType e, SqList * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">list</span>-&gt;length;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span> || length &gt; MAXSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>-&gt;data[length] = e;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在指定位置插入数据元素的代码实现如下：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  在线性表中的第i个位置插入之前新的元素数据e，线性表的长度+1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">insertElementWithLocation</span><span class="params">(ElementType e, SqList * <span class="built_in">list</span>, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">//判断线性表的存储空间是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == MAXSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断i的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将要插入的位置后面的数据向后移动一位</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; k &gt;= i<span class="number">-1</span>; k--) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;data[k+i] = <span class="built_in">list</span>-&gt;data[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>-&gt;data[i<span class="number">-1</span>] = e;  <span class="comment">//插入新元素</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5>删除操作</h5>
<p>讲完了插入的概念以及实现，应该对删除操作的行为也有了理解，即为从指定位置，删除需要删除的元素。</p>
<p>所以删除算法的思路：</p>
<ul>
<li>
<p>如果删除位置不合理，抛出异常</p>
</li>
<li>
<p>取出删除元素</p>
</li>
<li>
<p>从删除元素开始，之后的元素至最后一个元素的存储位置向前挪动一个位置</p>
</li>
<li>
<p>表长-1</p>
</li>
</ul>
<p>我们同样用栈的删除模式和指定位置删除的模式来实现代码。</p>
<p>栈的方式删除元素，即为每次都删除最后一个元素的代码实现：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  按照栈的方式删除元素 e用来接收删除出来的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">popElement</span><span class="params">(ElementType e, SqList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">list</span>-&gt;length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断线性表的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span> || length &gt; MAXSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    e = <span class="built_in">list</span>-&gt;data[length - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;length -- ;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在指定位置删除元素的代码实现如下:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  在线性表中的第i个位置删除元素 线性表的长度减一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">deleteElementWithLocation</span><span class="params">(ElementType e, <span class="keyword">int</span> i , SqList * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断线性表的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length &lt; <span class="number">0</span> || <span class="built_in">list</span>-&gt;length &gt; MAXSIZE ) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断删除位置的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    e = <span class="built_in">list</span>-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="comment">//将删除位置的后继元素前移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; <span class="built_in">list</span>-&gt;length; k++) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;data[k<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;data[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>-&gt;length -- ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5>遍历线性表</h5>
<p>最后为了方便我们等下来验证代码的正确性，我们写一个函数来遍历线性表，代码如下：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  遍历线性表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">displayList</span><span class="params">(SqList * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length &lt; <span class="number">0</span> || <span class="built_in">list</span>-&gt;length &gt; MAXSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数值 = %d , 地址 = %p\n"</span>,<span class="built_in">list</span>-&gt;data[i], &amp;<span class="built_in">list</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***************************\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5>验证代码正确性</h5>
<p>在验证代码的正确性时，我用了Objective-C语言来写，大体思路如果是使用C语言的程序员，也是能完全看懂的。</p>
<p>我先创建了一个线性表，并且遍历它，打印地址来验证顺序结构存储空间的连续性。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">//把1-8按顺序入栈</span></span><br><span class="line">        SqList * <span class="built_in">list</span> = initSqList();</span><br><span class="line"></span><br><span class="line">        NSLog(@<span class="string">"把1-8按顺序入栈"</span>);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">8</span>  ; i++) &#123;</span><br><span class="line">            pushElement(j, <span class="built_in">list</span>);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        displayList(<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></p>
<p>因为存储空间总大小为10个元素单位，而我要求把1-8共8个数按顺序存入线性表中。打印结果如下：</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">数值 = <span class="number">1</span> , 地址 = <span class="number">0x1002014d0</span></span><br><span class="line">数值 = <span class="number">2</span> , 地址 = <span class="number">0x1002014d4</span></span><br><span class="line">数值 = <span class="number">3</span> , 地址 = <span class="number">0x1002014d8</span></span><br><span class="line">数值 = <span class="number">4</span> , 地址 = <span class="number">0x1002014dc</span></span><br><span class="line">数值 = <span class="number">6</span> , 地址 = <span class="number">0x1002014e0</span></span><br><span class="line">数值 = <span class="number">7</span> , 地址 = <span class="number">0x1002014e4</span></span><br><span class="line">数值 = <span class="number">8</span> , 地址 = <span class="number">0x1002014e8</span></span><br><span class="line">***************************</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，数值以及存储空间都是连续的，说明我们用栈的方式插入线性表是创建成功的。</p>
<p>我又要求往第八个位置插入724这个数字</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//往第8个位置插入724;</span></span><br><span class="line">        </span><br><span class="line">        insertElementWithLocation(<span class="number">724</span>, <span class="built_in">list</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下，可以清楚的看到第八位是724，而原先的元素后移一位。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第八位增加<span class="number">724</span></span><br><span class="line">***************************</span><br><span class="line">数值 = <span class="number">1</span> , 地址 = <span class="number">0x100101320</span></span><br><span class="line">数值 = <span class="number">2</span> , 地址 = <span class="number">0x100101324</span></span><br><span class="line">数值 = <span class="number">3</span> , 地址 = <span class="number">0x100101328</span></span><br><span class="line">数值 = <span class="number">4</span> , 地址 = <span class="number">0x10010132c</span></span><br><span class="line">数值 = <span class="number">5</span> , 地址 = <span class="number">0x100101330</span></span><br><span class="line">数值 = <span class="number">6</span> , 地址 = <span class="number">0x100101334</span></span><br><span class="line">数值 = <span class="number">7</span> , 地址 = <span class="number">0x100101338</span></span><br><span class="line">数值 = <span class="number">724</span> , 地址 = <span class="number">0x10010133c</span></span><br><span class="line">数值 = <span class="number">8</span> , 地址 = <span class="number">0x100101340</span></span><br><span class="line">***************************</span><br></pre></td></tr></table></figure></p>
<p>验证删除操作的时候，我们命令把第五位的数据删除（以原始数据为例）</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        把第五位的数据删除</span></span><br><span class="line">        deleteElementWithLocation(<span class="number">0</span>, <span class="number">5</span>, <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></p>
<p>得到结果如下:</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">删除第五位</span><br><span class="line">***************************</span><br><span class="line">数值 = <span class="number">1</span> , 地址 = <span class="number">0x1002014d0</span></span><br><span class="line">数值 = <span class="number">2</span> , 地址 = <span class="number">0x1002014d4</span></span><br><span class="line">数值 = <span class="number">3</span> , 地址 = <span class="number">0x1002014d8</span></span><br><span class="line">数值 = <span class="number">4</span> , 地址 = <span class="number">0x1002014dc</span></span><br><span class="line">数值 = <span class="number">6</span> , 地址 = <span class="number">0x1002014e0</span></span><br><span class="line">数值 = <span class="number">7</span> , 地址 = <span class="number">0x1002014e4</span></span><br><span class="line">数值 = <span class="number">8</span> , 地址 = <span class="number">0x1002014e8</span></span><br><span class="line">***************************</span><br></pre></td></tr></table></figure></p>
<p>至此，我们可以得出结论我们创建的线性表是正确的，连续的，具备线性表的属性的。而我们在对线性表的顺序存储结构的插入和删除的操作也是正确的，实现了功能。所以今天的线性表的顺序存储结构，就讲到这里，以上代码我已经上传到Github上，若有讲的不清楚的地方，也可以下载Github上的代码来参考。</p>
<p><a href="https://github.com/originalix/ListSequentialDemo" target="_blank" rel="noopener">线性表的顺序存储结构Demo</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/21/线性表的顺序存储结构/" data-id="cjptr3x9100erlyz9jd2cqiiv" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线性表/">线性表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线性表的顺序存储结构/">线性表的顺序存储结构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS设计模式之简单工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/18/iOS设计模式之简单工厂模式/" class="article-date">
  <time datetime="2016-03-18T09:20:37.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/iOS设计模式之简单工厂模式/">iOS设计模式之简单工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近在看关于设计模式的书籍，开始觉得在设计程序架构之时，能够灵活运用这些设计模式，代码将变得非常具有美感。一个好的设计模式使得程序更加的灵活，容易修改，易于使用。</p>
<p>从最简单的简单工厂模式开始学起，举一个实现计算器的例子，来完成简单工厂模式。</p>
<p>&lt;!--more--&gt;</p>
<h3>普通的简易计算器代码示例</h3>
<p>一个简单计算器，用四则运算来考虑的话，加减乘除，那么初学者会觉得很简单，用if条件来进行判断，判断好了之后就可以完成要求，而稍微有经验点的 可能会选择switch case的判断方式，例如下面的代码:</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Operation运算方法的逻辑</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)operationWithnumberA:(<span class="keyword">double</span> )numberA Withoperator:(<span class="keyword">char</span>)operator WithnumberB:(<span class="keyword">double</span> )numberB</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  封装了一个传递值的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param numberA  数字A</span></span><br><span class="line"><span class="comment"> *  @param operator 运算符</span></span><br><span class="line"><span class="comment"> *  @param numberB  数字B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        result = numberA + numberB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">            result = numberA - numberB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">            result = numberA * numberB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">            <span class="keyword">if</span> (numberB == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"除数不能为0 请重新输入"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result = numberA / numberB;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"退出"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>而客户端方面的代码 我们可以这么写</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  四则运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)operation</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> numberA;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请输入数字A"</span>);</span><br><span class="line">    scanf(<span class="string">"%lf"</span>,&amp;numberA);</span><br><span class="line">    <span class="keyword">double</span> numberB;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请输入数字B"</span>);</span><br><span class="line">    scanf(<span class="string">"%lf"</span>,&amp;numberB);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"加法请输入a"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"减法请输入b"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"乘法请输入c"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"除法请输入d"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"退出请输入e"</span>);</span><br><span class="line">    </span><br><span class="line">    scanf(<span class="string">"%c"</span>,&amp;a);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> operationWithnumberA:numberA Withoperator:a WithnumberB:numberB];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在我们得到需要的数值之后，调用运算方法做判断，算出结果。</p>
<p>这样写就会比if的判断清晰，因为我们已经把业务逻辑和界面显示的部分完全分离了，在任何需要用到的地方，我们就可以直接复制这段代码，完成运算。</p>
<p>但是假如，我有一天的运算需求不满足于四则运算，而是希望加上开根号或者平方的运算方法，该怎么办。难道我们还要回头，去switch语句里再加判断条件，之后在界面上增加提示么？</p>
<p>之前的代码，我们只用到了面向对象的三个特性之一，就是封装，而解决我上一段话提出的疑问，我们可以用到另外两个特性，多态和继承来实现。</p>
<h3>简单工厂模式的代码示例</h3>
<p>为了实现之前的要求，在不改动其他代码的情况下，能够增加更多的运算方法，或者修改出问题的运算方法。那么我们首先先把四则运算，封装成四个类，即为加法类、减法类、乘法类、除法类。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AddOperation</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   加法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">double</span>)addOperationWithNumberA:(<span class="keyword">double</span>)numberA WithNumberB:(<span class="keyword">double</span>)numberB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    result = numberA + numberB ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   减法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">double</span>)subOperationWithNumberA:(<span class="keyword">double</span>)numberA WithNumberB:(<span class="keyword">double</span>)numberB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    result = numberA - numberB ;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MulOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   乘法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">double</span>)mulOperationWithNumberA:(<span class="keyword">double</span>)numberA WithNumberB:(<span class="keyword">double</span>)numberB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    result = numberA * numberB ;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DivOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   除法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">double</span>)divOperationWithNumberA:(<span class="keyword">double</span>)numberA WithNumberB:(<span class="keyword">double</span>)numberB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numberB == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"除数不能为0 请重新输入"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = numberA / numberB;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就已经把四则运算，封装成了四个类。因为偷懒，我并没有设计界面模型，只是把结果输出来，所以每段输出结果的NSLog请不要介意。</p>
<p>接下来，我们在简单工厂的Operation类中，把调用这四个类的运算方法实现。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  封装了一个运算方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param numberA  数字A</span></span><br><span class="line"><span class="comment"> *  @param operator 运算符</span></span><br><span class="line"><span class="comment"> *  @param numberB  数字B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)operationWithnumberA:(<span class="keyword">double</span> )numberA Withoperator:(<span class="keyword">char</span>)operator WithnumberB:(<span class="keyword">double</span> )numberB</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            [AddOperation addOperationWithNumberA:numberA WithNumberB:numberB];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">            [SubOperation subOperationWithNumberA:numberA WithNumberB:numberB];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">            [MulOperation mulOperationWithNumberA:numberA WithNumberB:numberB];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">            [DivOperation divOperationWithNumberA:numberA WithNumberB:numberB];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"退出"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是在简单工厂的类中，调用四个运算方法的类，来实现运算，并且成功解耦合，有利于以后的维护和扩展。客户端方面的代码也就非常简单。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  四则运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)operation</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'a'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> numberA = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> numberB = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//    NSLog(@"加法请输入a");</span></span><br><span class="line"><span class="comment">//    NSLog(@"减法请输入b");</span></span><br><span class="line"><span class="comment">//    NSLog(@"乘法请输入c");</span></span><br><span class="line"><span class="comment">//    NSLog(@"除法请输入d");</span></span><br><span class="line"><span class="comment">//    NSLog(@"退出请输入e");</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [Operation operationWithnumberA:numberA Withoperator:a WithnumberB:numberB];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端的代码还是偷懒，没有设计UI部分，所以也直接把数据代入进去了，但是大体的思路就是这样。直接用面向对象的三大特性来解决问题，在设计代码时，一定要本着可维护、可复用、可扩展、灵活性好的设计思路来设计。尤其要注意，这里的可复用，可不是可复制哦。今天的学习笔记就写到这里。</p>
<p>简单工厂模式的Demo我已经上传到Github上，如果觉得对您有帮助，请自行下载。</p>
<p><a href="https://github.com/originalix/OperationFactoryDemo.git" target="_blank" rel="noopener">Operation Factory Demo</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/18/iOS设计模式之简单工厂模式/" data-id="cjptr3x5a0036lyz93rv9wj4o" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/简单工厂模式/">简单工厂模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-算法时间复杂度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/17/算法时间复杂度/" class="article-date">
  <time datetime="2016-03-16T18:05:13.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/17/算法时间复杂度/">算法时间复杂度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>很多程序员，做了很长时间的编程工作却始终都弄不明白算法的时间复杂度的估算，这是很可悲的一件事情。因为弄不清楚，所以也就从不深究自己写的代码是否效率底下，是不是可以通过优化，让计算机更加快速高效。所以在我最近自学看完算法的时间复杂度这个章节之后，我决定写一篇文章回顾，加深记忆，帮助理解。
  
&lt;!--More--&gt;</p>
<h3>算法设计的要求</h3>
<p>一个好的算法的设计要求，必须符合以下的几个特性：正确性，可读性，健壮性，时间效率高和存储量低这四个特性。其中算法的前三个特性毕竟容易理解，今天就着重的关于算法的时间效率这个性质来梳理一下。</p>
<p>时间效率高是指在对于同一个问题，有多个算法能够解决，执行时间短的算法效率更高，执行时间长的效率低。在生活中，人们都希望花最少的钱，最短的时间，办最大的事，算法也是一样的思想。例如求一个班级的物理平均分和求全省学生的中考物理平均分，用同样一套算法的确能够解决问题，但是在占用的时间和内存上的差距是非常大的，所以非常有必要去追求一套高效率，低存储空间的算法来解决问题。</p>
<h3>算法效率的度量方法</h3>
<p>一般我们分析一套算法的效率，有事后统计法和事前分析法，但是事后统计法显然是有很大缺陷的，首先它必须要我们先编写好一套程序，这通常需要花费很大的时间和精力。所以一般我们对一套算法的分析，需要事前分析。</p>
<p>于是我们能发现，一个用高级程序语言编写的程序，在计算机上运行时所消耗的时间取决于下列因素：</p>
<ul>
<li>算法采用的策略、方法</li>
<li>编译产生的代码质量</li>
<li>问题的输入规模</li>
<li>机器的执行指令的速度</li>
</ul>
<p>第1条当然是决定一个算法好坏的根本，而第2条由软件决定，第4条主要看硬件性能，也就是说，抛开与计算机软件、硬件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓的输入规模，就是指输入量的多少。</p>
<p>所以我们在分析算法问题时，最重要的就是把程序看成是独立于程序设计语言的算法或一系列的步骤。</p>
<h3>函数的渐近增长</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数的渐近增长：给定两个函数f(n)和g(n),</span><br><span class="line">如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大,</span><br><span class="line">那么我们就说f(n)的增长渐近快于g(n)。</span><br></pre></td></tr></table></figure></p>
<p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注的是主项（最高阶项）的阶数。</p>
<p>判断一个算法好不好，通过少量的数据是不能得出结论的。如果我们对比几个函数在关键执行次数的函数的渐近增长性，基本就可以分析出：某个算法，随着n的增大，它会越来越优于另一算法，或者原来越差于另一算法。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。</p>
<h3>算法时间复杂度</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，</span><br><span class="line">进而分析T(n)随着n的变化情况并确定T(n)的数量级。</span><br><span class="line">算法的时间复杂度，也就是算法的时间度量，记作：T(n)=O(f(n))。</span><br><span class="line">它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，</span><br><span class="line">称作算法的时间复杂度，简称为时间复杂度。</span><br><span class="line">其中f(n)是问题规模n的某个函数。</span><br></pre></td></tr></table></figure></p>
<p>这样用写大O()来体现的时间复杂度的记法，我们称之为大O记法。</p>
<p>显然由时间复杂度的定义可知，算法的时间复杂度分别为O(1),O(n),O(n²)，用非官方的名称来叫它们，O(1)常数阶，O(n)线性阶，O(n²)平方阶，当然还有一些其他的阶。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如O(1)常数阶</span></span><br><span class="line">sum = (<span class="number">1</span> + n) / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如O(n)线性阶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如O(n²)平方阶</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                       x++;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3>推导大O阶的方法</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">推导大O阶：</span><br><span class="line"></span><br><span class="line">1、用常数1取代运行时间中所有的加法常数。</span><br><span class="line">2、在修改后的运行次数函数中，只保留最高阶项。</span><br><span class="line">3、如果最高阶项存在且不是1，则去除与这个项相乘的常熟。</span><br><span class="line">得到的结果就是大O阶。</span><br></pre></td></tr></table></figure></p>
<p>其实理解大O阶推导并不难，难得是对数列的一些相关运算，这里更多的考察的是数学知识和能力，特别是数列方面的知识和解题能力。</p>
<h3>常见的时间复杂度</h3>
<table>
<thead>
<tr>
<th>执行次数函数</th>
<th>阶</th>
<th>非正式术语</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>O(1)</td>
<td>常数阶</td>
</tr>
<tr>
<td>2n+3</td>
<td>O(n)</td>
<td>线性阶</td>
</tr>
<tr>
<td>3n²+2n+1</td>
<td>O(n²)</td>
<td>平方阶</td>
</tr>
<tr>
<td>5log2n+20</td>
<td>O(logn)</td>
<td>对数阶</td>
</tr>
<tr>
<td>2n+3nlog2n+19</td>
<td>O(nlogn)</td>
<td>nlogn阶</td>
</tr>
<tr>
<td>6n³+2n²+3n+4</td>
<td>O(n³)</td>
<td>立方阶</td>
</tr>
<tr>
<td>2^n</td>
<td>O(2^n)</td>
<td>指数阶</td>
</tr>
</tbody>
</table>
<p>常用的时间复杂度所耗费的时间从小到大依次是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</span><br></pre></td></tr></table></figure></p>
<p>一般在没有特殊说明的情况下，我们分析的都是算法的在最坏状况下的时间复杂度。</p>
<p>通过分析算法的效率，能深刻感受到愚公的精神固然可敬，但是推土机和炸药可能是更加实在和聪明。</p>
<p>简单的算法时间复杂度的概念就先到这里结束了，以后看到新的知识再继续分享。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/17/算法时间复杂度/" data-id="cjptr3x6i0051lyz9h0q9bu08" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/推导大O阶/">推导大O阶</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法时间复杂度/">算法时间复杂度</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS单例设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/iOS单例设计模式/" class="article-date">
  <time datetime="2016-03-15T07:00:33.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/iOS单例设计模式/">iOS设计模式系列：单例设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>单例设计模式从字面意思上来说，就是一个类在系统运行时，只创建一个实例。可以用于需要被多次调用的或者多次使用的资源中。比如我们常见的网络请求类、工具类等等。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS中大量的使用了单例方法，常见的有：</span></span><br><span class="line">[<span class="built_in">NSUserDefaults</span> standardUserDefaults]  轻量级的本地数据存储，存储自定义的对象，比如保存登陆界面的数据、用户名、密码等。</span><br><span class="line"></span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication] 处理用户事件，main函数入口</span><br><span class="line"></span><br><span class="line">[<span class="built_in">UIScreen</span> mainScreen] 获取全屏幕尺寸</span><br></pre></td></tr></table></figure></p>
<p>&lt;!--more--&gt;</p>
<h3>单例模式的作用</h3>
<p>它可以保证某个类在运行过程中，只有一个实例，也就是对象实例只占用一份系统内存资源。</p>
<h3>单例的要点</h3>
<ul>
<li>
<p>该类有且只有一个实例</p>
</li>
<li>
<p>该类必须能自行创建这个实例</p>
</li>
<li>
<p>该类必须能够向整个系统提供这个实例</p>
</li>
</ul>
<h3>单例的优缺点</h3>
<p>优点：</p>
<ul>
<li>
<p>提供了唯一实例的受访对象</p>
</li>
<li>
<p>因为在系统中只存在一个实例，在频繁访问和调用时，节省了系统创建和销毁资源的开销，提高系统性能。</p>
</li>
<li>
<p>因为单例化的类，控制了实例化的过程，所以能更灵活修改实例化的过程。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>单例模式没有抽象层，不容易扩展。</p>
</li>
<li>
<p>单例模式往往职责过重，一定程度上违背了“单一职责原则”。</p>
</li>
</ul>
<h3>单例类的实现</h3>
<ul>
<li>
<p>为单例对象创建一个静态实例，可以写成全局的，也可以在类方法中实现，并置为nil。</p>
</li>
<li>
<p>用GCD多线程的方式来实现单例，用dispatch_once_t来保证线程的安全性和单一性。</p>
</li>
<li>
<p>检查生成的静态实例是否为nil，若是则创建并返回一个本类的实例。</p>
</li>
<li>
<p>重写allocWithZone方法，用来保证其他人想通过alloc、init方法创建实例的时候，不会产生新实例。</p>
</li>
<li>
<p>适当实现copyWithZone。</p>
</li>
</ul>
<p>代码如下：</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Singleton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Singleton</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为单例对象创建的静态实例，置为nil，因为对象的唯一性，必须是static类型</span></span><br><span class="line"><span class="keyword">static</span> Singleton * _singleton = <span class="literal">nil</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  重写allocWithZone方法，保证alloc或者init创建的实例不会产生新实例，因为该类覆盖了allocWithZone方法，所以只能通过其父类分配内存，即[super allocWithZone]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _singleton = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  单例对象对外的唯一接口，用到dispatch_once在初始化时执行一次任务，且dispatch_once保证线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareSingleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _singleton = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>到这里，一个简单的单例模式就基本完成了。
 如果有需要，还可以把整个单例模式封装成一个宏。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/15/iOS单例设计模式/" data-id="cjptr3x4i001klyz9k5dxjys7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单例设计模式/">单例设计模式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Hexo常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/Hexo常用命令/" class="article-date">
  <time datetime="2016-03-15T05:00:33.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/Hexo常用命令/">Hexo常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<p>&lt;!--more--&gt;</p>
<h2>Quick Start</h2>
<h3>Create a new post</h3>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3>Run server</h3>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3>Generate static files</h3>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3>Deploy to remote sites</h3>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/15/Hexo常用命令/" data-id="cjptr3x3r000blyz9rjunqatp" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo命令/">hexo命令</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/18/Nodejs中编写异步的单元测试代码/">Nodejs中编写异步的单元测试代码</a>
          </li>
        
          <li>
            <a href="/2018/11/30/理解JavaScript中的浮点数/">理解JavaScript中的浮点数</a>
          </li>
        
          <li>
            <a href="/2018/11/21/理解prototype、getPrototypeOf和-proto-之间的不同/">理解prototype、getPrototypeOf和 _proto _之间的不同</a>
          </li>
        
          <li>
            <a href="/2018/11/14/javascript——为自己的库编写更健壮的API函数/">javascript——为自己的库编写更健壮的API函数</a>
          </li>
        
          <li>
            <a href="/2018/10/09/服务器的Mysql初始化设置/">服务器的Mysql初始化设置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 李晓&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;xiao.liunit@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>