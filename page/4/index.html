<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Leon的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="移动端,iOS,Android,javascript,html5,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验">
<meta property="og:type" content="website">
<meta property="og:title" content="Leon的博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Leon的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leon的博客">
  
    <link rel="alternate" href="/atom.xml" title="Leon的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Leon的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">每多学一点知识，就少写一行代码</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS漫谈——对于项目架构的思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/11/iOS漫谈——对于项目架构的思考/" class="article-date">
  <time datetime="2017-01-11T09:55:29.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/iOS漫谈——对于项目架构的思考/">iOS漫谈——对于项目架构的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>又一次的版本更新上架，心情容不得片刻舒缓，新的迭代任务又明白的摆在桌面上。今年上半年自己琢磨完<code>ReactiveCocoa</code>之后，对手上了项目做了<code>MVVM</code>架构的尝试，当时自我感觉效果还不错，代码之间的关系确实变得清楚了，并且有更加多的机会去进行单元测试，但是在新的一年，回头再去思考自己当时的架构，依旧会发现很多的问题，例如虽然逻辑清晰，但是并没有完全解耦，一些界面任务的处理，依旧通过<code>RAC</code>返回到<code>View</code>层去处理。只是<code>Controller</code>更干净了，心里自己觉得舒服罢了。</p>
<p>之后又经手了现在这个项目，在最近不断的工作不断的熟悉业务代码的同时，近日来对于架构方面的思考也不少。这个项目模块之间功能清晰，业务A和业务B之间耦合较少，但是在未来的日子里，公司又有可能新启动项目，不出意外会使用到跟当前项目相同的模块，而如何能节约时间，亦或是在当前项目上调优架构，是我最近思考的主题。</p>
<p>&lt;!--more--&gt;</p>
<p>在了解体会了项目中越来越多的缺点之后，我的脑子里首先蹦出来的就是<strong>模块化开发</strong>这个概念，这个概念在脑子里成形之后，我阅读了大量的他人组件化开发的源码，从阿里大神刘坤的博客里再到蘑菇街的组件化之路，大家再做<code>iOS</code>组件化开发时，似乎都或多或少的受到了路由这个概念的影响，这个概念是在各个模块之间，或者每个页面之间都用<code>url</code>来进行跳转，具体的话可以去查看<code>JLRoute</code>这个框架，是一个把<code>URL</code>跳转使用的非常好的一个框架，很理想。</p>
<p>但是我认为<code>URL</code>的路由概念虽好，但是在App启动时需要实例化各组件的模块，说白了就是有个类似注册各个模块的行为，而在组件化的过程中，注册<code>URL</code>并不是充分必要条件，会造成不必要的内存常驻，如果是注册<code>Class</code>，内存常驻会小一点，如果是注册实例，组件多了，常驻的内存也就更大了。</p>
<p>上述是第一点原因，其二，我认为当前团队，当开发人员去切换到路由模式，学习成本过大，我并不像在之前的公司，在软件团队里是一个决策者，当前我只是一个普通的程序员，改良架构这种事情的推动力度不够大，所以暂时先抛开组件化开发的这个想法。</p>
<p>其三，目前项目的时机未到，当前的项目还没有到相对完善的时候，迭代的压力也比较大，就目前的项目状况来看，似乎常规的开发模式还是可以沿用一段时间的，毕竟组件化开发的成效在小团队模式单项目的模式下不会体现的特别明显，反而团队越大，组件开发的必要性越强。并且当前团队在用<code>Swift</code>开发项目，如果希望最优的模块化开发，还是需要依赖到OC的<code>runtime</code>的。</p>
<p>至于如何进行组件化开发，我这里也就不赘述了，网上优秀的团队博客说了很多，比如阿里念纪、微信阅读、蘑菇街、casatwy等等。每一个都对组件化有独到的见解，而我现在能谈得所有见解，只不过是站在这些巨人的肩膀上汲取到的一点皮毛，真正的感想，还需等实践之后再来谈。</p>
<p>最近就打算写个小模块，把这个模块完全封装成一个组件，植入到App中。</p>
<p>对于缓存和数据持久化，我也想到了一个似乎可以更好处理，更干净的方案，等到测试完成，再写个文章单独讲述吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/11/iOS漫谈——对于项目架构的思考/" data-id="cjptr3x590034lyz92toxns80" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构思考/">架构思考</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-使用Block提高代码可读性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/06/使用Block提高代码可读性/" class="article-date">
  <time datetime="2017-01-06T09:11:37.000Z" itemprop="datePublished">2017-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/06/使用Block提高代码可读性/">使用Block提高代码可读性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近一直在思考并持续的扩充着自己的技术栈，比如每天坚持着学习前端知识，并且时常想着在移动端这条路上，自己的技术盲区。诚然，想要在一个领域达到一定的技术高度是挺困难的一件事情，操之过急万万不可，最主要的还是保持对技术的热情，慢慢沉淀。</p>
<p>以前的公司并不需要高强度的加班，所以时长有时间去发掘一些新鲜玩意儿，圈内有了技术热潮，也能及时跟进观望或者学习，但是最近在一波高强度加班过后，这种业务代码与自身学习之间的冲突也让我产生了一些自己的看法。一个程序员，不论何时，不能抛掉持续学习的习惯。</p>
<p>最近的大面积写业务代码，当碰到两个类之间的传值问题，我习惯性的解决方案是使用<code>delegate</code>，我觉得<code>delegate</code>本身当命名得当并且功能单一时，可阅读性会比较好。在习惯了这种思维后，开发中也养成了自己的习惯。</p>
<p>但是在最近封装代码的时候，我发觉<code>delegate</code>对于我自己定义并编写代码来说，可读性和使用性很好，但是当他人来使用我封装的代码的时候，也许<code>Block</code>更容易被理解一点。举个简单的例子，就比如</p>
<p>&lt;!--more--&gt;</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">           </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>这是我们日常最常用的<code>Block</code>结构之一，需要执行的事情，只要在<code>Block</code>中交代清楚就可以了，在阅读他人的代码时，可以直接在<code>Block</code>中直接阅读到执行的事件，并不用再去关注各种<code>delegate</code>中执行了什么。大大提高了代码的可读性。</p>
<p>我认为，程序员首先是写人能看得懂的代码，顺便运行。</p>
<p>在这个理念的驱使下，我大概会在之后的开发过程中，对可读性这个概念更上心一点，能用<code>block</code>处理的事件，尽量的用<code>block</code>处理。很久以前我写过一篇博客，讲述的是<code>blcok</code>的传值，<strong>iOS4.0</strong>开始，苹果爸爸引入了<code>block</code>的特性，而自从<code>block</code>特性诞生之日起，似乎它就受到了苹果爸爸特殊的照顾和青睐。字面上说，<code>block</code>就是一个代码块，但是它的神奇之处在于在内联(inline)执行的时候(这和C++很像)还可以传递参数。同时block本身也可以被作为参数在方法和函数间传递，这就给予了<code>block</code>无限的可能。</p>
<p>在日常的<code>coding</code>里绝大时间里开发者会是各种<code>block</code>的使用者，但是当你需要构建一些比较基础的，提供给别人用的类的时候，使用<code>block</code>会给别人的使用带来很多便利。当然如果你已经厌烦了一直使用<code>delegate</code>模式来编程的话，偶尔转转写一些<code>block</code>，不仅可以锻炼思维，也能让你写的代码看起来高端洋气一些，而且因为代码跳转变少，所以可读性也会增加。</p>
<p>今天我用一个判断奇数偶数的例子，来说说如何在封装的方法中，根据条件来执行方法内携带的<code>block</code>。</p>
<p>首先看看我们这个含有<code>blcok</code>的类是如何声明的。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^LixExcuteOperation)(<span class="built_in">NSInteger</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^LixError)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LixBlock</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)isOddNumber:(<span class="built_in">NSInteger</span>)number Excute:(LixExcuteOperation)excute Lixerror:(LixError)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>结合下面的图片，来看看<code>block</code>是如何声明并且定义的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/783864-3ad5d92333756aa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="block的声明与定义"></p>
<p>再来看看这个方法的内部，是如何使用<code>block</code>的，因为是示例，所以我很粗略的去判断了奇偶数，并没有考虑特殊情况，见谅，只是个栗子。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)isOddNumber:(<span class="built_in">NSInteger</span>)number Excute:(LixExcuteOperation)excute Lixerror:(LixError)error &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOddNum = number % <span class="number">2</span> == <span class="number">0</span> ? <span class="literal">NO</span> : <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (isOddNum &amp;&amp; excute) &#123;</span><br><span class="line">            excute(number);</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!isOddNum &amp;&amp; error) &#123;</span><br><span class="line">            error();</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于调用，就更加随意了。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LixBlock *block = [[LixBlock alloc] init];</span><br><span class="line">[block isOddNumber:<span class="number">9</span> Excute:^(<span class="built_in">NSInteger</span> number) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"is OddNumber %ld"</span>, number);</span><br><span class="line">            </span><br><span class="line">&#125; Lixerror:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"is not OddNumber"</span>);</span><br><span class="line">            </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>至此，一个简单的封装<code>block</code>进方法的栗子就已经讲完了。举一反三的讲，我们在对网络请求进行二次封装，执行<code>success</code>或者<code>error</code>状态的闭包时，就可以用到类似的思想了。代码的可读性是否如愿提升了呢。</p>
<p>简单的栗子讲到这里，<code>Coding</code>还是需要多写多思考的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/06/使用Block提高代码可读性/" data-id="cjptr3x5k003klyz9bykrle4b" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Block/">Block</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码可读性/">代码可读性</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——解析崩溃日志" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/04/iOS开发——解析崩溃日志/" class="article-date">
  <time datetime="2017-01-04T09:19:51.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/04/iOS开发——解析崩溃日志/">iOS开发——解析崩溃日志</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>iOS开发——解析崩溃日志</p>
<p>在实际的开发过程中，作为开发者的我们常常会碰到一种场景，那就是真机调试时崩溃了，而有时又不能在Xcode中打印出崩溃信息，那么这时候我们就必须要获取到崩溃原因，从而解决问题。</p>
<p>&lt;!--more--&gt;</p>
<p>而在万能的<strong>Xcode</strong>中，你可以找到自己测试机里的崩溃日志。<code>Window</code> -&gt; <code>Devices</code> -&gt; 选中自己的测试机 <code>View Device Logs</code> ，类似下图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/134882-3eb075f8e82c2413.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg" alt=""></p>
<p>而此时你可以选择导出自己的崩溃日志，并且这里的我们看到的崩溃日志，都是Xcode已经帮我们符号化的，很清晰的就可以看到崩溃原因，以及崩溃的位置。</p>
<p>如果是其他用户，下载了我们的App之后出现了崩溃，我们可以从<code>iTunes Connect</code>中获取到其他用户的崩溃日志，但是这时如果你去看他人的崩溃日志，不出意外您是懵逼的。这是崩溃日志么？ 天书还差不多。而如何把他人的崩溃日志符号化呢？ 这就是我们接下来要讲的内容了。</p>
<p>依旧是万能的<strong>Xcode</strong>给我们提供了一个工具 —— <strong>symbolicatecrash</strong>，这是一个<strong>Xcode</strong>自带的分析工具，可以通过机器上的崩溃日志和应用的<code>.dSYM</code>文件定位发生崩溃的位置，把<code>Crash</code>日志中的一堆地址替换成代码相应的位置。</p>
<h1>如何使用symbolicatecrash分析崩溃日志</h1>
<ol>
<li>
<p>在你的桌面创建一个新文件夹，并且命名为&quot;CrashReport&quot;</p>
</li>
<li>
<p>打开终端输入 <code>find /Applications/Xcode.app -name symbolicatecrash -type f</code>，然后终端会返回这个文件的路径,只要找到<code>symbolicatecrash</code>文件, 复制然后粘贴到刚才创建的 &quot;CrashReport&quot; 文件夹里面.</p>
</li>
<li>
<p>从<strong>Xcode Archive</strong>的二进制文件中找到**.dSYM<strong>文件和</strong>.app**文件拷贝到刚才创建的 <code>CrashReport</code> 文件夹里面.</p>
</li>
<li>
<p>打开终端进入<strong>CrashReport</strong>文件夹，依次输入以下命令行:</p>
</li>
</ol>
<p>记得替换自己的<strong>Username</strong></p>
<ul>
<li>
<p><code>cd /Users/username/Desktop/CrashReport</code></p>
</li>
<li>
<p><code>export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer</code></p>
</li>
<li>
<p><code>./symbolicatecrash ./*.crash ./*.app.dSYM &gt; symbol.crash</code></p>
</li>
</ul>
<p>这时候终端将会进行处理......
处理结果是生成一个新的文件symbol.crash。然后打开这个文件。
你就会看到日志跟我们调试APP的控制台输出的内容一样了！</p>
<p>天书变成了可以看懂的崩溃记录，攻城狮们，赶紧改Bug吧。</p>
<p>不知不觉博客更新了一年了，2017的第一篇日志，希望大家新年无Bug。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/04/iOS开发——解析崩溃日志/" data-id="cjptr3x580031lyz9j6v24rdt" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Crash/">Crash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolicatecrash/">symbolicatecrash</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——带有暂停功能的计时器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/23/iOS开发——带有暂停功能的计时器/" class="article-date">
  <time datetime="2016-12-22T23:39:35.000Z" itemprop="datePublished">2016-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/23/iOS开发——带有暂停功能的计时器/">iOS开发——带有暂停功能的计时器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>上篇博客我跟大家分享了如何在iOS系统中使用原生框架获取步数，又是大半个月过去了，运动模块的全部功能也总算完成了，也打算有始有终的把如何做一个跑步类App跟大家分享了。</p>
<p>运动类应用中，有一个很重要的模块就是计时器，当然，这个计时器不算复杂，只要有简单的开始、暂停以及复位功能即可。那么今天我们从<strong>Model</strong>层来看看这个计时器的逻辑实现。</p>
<p>我们先自己创建一个时间的<strong>Model</strong></p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunningTimer</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="comment">//MARK: var property</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> timeLabel: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> timer: <span class="type">NSTimer</span>?</span><br><span class="line">    <span class="comment">//开始和结束时间列表</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">private</span> <span class="keyword">var</span> startTimes = [<span class="type">NSDate</span>]()</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">private</span> <span class="keyword">var</span> endTimes = [<span class="type">NSDate</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> timeNumber = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            timeString = getTimeStringFromSecond(timeNumber)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> timeString = <span class="string">"00:00:00"</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            timeLabel.text = timeString</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&lt;!--more--&gt;</p>
<p>先从这段声明变量的代码分析开来，首先是定义了一个<strong>timeLabel</strong>，这个变量主要是为了在初始化时，直接将<strong>View</strong>层要显示的<strong>Label</strong>绑定进来，<strong>timer</strong>即为一个计时器，顺便定义了两个数组，用来记录时间，因为在真实环境中，可能有若干次暂停，所以用数组来存储。<strong>timeNumber</strong>即为计时器中的总秒数，用<strong>Swift</strong>的<strong>didSet</strong>特性来监听属性的变化，当秒数发送变化时，讲秒数转化成时间的标准格式，并且赋值给<strong>timeString</strong>，同理，<strong>timeString</strong>也在属性发送变化时，将自己的值赋值给<strong>Label</strong>的<strong>text</strong>属性用以显示。</p>
<p>到这里我们的变量讲解完毕，接着往下看功能的实现。</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: - 初始化</span></span><br><span class="line"><span class="keyword">init</span>(timeLabel: <span class="type">UILabel</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.timeLabel = timeLabel</span><br><span class="line">    timeLabel.text = timeString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是这个<strong>Model</strong>的初始化，用意一目了然，传入一个外部<strong>Label</strong>用以显示时间。</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计时开始</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">timingStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        startTimes.append(<span class="type">NSDate</span>())</span><br><span class="line">        timer = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">1</span>, target: <span class="keyword">self</span>, selector: #selector(<span class="keyword">self</span>.<span class="built_in">count</span>), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停计时</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">timingPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        endTimes.append(<span class="type">NSDate</span>())</span><br><span class="line">        timer?.invalidate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停后继续计时</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">timingContinue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        timingStart()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重置Timer</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">resetToStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        startTimes = []</span><br><span class="line">        endTimes = []</span><br><span class="line">        timer?.invalidate()</span><br><span class="line">        timeNumber = <span class="number">0</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里定义了四个方法，对应我们<strong>UI</strong>界面会出现的<strong>Button</strong>功能，<strong>Start</strong>、<strong>Pause</strong>、<strong>Continue</strong>、<strong>resetToStart</strong>。代码很简单，当start时添加当前时间至数组里，并且启动定时器，暂停时，销毁定时器，添加暂停的时间进入暂停数组。继续和重置同理。那么我们来看定时器启动时，对应的<strong>selector</strong>做了哪些事情。</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: - 计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">timeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> startTimes.<span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> currentTime = <span class="type">NSDate</span>()</span><br><span class="line">            timeNumber = <span class="type">Int</span>(<span class="type">CFDateGetTimeIntervalSinceDate</span>(currentTime, startTimes[<span class="number">0</span>]))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> startTimes.<span class="built_in">count</span> - endTimes.<span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">                endTimes.append(<span class="type">NSDate</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> index = startTimes.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">            endTimes[index] = <span class="type">NSDate</span>()</span><br><span class="line">            <span class="keyword">var</span> timeCount = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> startTime <span class="keyword">in</span> startTimes&#123;</span><br><span class="line">                timeCount += <span class="type">Int</span>(<span class="type">CFDateGetTimeIntervalSinceDate</span>(endTimes[startTimes.indexOf(startTime)!],startTime))</span><br><span class="line">            &#125;</span><br><span class="line">            timeNumber = timeCount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        timeCount()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当计时器的<code>count()</code>方法运行时、调用<code>timeCount()</code>方法。
当我们第一次运行计时器时，获取的秒数就是开始时间与当前时间比对的差值。
而之后，就是跟暂停之后启动时间的对比了。
这里面使用<code>public func CFDateGetTimeIntervalSinceDate(theDate: CFDate!, _ otherDate: CFDate!) -&gt; CFTimeInterval</code>函数获取两个时间之间的时间戳差值。
最后再把前面那个秒数转格式化时间的方法也贴出来吧。</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从以秒计时的时间里获得表示时间的字符串用于显示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTimeStringFromSecond</span><span class="params">(seconds: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> secondNumber = seconds % <span class="number">60</span></span><br><span class="line">    <span class="keyword">let</span> minuteNumber = (seconds / <span class="number">60</span>) % <span class="number">60</span></span><br><span class="line">    <span class="keyword">let</span> hourNumber = (seconds / (<span class="number">60</span>*<span class="number">60</span>)) % <span class="number">24</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> secondText = secondNumber &lt; <span class="number">10</span> ? <span class="string">"0<span class="subst">\(secondNumber)</span>"</span> : <span class="string">"<span class="subst">\(secondNumber)</span>"</span></span><br><span class="line">    <span class="keyword">let</span> minuteText = minuteNumber &lt; <span class="number">10</span> ? <span class="string">"0<span class="subst">\(minuteNumber)</span>"</span> : <span class="string">"<span class="subst">\(minuteNumber)</span>"</span></span><br><span class="line">    <span class="keyword">let</span> hourText = hourNumber &lt; <span class="number">10</span> ? <span class="string">"0<span class="subst">\(hourNumber)</span>"</span> : <span class="string">"<span class="subst">\(hourNumber)</span>"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">\(hourText)</span>:<span class="subst">\(minuteText)</span>:<span class="subst">\(secondText)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/23/iOS开发——带有暂停功能的计时器/" data-id="cjptr3x51002plyz97wh08rdw" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计时器/">计时器</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——步数获取" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/09/iOS开发——步数获取/" class="article-date">
  <time datetime="2016-12-08T23:12:43.000Z" itemprop="datePublished">2016-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/09/iOS开发——步数获取/">iOS开发——步数获取</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近半个月的开发工作，重点一直是类似于悦跑圈、咕咚这样的运动产品的功能，所以在处理iOS设备在运动中的表现也是积累了一些经验。</p>
<p>打算之后的文章，开始把整体的运动功能，分成简单的模块，来介绍一下。那么今天我们就来围绕iOS设备的计步功能，稍微简单的聊一聊。</p>
<p>&lt;!--more--&gt;</p>
<p>大家可能都看过或者知晓<code>HealthKit</code>这个框架，但是实际上，一般去研究过这个框架的，都会知道，实时的获取运动数据，并不是用这个框架的，尤其是步数，这个框架如果你在健康中没有开启步数权限的话，是获取不到的。</p>
<p>所以讲到了实时获取运动数据，苹果还提供了另一个框架给我们使用 —— <code>CoreMotion</code>框架。在这个框架中，我们可以获取加速度、步数等等等等运动数据，今天我们主要是讲讲步数是怎么获取的。</p>
<p>首先我们要去引用这个框架 <code>import CoreMotion</code>。</p>
<p>然后生成两个时间，分别为查询步数的起止时间，<code>CoreMotion</code>中会保存七天的运动数据,假设我们生成的时间为<code>startTime</code>,<code>endTime</code>.</p>
<p>分别对这两个时间进行初始化</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> startTime: <span class="type">NSDate</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> endTime: <span class="type">NSDate</span>!</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//在这里我只是随意初始化， 你可以根据自己具体的时间周期去设置时间</span></span><br><span class="line">   startTime = <span class="type">NSDate</span>()</span><br><span class="line">   endTime = <span class="type">NSDate</span>()</span><br></pre></td></tr></table></figure></p>
<p><code>CoreMotion</code>框架中，专门有一个类是负责处理步数的，就是<code>CMPedometer</code>，所以在这里我们想获取到步数信息，也要创建一个这个对象,并且同时创建一个<code>int</code>对象保存步数数据</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> pedometer: <span class="type">CMPedometer</span>!</span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">private</span> <span class="keyword">var</span> numberOfSteps = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>接下来 我们来看看具体获取步数的代码。</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">getPedonmeterData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pedometer = <span class="type">CMPedometer</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="type">CMPedometer</span>.isStepCountingAvailable()&#123;</span><br><span class="line">        <span class="keyword">if</span> startTime != <span class="literal">nil</span>&#123;</span><br><span class="line">            pedometer.queryPedometerDataFromDate(startTime!, toDate: endTime, withHandler: &#123; (data, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(error?.localizedDescription)</span>"</span>)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> data != <span class="literal">nil</span>&#123;</span><br><span class="line">                        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">                            <span class="keyword">self</span>.numberOfSteps = <span class="type">Int</span>(data!.numberOfSteps)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码是否简单易懂，先判断该设备是否支持计步功能，若是时间不为空，那么调用<code>public func queryPedometerDataFromDate(start: NSDate, toDate end: NSDate, withHandler handler: CMPedometerHandler)</code>函数去查询步数数据，传入的参数有起止时间，之后的操作在闭包中完成，分别判断是否有错误信息以及返回的数据时，就可以轻易的获取到步数。</p>
<p>今天的分享就到这里了，代码非常简短易懂，就不往GitHub上丢了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/09/iOS开发——步数获取/" data-id="cjptr3x54002wlyz9ji6zd0il" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/步数获取/">步数获取</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发-——-Swift版地址选择器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/25/iOS开发-——-Swift版地址选择器/" class="article-date">
  <time datetime="2016-11-25T02:44:06.000Z" itemprop="datePublished">2016-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/25/iOS开发-——-Swift版地址选择器/">iOS开发 —— Swift版地址选择器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>已经有二十多天没有更新自己的博客了，这段时间经历了很多事情，离开了生活了六七年的杭州，从离职再入职，忙的是一塌糊涂。</p>
<p>现在这个公司的项目使用了Swift开发，我一直想在自己的项目中也运用Swift，但是一直也没有机会，所以这次能够使用Swift正儿八经的开发，我也是超级兴奋的。</p>
<p>所以从以后开始，我的iOS系列的文章会逐渐的与Swift语言越来越相关。不得不说只有实际开发才能发现Swift中等着我要去踩的坑还有很多。没辙了，爱他就拼命的去填坑吧。</p>
<p>刚入职的第一周写了个简单的页面来熟悉公司项目代码，并且了解下业务。做了一个电商方面相关的收货地址的选择。</p>
<p>今天就来讲讲Swift版本的地址选择器的构建。</p>
<p>&lt;!--more--&gt;</p>
<h2>构建思路</h2>
<p>刚开始领导丢给我了一个数据库包含着中国地区的省市区关系，但是以前处理这个问题常用Plist文件来搞定，所以我也就偷懒懒得再去写Sql语句了，直接用一个Plist文件来处理。</p>
<p>之前OC写的很多省市选择器，都是封装的不够完善，直接调用存在很多问题。并且在处理省市联动的问题上，常常是通过拆分省市区为三个数组，当其中一个数据变化时，再根据 <code>index</code>来处理之后的数据联动。</p>
<p>所以这次的类就本着提高复用性的想法，对地址选择界面做了比较全面的封装，在之后的任何地方调用就非常方便。</p>
<p>首先把<code>UIPickerView</code>这个类的两个代理方法在自己的类里实现，以后调用的时候不用再去实现<code>UIPickerView</code>的两个<strong>Delegate Method</strong>，之后我们再提供一个协议，用最简单的方式来完成数据的获取。</p>
<p>至于省市区的结构，我们用结构体来处理，将省市区写成两个<strong>Struct</strong>，再之后就是简单的数据处理了。将数据加载并且传入这个Struct中。</p>
<p>最后，因为有时候不是省市区三个一起调用，有可能只是单个，或者两个。所以再用枚举声明三种类型，包括了<strong>省、省市、省市区</strong>三种情况，我想这样就可以满足所有情况的使用了。</p>
<h2>简单调用</h2>
<p>贴上一个简单调用的方法吧，最直接的调用，非常的简单。</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">LixAreaPickerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> dataLabel: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> subdivisionsPicker: <span class="type">LixAreaPickerView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">selectPickerType</span><span class="params">(sender: UISegmentedControl)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> sender.selectedSegmentIndex &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            subdivisionsPicker.pickerType = .<span class="type">Province</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            subdivisionsPicker.pickerType = .<span class="type">City</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            subdivisionsPicker.pickerType = .<span class="type">District</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">areaPickerDidUpdate</span><span class="params">(sender: LixAreaPickerView)</span></span> &#123;</span><br><span class="line">        dataLabel.text = (subdivisionsPicker.province ?? <span class="string">""</span>) + <span class="string">" "</span> + (subdivisionsPicker.city ?? <span class="string">""</span>) + <span class="string">" "</span> + (subdivisionsPicker.district ?? <span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        subdivisionsPicker.pickerDelegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>源码地址</h2>
<p>源码我已经放在我的<a href="https://github.com/originalix/LixAreaPickerView" target="_blank" rel="noopener">Github</a>上面了，欢迎使用。
如果您觉得好用，麻烦Star</p>
<p>谢谢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/25/iOS开发-——-Swift版地址选择器/" data-id="cjptr3x4k001mlyz9jl83ow0v" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/地址选择器/">地址选择器</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——GCD在Swift中的变脸" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/02/iOS开发——GCD在Swift中的变脸/" class="article-date">
  <time datetime="2016-11-02T00:34:25.000Z" itemprop="datePublished">2016-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/iOS开发——GCD在Swift中的变脸/">iOS开发——GCD在Swift中的变脸</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Xcode8正式发布后，Swift3也随即发布，为了跟上苹果这艘大船的脚步，赶紧逼着自己看文档哦。在看文档的过程中，发现GCD的变化跟OC相比简直都要不认识了，赶紧写个文章总结下，顺手复习下GCD中死锁的概念，死锁的总结发布在另一篇文章里了。</p>
<h1>取消过去的接口</h1>
<p>说起 GCD， 大家肯定回想起类似 <code>dispatch_async</code> 这样的语法。 GCD 的这个语法模式无论是和 Objc 还是 Swift 的整体风格都不太搭调。 所以 Swift 3 中对它的语法进行了彻底的改写。</p>
<p>&lt;!--more--&gt;</p>
<p>比如最常用的，在一个异步队列中读取数据， 然后再返回主线程更新 UI， 这种操作在新的 Swift 语法中是这样的：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.label?.text = <span class="string">"finished"</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1>DispatchQueue</h1>
<p>首先，dispatch 的全局函数不再写为下划线风格的名称了，它变成了一个更符合 Swift 风格的 DispatchQueue 的样子。</p>
<h1>main thread</h1>
<p>同样的，你不需要在去用  <code>dispatch_get_main_queue()</code> 来获取主线程，而是 <code>DispatchQueue.main</code> ，那么要放到主线程的代码怎么执行呢？只需要在线程后边使用  <code>.async {}</code> 即可，也就是说，大概是这样：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      your code runs <span class="keyword">in</span> main thread</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1>优先级</h1>
<p>无论从代码长度，已经语法含义上都清晰了一些呢。 另外， 这次对 <code>GCD</code> 的改进还包括优先级的概念。 以往我们使用 <code>Global Queue</code> 的时候，可以使用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code> 或 <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> 等，来指定队列的优先级。 而新的 <code>GCD</code> 引入了 <code>QoS (Quality of Service)</code> 的概念，体现在代码上面就是优先级所对应的名称变了， 对应关系如下：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="type">DISPATCH_QUEUE_PRIORITY_HIGH</span>:         .userInitiated</span><br><span class="line">* <span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>:      .<span class="keyword">default</span></span><br><span class="line">* <span class="type">DISPATCH_QUEUE_PRIORITY_LOW</span>:          .utility</span><br><span class="line">* <span class="type">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>:   .background</span><br></pre></td></tr></table></figure></p>
<p>举个例子，如果想以最高优先级执行这个队列， 那么就可以这样：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以这个优先级概念的变化， 大家也需要留意一下。</p>
<h1>获取一个队列</h1>
<p>我们使用  <code>DispatchQueue.global()</code> 获取一个系统的队列，这样的话获取的就是默认  <code>.default</code> 优先级的队列了，如果要获取其他优先级的队列，就使用 <code>DispatchQueue.global(qos: .userInitiated)</code> ，最后，我们使用 <code>.async {}</code> 来执行代码。</p>
<h1>创建一个队列</h1>
<p>直接用<code>DispatchQueue</code> 的初始化器来创建一个队列。最简单直接的办法是这样：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"myBackgroundQueue"</span>)</span><br></pre></td></tr></table></figure></p>
<p>复杂一点？你可以指定优先级以及队列类别：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"myBackgroundQueue"</span>, qos: .userInitiated, attributes: .concurrent)</span><br></pre></td></tr></table></figure></p>
<p>然后把代码放进去即可：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"aaa"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1>组队列</h1>
<p>对于组，现在你可以使用这样的语法直接创建一个组：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br></pre></td></tr></table></figure></p>
<p>至于使用，则是这样的：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"myBackgroundQueue"</span>)</span><br><span class="line"> </span><br><span class="line">queue.async(group:group) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"background working"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，如果有多个并发队列在同一个组里，我们需要它们完成了再继续呢？</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">group.wait()</span><br></pre></td></tr></table></figure></p>
<h1>dispatch_time_t</h1>
<p>还有一个是对 dispatch_time_t 的改进：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> delay = <span class="type">DispatchTime</span>.now() + .seconds(<span class="number">60</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.main.after(when: delay) &#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>语法使用起来更加简单。DispatchTime.now() 是当前事前， 然后加上 .seconds(60) 代表 60秒。 再使用 DispatchQueue.main.after 让这个操作在 60 秒后执行。 相比于之前的 GCD 语法，那就容易理解很多了。</p>
<p>顺手儿把 GCD 以前获取当前时间的语法贴出来对比一下：</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatch_time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="type">Int64</span>(<span class="number">60</span> * <span class="type">NSEC_PER_SEC</span>))</span><br></pre></td></tr></table></figure></p>
<p>这样一比， 立竿见影哈。 至少上面新的 GCD 语法， 我大概看了一眼，就能明白它是什么意思了。 而下面这个老的语法，如果不查阅相关文档的话，第一眼恐怕没那么容易看懂了。</p>
<h1>结尾</h1>
<p>Swift 3 对 GCD 的语法改进还是很大的。 新的语法结构还是很不错的， 当然大多数朋友应该都习惯了以前的写法，也包括我~ 所以肯定需要一点时间适应。 希望这篇文章能帮你节省查阅文档的时间， 在闲暇时刻了解一些技术点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/02/iOS开发——GCD在Swift中的变脸/" data-id="cjptr3x4q001zlyz9010fqayy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS——GCD的死锁案例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/iOS——GCD的死锁案例/" class="article-date">
  <time datetime="2016-11-01T04:57:11.000Z" itemprop="datePublished">2016-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/iOS——GCD的死锁案例/">iOS——GCD的死锁案例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在项目中，用GCD的时候非常多，但是我最近脑子里一直在问自己一个问题，死锁是什么。惭愧的是这个当初清晰的概念现在愈加模糊，考虑到自己并没有专门整理过死锁的文章，所以写一篇技术文章来帮助自己梳理概念。</p>
<p>GCD提供了功能强大的任务和队列控制功能，相比于NSOperationQueue更加底层，因此如果不注意也会导致死锁。</p>
<p>所谓死锁，通常指有两个线程A和B都卡住了，并等待对方完成某些操作。A不能完成是因为它在等待B完成。但B也不能完成，因为它在等待A完成。于是大家都完不成，就导致了死锁（DeadLock）。</p>
<p>&lt;!--more--&gt;</p>
<h1>串行与并行</h1>
<p>在使用GCD的时候，我们会把需要处理的任务放到<code>Block</code>中，然后将任务追加到相应的队列里面，这个队列，叫做<code>Dispatch Queue</code>。然而，存在于两种<code>Dispatch Queue</code>，一种是要等待上一个执行完，再执行下一个的<code>Serial Dispatch Queue</code>，这叫做串行队列；另一种，则是不需要上一个执行完，就能执行下一个的<code>Concurrent Dispatch Queue</code>，叫做并行队列。这两种，均遵循<code>FIFO</code>原则。</p>
<blockquote>
<p>举一个简单的例子，在三个任务中输出1、2、3，串行队列输出是有序的1、2、3，但是并行队列的先后顺序就不一定了。</p>
</blockquote>
<h1>同步与异步</h1>
<p>串行与并行针对的是队列，而同步与异步，针对的则是线程。最大的区别在于，同步线程要阻塞当前线程，必须要等待同步线程中的任务执行完，返回以后，才能继续执行下一任务；而异步线程则是不用等待。</p>
<h1>死锁的具体案例</h1>
<blockquote>
<p>接下来所有的案例代码，我都会用Swift3的语言重写一遍，为了帮助自己加深对Swift3的语言的理解。</p>
</blockquote>
<p>##Demo1</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1"</span>); <span class="comment">// 任务1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>); <span class="comment">// 任务2</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3"</span>); <span class="comment">// 任务3</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"1"</span>)   <span class="comment">//任务1</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"2"</span>)  <span class="comment">//任务2</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"3"</span>)  <span class="comment">//任务3</span></span><br></pre></td></tr></table></figure></p>
<p>接下来 控制器输出:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>
<p>dispatch_sync表示是一个同步线程；</p>
</li>
<li>
<p>dispatch_get_main_queue表示运行在主线程中的主队列；</p>
</li>
<li>
<p>任务2是同步线程的任务。</p>
</li>
<li>
<p>首先执行任务1，这是肯定没问题的，只是接下来，程序遇到了同步线程，那么它会进入等待，等待任务2执行完，然后执行任务3。但这是队列，有任务来，当然会将任务加到队尾，然后遵循FIFO原则执行任务。那么，现在任务2就会被加到最后，任务3排在了任务2前面</p>
</li>
<li>
<p>任务3要等任务2执行完才能执行，任务2由排在任务3后面，意味着任务2要在任务3执行完才能执行，所以他们进入了互相等待的局面。</p>
</li>
</ul>
<h2>Demo2</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1"</span>); <span class="comment">// 任务1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>); <span class="comment">// 任务2</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3"</span>); <span class="comment">// 任务3</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>).sync &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"3"</span>)</span><br></pre></td></tr></table></figure></p>
<p>控制器输出</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>首先执行任务1，接下来会遇到一个同步线程，程序会进入等待。</p>
</li>
<li>
<p>等待任务2执行完成以后，才能继续执行任务3。</p>
</li>
<li>
<p>从<code>dispatch_get_global_queue</code>可以看出，任务2被加入到了全局的并行队列中，当并行队列执行完任务2以后，返回到主队列，继续执行任务3。</p>
</li>
</ul>
<h2>Demo3</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.demo.serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1"</span>); <span class="comment">// 任务1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>); <span class="comment">// 任务2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>); <span class="comment">// 任务3</span></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>); <span class="comment">// 任务4</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5"</span>); <span class="comment">// 任务5</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"serealQueue"</span>, qos: .<span class="keyword">default</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">queue.async &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">queue.sync &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"5"</span>)</span><br></pre></td></tr></table></figure></p>
<p>控制台输出</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">// 5和2的顺序不一定</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>
<p>这个案例没有使用系统提供的串行或并行队列，而是自己通过<code>dispatch_queue_create</code>函数创建了一个<code>DISPATCH_QUEUE_SERIAL</code>的串行队列。</p>
</li>
<li>
<p>执行任务1；</p>
</li>
<li>
<p>遇到异步线程，将【任务2、同步线程、任务4】加入串行队列中。因为是异步线程，所以在主线程中的任务5不必等待异步线程中的所有任务完成；</p>
</li>
<li>
<p>因为任务5不必等待，所以2和5的输出顺序不能确定；</p>
</li>
<li>
<p>任务2执行完以后，遇到同步线程，这时，将任务3加入串行队列；</p>
</li>
<li>
<p>又因为任务4比任务3早加入串行队列，所以，任务3要等待任务4完成以后，才能执行。但是任务3所在的同步线程会阻塞，所以任务4必须等任务3执行完以后再执行。这就又陷入了无限的等待中，造成死锁。</p>
</li>
</ul>
<h2>Demo4</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1"</span>); <span class="comment">// 任务1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>); <span class="comment">// 任务2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>); <span class="comment">// 任务3</span></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>); <span class="comment">// 任务4</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5"</span>); <span class="comment">// 任务5</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>).async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"5"</span>)</span><br></pre></td></tr></table></figure></p>
<p>控制器输出</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">// 5和2的顺序不一定</span><br></pre></td></tr></table></figure></p>
<p>分析:</p>
<ul>
<li>
<p>首先，将【任务1、异步线程、任务5】加入Main Queue中，异步线程中的任务是：【任务2、同步线程、任务4】。</p>
</li>
<li>
<p>所以，先执行任务1，然后将异步线程中的任务加入到Global Queue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。</p>
</li>
<li>
<p>然后再看异步线程中的任务执行顺序。任务2执行完以后，遇到同步线程。将同步线程中的任务加入到Main Queue中，这时加入的任务3在任务5的后面。</p>
</li>
<li>
<p>当任务3执行完以后，没有了阻塞，程序继续执行任务4。</p>
</li>
<li>
<p>从以上的分析来看，得到的几个结果：1最先执行；2和5顺序不一定；4一定在3后面。</p>
</li>
</ul>
<h2>Demo5</h2>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>); <span class="comment">// 任务1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>); <span class="comment">// 任务2</span></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>); <span class="comment">// 任务3</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"4"</span>); <span class="comment">// 任务4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5"</span>); <span class="comment">// 任务5</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>).async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"5"</span>)</span><br></pre></td></tr></table></figure></p>
<p>控制器输出:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">// 1和4的顺序不一定</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>
<p>和上面几个案例的分析类似，先来看看都有哪些任务加入了Main Queue：【异步线程、任务4、死循环、任务5】。</p>
</li>
<li>
<p>在加入到Global Queue异步线程中的任务有：【任务1、同步线程、任务3】。</p>
</li>
<li>
<p>第一个就是异步线程，任务4不用等待，所以结果任务1和任务4顺序不一定。</p>
</li>
<li>
<p>任务4完成后，程序进入死循环，Main Queue阻塞。但是加入到Global Queue的异步线程不受影响，继续执行任务1后面的同步线程。</p>
</li>
<li>
<p>同步线程中，将任务2加入到了主线程，并且，任务3等待任务2完成以后才能执行。这时的主线程，已经被死循环阻塞了。所以任务2无法执行，当然任务3也无法执行，在死循环后的任务5也不会执行。</p>
</li>
<li>
<p>最终，只能得到1和4顺序不定的结果。</p>
</li>
</ul>
<h1>总结</h1>
<p>在总结完这些GCD死锁的情况的以后，我觉得脑子里关于GCD中死锁的概念也逐渐清晰了。以后在项目中也会运用的时候也会更加注意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/iOS——GCD的死锁案例/" data-id="cjptr3x4h001hlyz9ip9blck0" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD的死锁/">GCD的死锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——TDD、BDD方法以及Kiwi单元测试框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/26/iOS开发——TDD、BDD方法以及Kiwi单元测试框架/" class="article-date">
  <time datetime="2016-10-26T06:39:21.000Z" itemprop="datePublished">2016-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/26/iOS开发——TDD、BDD方法以及Kiwi单元测试框架/">iOS开发——TDD、BDD方法以及Kiwi单元测试框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1>TDD和BDD</h1>
<p>在GitBook上看过一篇文章，一个不写单元测试的程序员不是一个好的攻城狮。坦白的说，在<strong>Objective-C</strong>这个领域的里，我见过的会主动写单元测试的程序员还是比较少的。当然了，在那些大的开源项目里，我还是见到过很多单元测试的应用。</p>
<p>于是也就促使我想总结总结自己现在对单元测试的理解。众所周知苹果在<code>Xcode5</code>中引入了<code>XCTest</code>框架替换了原来的<code>SenTestingKit</code>。这也显示了苹果一直致力于在iOS开发中集成更方便可用的测试。但是我一直觉得<code>XCTest</code>的断言可读性较差，如果是让他人来阅读这段单元测试，会比较的花费精力。</p>
<p>再进入讨论单元测试之前，我们来谈谈不一样测试思想</p>
<p>&lt;!--more--&gt;</p>
<ul>
<li>
<p>行为驱动开发（英语：Behavior-driven development，缩写BDD）是一种敏捷软件开发的技术，BDD的重点是通过与利益相关者的讨论取得对预期的软件行为的清醒认识。它通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。</p>
</li>
<li>
<p>测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>
</li>
</ul>
<p>上面讲述了TDD和BDD的思想差别，看到这里，你们认为当前的iOS开发适合怎样的测试思想。不知道你们开发中的实际情况是如何，在现在大环境赶进度的开发下，一般我是采用BDD的测试方法。</p>
<p>而谈到BDD，我要给大家介绍一个iOS中非常有名并且好用的BDD框架 —— <strong>Kiwi</strong>。</p>
<h1>Kiwi</h1>
<h2>Kiwi的安装</h2>
<ul>
<li>项目主页: <a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="noopener">https://github.com/kiwi-bdd/Kiwi</a></li>
</ul>
<p><strong>使用Cocopods 安装</strong></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target :YourProjectTests do</span><br><span class="line">  pod &apos;Kiwi&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>在这里记得一定要替换<code>YourProject</code>为你的项目名。</p>
<h2>Kiwi的基本结构</h2>
<p>在讲<strong>Kiwi</strong>的常用语法前，我们先来看一段Kiwi的Github提供的示例代码。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">@"Team"</span>, ^&#123;</span><br><span class="line">    context(<span class="string">@"when newly created"</span>, ^&#123;</span><br><span class="line">        it(<span class="string">@"should have a name"</span>, ^&#123;</span><br><span class="line">            <span class="keyword">id</span> team = [Team team];</span><br><span class="line">            [[team.name should] equal:<span class="string">@"Black Hawks"</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">@"should have 11 players"</span>, ^&#123;</span><br><span class="line">            <span class="keyword">id</span> team = [Team team];</span><br><span class="line">            [[[team should] have:<span class="number">11</span>] players];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们很容易根据上下文将其提取为Given..When..Then的三段式自然语言。</p>
<blockquote>
<p>Given a team, when newly created, it should have a name, and should have 11 players</p>
</blockquote>
<p>是不是非常简单易懂的语法结构。</p>
<p><code>describe</code>描述需要测试的对象内容，也即我们三段式中的<code>Given</code>，<code>context</code>描述测试上下文，也就是这个测试在<code>When</code>来进行，最后<code>it</code>中的是测试的本体，描述了这个测试应该满足的条件，三者共同构成了<strong>Kiwi</strong>测试中的行为描述。它们是可以<strong>nest</strong>的，也就是一个Spec文件中可以包含多个<code>describe</code>（虽然我们很少这么做，一个测试文件应该专注于测试一个类）；一个<code>describe</code>可以包含多个<code>context</code>，来描述类在不同情景下的行为；一个<code>context</code>可以包含多个<code>it</code>的测试例。</p>
<p>Kiwi还有一些其他的行为描述关键字，其中比较重要的包括:</p>
<ul>
<li>
<p><code>beforeAll(aBlock)</code> - 当前scope内部的所有的其他block运行之前调用一次</p>
</li>
<li>
<p><code>afterAll(aBlock)</code> - 当前scope内部的所有的其他block运行之后调用一次</p>
</li>
<li>
<p><code>beforeEach(aBlock)</code> - 在scope内的每个it之前调用一次，对于context的配置代码应该写在这里</p>
</li>
<li>
<p><code>afterEach(aBlock)</code> - 在scope内的每个it之后调用一次，用于清理测试后的代码</p>
</li>
<li>
<p><code>specify(aBlock)</code> - 可以在里面直接书写不需要描述的测试</p>
</li>
<li>
<p><code>pending(aString, aBlock)</code> - 只打印一条log信息，不做测试。这个语句会给出一条警告，可以作为一开始集中书写行为描述时还未实现的测试的提示。</p>
</li>
<li>
<p><code>xit(aString, aBlock)</code> - 和pending一样，另一种写法。因为在真正实现时测试时只需要将x删掉就是it，但是pending语意更明确，因此还是推荐pending</p>
</li>
</ul>
<h2>Kiwi使用实例</h2>
<p>就拿项目中一个真实的场景来说，我在写完一个适配所有iPhone机型的宽高的类之后，我用Kiwi来进行单元测试。</p>
<p>首先我这个类是这么描述宽高的</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CalculateLayout.h</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)neu_layoutForAlliPhoneHeight:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)neu_layoutForAlliPhoneWidth:(<span class="built_in">CGFloat</span>)width;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  CalculateLayout.m</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)layoutForAlliPhoneHeight:(<span class="built_in">CGFloat</span>)height type:(IPhoneType)type &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> layoutHeight = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> iPhone4Type:</span><br><span class="line">            layoutHeight = ( height / iPhone6Height ) * iPhone4Height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> iPhone5Type:</span><br><span class="line">            layoutHeight = ( height / iPhone6Height ) * iPhone5Height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> iPhone6Type:</span><br><span class="line">            layoutHeight = ( height / iPhone6Height ) * iPhone6Height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> iPhone6PlusType:</span><br><span class="line">            layoutHeight = ( height / iPhone6Height ) * iPhone6PlusHeight;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layoutHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)layoutForAlliPhoneWidth:(<span class="built_in">CGFloat</span>)width type:(IPhoneType)type &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> layoutWidth = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> iPhone4Type:</span><br><span class="line">            layoutWidth = ( width / iPhone6Width ) * iPhone4Width;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> iPhone5Type:</span><br><span class="line">            layoutWidth = ( width / iPhone6Width ) * iPhone5Width;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> iPhone6Type:</span><br><span class="line">            layoutWidth = ( width / iPhone6Width ) * iPhone6Width;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> iPhone6PlusType:</span><br><span class="line">            layoutWidth = ( width / iPhone6Width ) * iPhone6PlusWidth;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layoutWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反正大概意思就是我输入了一个宽高，他根据UI给定的设计图，返回给我一个宽高适配当前机型的宽高。</p>
<p>那么我们如何来写这个测试用例呢.</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Kiwi/Kiwi.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CalculateLayout.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SPEC_BEGIN(CalculateLayoutTests)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">@"CalculateLayout"</span>, ^&#123;</span><br><span class="line">    context(<span class="string">@"when calculate width and height"</span>, ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGFloat</span> width = [CalculateLayout neu_layoutForAlliPhoneWidth:<span class="number">375.</span>f];</span><br><span class="line">        <span class="built_in">CGFloat</span> height = [CalculateLayout neu_layoutForAlliPhoneHeight:<span class="number">667.</span>f];</span><br><span class="line">        </span><br><span class="line">        pending_(<span class="string">@"All iPhone Test"</span>, ^&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        it(<span class="string">@"should layout width"</span>, ^&#123;</span><br><span class="line">            [[theValue(width) should] equal:theValue(<span class="number">320.</span>f)];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        it(<span class="string">@"should layout height"</span>, ^&#123;</span><br><span class="line">            [[theValue(height) should] equal:theValue(<span class="number">568.</span>f)];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">SPEC_END</span><br></pre></td></tr></table></figure></p>
<p>我写进去的宽高数值是iPhone6的宽高数值，如果用5S的模拟器来运行，将会返回5S的宽高 320 * 568</p>
<p>当我们 com+U 运行这段测试用例时。</p>
<p>控制台的输出</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ &apos;CalculateLayout, when calculate width and height, should layout width&apos; [PASSED]</span><br><span class="line"></span><br><span class="line">+ &apos;CalculateLayout, when calculate width and height, should layout height&apos; [PASSED]</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于有<code>context</code>的存在，以及其可以嵌套的特性，测试的流程控制相比传统测试可以更加精确。我们更容易把<code>before</code>和<code>after</code>的作用区域限制在合适的地方。</p>
<p>实际的测试写在it里，是由一个一个的期望(Expectations)来进行描述的，期望相当于传统测试中的断言，要是运行的结果不能匹配期望，则测试失败。在<code>Kiwi</code>中期望都由<code>should</code>或者<code>shouldNot</code>开头，并紧接一个或多个判断的的链式调用，大部分常见的是<code>be</code>或者<code>haveSomeCondition</code>的形式。在我们上面的例子中我们使用了<code>should not be nil</code>和<code>should equal</code>两个期望来确保字符串赋值的行为正确。其他的期望语句非常丰富，并且都符合自然语言描述，所以并不需要太多介绍。在使用的时候不妨直接按照自己的想法来描述自己的期望，一般情况下在<code>IDE</code>的帮助下我们都能找到想要的结果。如果您想看看完整的期望语句的列表，可以参看文档的这个页面。从这一点来看，Kiwi可以说是一个非常灵活并具有可扩展性的测试框架。</p>
<p>来解释下上面的语法中用到的<code>theValue</code>.</p>
<p><code>Kiwi</code>为我们提供了一个标量转对象的语法糖，叫做<code>theValue</code>，在做精确比较的时候我们可以直接使用例子中直接与<code>320.f或者568.f</code>做比较这样的写法来进行对比。</p>
<p>通过这样一个简单的例子，我们基本能掌握Kiwi的语法，以及Kiwi的使用。单元测试的门其实很好进，但是如何用心的，动脑子的去写单元测试，则是对我们程序员莫大的考验哦。</p>
<p>我讲的并不完善，也不详细，就算简单记录自己目前的收获吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/26/iOS开发——TDD、BDD方法以及Kiwi单元测试框架/" data-id="cjptr3x8n00e3lyz96mlng3qj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——Instruments工具调试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/24/iOS开发——Instruments工具调试/" class="article-date">
  <time datetime="2016-10-24T05:25:53.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/iOS开发——Instruments工具调试/">iOS开发——Instruments工具调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>随着项目的进行，APP的优化必须要尽早的展开了，所以最近自己在学习很多APP的调试技巧，今天我们就来说说Xcode为我们准备的自带的调试工具。</p>
<p>代码性能是个避不开的话题。随着项目的扩大和功能的增多，没经过认真调试和优化的代码，要么任性地卡顿运行，要么低调地崩溃了之……结果呢，大家用着不高兴，开发者也不开心。</p>
<p>本篇重点讨论一下 iOS性能测试中的启动测试、内存泄露测试、CPU测试。</p>
<p>&lt;!--more--&gt;</p>
<p>##1.启动测试
测试工具：Instruments &gt; TimeProfile
可在 appDelegate.m中加入一段代码，来进行测试：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLaunch</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; 100000;i++)&#123;</span><br><span class="line">		NSLog(@&quot;test&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###1）获得启动时间
APP启动之后，中止 TimeProfile，按住 option键在监控窗口中拖拽，选中监控区域中起始点到打开 APP后的峰谷，查看APP启动所需时间，如下图：
<img src="http://img.blog.csdn.net/20150428175349386" alt="图1 在 TimeProfile中查看启动时间"></p>
<p>###2）分析可优化空间
首先，需要注意一下右侧栏中的几个给力的筛选项，如下图：
<img src="http://img.blog.csdn.net/20150428180729277" alt="图2 TimeProfile右边栏"></p>
<p>（注：我觉得非常常用的标记为『必选项』）</p>
<blockquote>
<ul>
<li>Separate by Thread //按线程聚类，『可选项』，当我们想查看每个线程中哪些方法比较耗时时，勾选它；</li>
<li>Invert Call Tree //反转调用栈信息，『必选项』，否则 main一直排在最上面，碍事；</li>
<li>Hide System Libraries //隐藏系统库，『可选项』，只查看自己应用的栈信息；</li>
<li>Top Functions //按耗时降序排列，『必选项』</li>
</ul>
</blockquote>
<p>Running Time列中显示运行每个方法所耗费的时间，根据耗时和占比猜测是否有代码需要优化。双击中间主窗口中的方法名进入具体的代码行查看，耗时多的代码行有颜色标记，并显示占比。
<img src="http://img.blog.csdn.net/20150428182138433" alt="图3 TimeProfile 代码行"></p>
<p>获取 APP启动时间非常简单，但分析哪些地方可以优化，则需要对代码足够了解。项目的启动时间没有一个特定的值，利用该方法可以提供一个缩小的检测范围，尽可能发现可被优化的代码。</p>
<p>##2.内存泄露测试
有两种方法可以采用，第一利用静态分析，第二使用Instruments工具集。
###1）静态分析
在 xcode中长按运行按钮&gt;Analyze，可启动代码静态分析。
<img src="http://img.blog.csdn.net/20150428182542806" alt="启动静态分析"></p>
<p><img src="http://img.blog.csdn.net/20150428191837926" alt="这里写图片描述">
对于 MRC项目，静态分析是必要的，对于 ARC项目，静态分析作为可选项。
这项检查只覆盖代码编译时可能存在的问题，但并不能覆盖代码运行时。这时，我们还需要结合动态分析工具。
###2）动态分析
工具: Allocations,Leaks</p>
<h4>【Allocation】</h4>
<p>Allocations组件监控对象调用了 alloc方法申请内存后的内存使用情况，可记录对象生命周期中内存引用计数的变化，当对象被正常释放后不再继续追踪。</p>
<p>####【Leaks】
Leaks监控内存泄露，一般和 Allocations一起使用，在检测到内存泄露后，通过 Allocations定位到具体的代码。发现问题时，监控图会显示红条。修改代码后，再次查看，如果红色消失则表示内存泄露被修复成功了。</p>
<p>但 Leaks可能会『假摔』，例如每次 APP启动后，都会显示几个红条，因此 Leaks的使用过程中也需要人工判断分析。</p>
<p>步骤：
a）运行Profile&gt;Allocations，启动 APP后实时查看 Allocations\Leaks图，若 Leaks中出现红条，则双击红条，切换到 Leaks视图；
<img src="http://img.blog.csdn.net/20150430114811540" alt="这里写图片描述">
b) 选择右侧栏查看 stack trace，点击黑色图标（非系统类），查看具体的代码实现，分析可能出现的问题，如下图：
<img src="http://img.blog.csdn.net/20150430140252822" alt="这里写图片描述"></p>
<p>例如，上面的代码中，每次初始化都会创建一个NSMutableArray 对象，可以优化为removeAllObject后重利用。</p>
<p>###3）CPU等指标
工具：Activity Monitor
可监控 CPU和内存指标，并可对比多次监控的结果。</p>
<p>步骤：
a)profile&gt;Activity Monitor 启动 APP, 运行过程中option选择峰值查看 cpu和内存使用量。
b)对比多次监控的结果，把最差情况作为最终结果；</p>
<p><img src="http://img.blog.csdn.net/20150430141211461" alt="ActivityMonitor"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/24/iOS开发——Instruments工具调试/" data-id="cjptr3x4r0021lyz92guev1l8" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Instruments工具/">Instruments工具</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/调试/">调试</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——FMDB的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/20/iOS开发——FMDB的使用/" class="article-date">
  <time datetime="2016-10-20T08:59:53.000Z" itemprop="datePublished">2016-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/20/iOS开发——FMDB的使用/">iOS开发——FMDB的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>今天决定给手上的项目加上一个数据库，用来进行数据持久化操作，关于在iOS端的数据持久化方式的差异，这里也就不再赘述，相信如果真实使用并且去感受过的人，有自己的评判标准。</p>
<p>在比较了<code>Realm</code>、<code>SQLite</code>之后，我决定在项目中依然使用<code>SQLite</code>数据库，并切还是使用<code>FMDB</code>这个第三方库来简化操作。(Realm我是觉得体积庞大，至于CoreData问我为什么不用，小心我打人哦)。</p>
<p><code>SQLite</code>语句，从我自身来说，感觉其实没有那么好的记忆力，所以我又花了一点点时间来温习<code>FMDB</code>的常规操作，想到自己从来没有总结过数据库这方面的知识，今天就花一点点时间，对iOS端<code>SQLite</code>数据库做一点操作层面的总结。</p>
<p>&lt;!--more--&gt;</p>
<p><code>SQLite</code>数据库，其实并不难学，打败许多初学者的，我觉得应该是它C语言中繁琐的API。我之前说我记不住，这套API，我真的看几次忘几次。所以才有了应运而生的<code>FMDB</code>。</p>
<h2>建表以及关闭表</h2>
<p>使用数据库的第一件事，就是建立一个数据库。要注意的是，在iOS环境下，只有<code>document</code> <code>directory</code> 是可以进行读写的。在写程序时用的那个<code>Resource</code>资料夹底下的东西都是read-only。因此，建立的资料库要放在<code>document</code> 资料夹下。方法如下：</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建表</span></span><br><span class="line"><span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"doc = %@"</span>, doc);</span><br><span class="line"><span class="built_in">NSString</span> *fileName = [doc stringByAppendingPathComponent:<span class="string">@"device.sqlite"</span>];</span><br><span class="line">FMDatabase *db = [FMDatabase databaseWithPath:fileName];</span><br><span class="line"><span class="keyword">if</span> ([db open]) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS Device (deviceID text, deviceName text, deviceType integer, deviceStatus integer);"</span>];</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建表成功"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"建表失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样简单的操作就已经完成了数据库的创建，每一行代码都很好理解，先是找到程序在沙盒中的路径，之后填写数据库的名字，完成创建。如果创建数据库成功，那么我们就创建一个名字叫<code>Device</code>的表，这个设备表里有 <code>deviceID, deviceName, deviceType, deviceStatus</code> 四个字段，他们的类型分别是<code>text、text、integer、integer</code>。</p>
<h2>关于CURD</h2>
<h3>插入数据</h3>
<p>首先，我们对我们的<code>DeviceModel</code>的模型文件声明属性，</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DeviceModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *deviceName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *deviceID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> deviceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> deviceStatus;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDeviceName:(<span class="built_in">NSString</span> *)deviceName DeviceID:(<span class="built_in">NSString</span> *)deviceID DeviceType:(<span class="built_in">NSInteger</span>)deviceType DeviceStatus:(<span class="built_in">NSInteger</span>)deviceStatus;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)DeviceWithDeviceName:(<span class="built_in">NSString</span> *)deviceName DeviceID:(<span class="built_in">NSString</span> *)deviceID DeviceType:(<span class="built_in">NSInteger</span>)deviceType DeviceStatus:(<span class="built_in">NSInteger</span>)deviceStatus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>在**.m**文件中写好它的初始化方法</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DeviceModel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DeviceModel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDeviceName:(<span class="built_in">NSString</span> *)deviceName DeviceID:(<span class="built_in">NSString</span> *)deviceID DeviceType:(<span class="built_in">NSInteger</span>)deviceType DeviceStatus:(<span class="built_in">NSInteger</span>)deviceStatus &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _deviceName = deviceName;</span><br><span class="line">        _deviceID = deviceID;</span><br><span class="line">        _deviceType = deviceType;</span><br><span class="line">        _deviceStatus = deviceStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)DeviceWithDeviceName:(<span class="built_in">NSString</span> *)deviceName DeviceID:(<span class="built_in">NSString</span> *)deviceID DeviceType:(<span class="built_in">NSInteger</span>)deviceType DeviceStatus:(<span class="built_in">NSInteger</span>)deviceStatus &#123;</span><br><span class="line">    </span><br><span class="line">    DeviceModel *model = [[DeviceModel alloc] initWithDeviceName:deviceName DeviceID:deviceID DeviceType:deviceType DeviceStatus:deviceStatus];</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>接下来是插入数据了</p>
<p>插入数据跟前面一样，用<code>executeUpdate</code>后面加语法就可以了。比较不同的是，因为插入的数据会跟<code>Objective-C</code>的变数有关，所以在<code>string</code>里使用?号来代表这些变数。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DeviceModel *model = [[DeviceModel alloc] initWithDeviceName:<span class="string">@"控制主机"</span> DeviceID:<span class="string">@"0001"</span> DeviceType:<span class="number">1</span> DeviceStatus:<span class="number">0</span>];</span><br><span class="line">[db executeUpdateWithFormat:<span class="string">@"INSERT INTO Device (deviceID, deviceName, deviceType, deviceStatus) VALUES (%@, %@, %ld, %ld);"</span>,model.deviceID, model.deviceName, model.deviceType, model.deviceStatus];</span><br></pre></td></tr></table></figure></p>
<h3>删除更新数据</h3>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除更新数据</span></span><br><span class="line">    <span class="built_in">NSString</span> *device1 = <span class="string">@"0001"</span>;</span><br><span class="line">    [db executeUpdateWithFormat:<span class="string">@"delete from Device where deviceID = %@;"</span>, device1];</span><br><span class="line">    [db executeUpdateWithFormat:<span class="string">@"update Device set deviceStatus = %d where deviceID = %@"</span>, <span class="number">1</span>, device1];</span><br></pre></td></tr></table></figure></p>
<h3>查询数据</h3>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">    FMResultSet *resultSet = [db executeQuery:<span class="string">@"select * from Device"</span>];</span><br><span class="line">    <span class="keyword">while</span> ([resultSet next]) &#123;</span><br><span class="line">        <span class="keyword">int</span> type = [resultSet intForColumn:<span class="string">@"deviceType"</span>];</span><br><span class="line">        <span class="keyword">int</span> status = [resultSet intForColumn:<span class="string">@"deviceStatus"</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *name = [resultSet objectForColumnName:<span class="string">@"deviceName"</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *<span class="keyword">id</span> = [resultSet objectForColumnName:<span class="string">@"deviceID"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"type = %d , status = %d, name = %@, id = %@"</span>, type, status, name, <span class="keyword">id</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，FMDB的常用操作就已经讲完了，后面还会补上FMDB的多线程操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/20/iOS开发——FMDB的使用/" data-id="cjptr3x4p001xlyz9qodrlt8r" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FMDB/">FMDB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLite/">SQLite</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——Debug-CUICatalog-Invalid-asset-name-supplied-null" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/13/iOS开发——Debug-CUICatalog-Invalid-asset-name-supplied-null/" class="article-date">
  <time datetime="2016-10-13T02:48:40.000Z" itemprop="datePublished">2016-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/13/iOS开发——Debug-CUICatalog-Invalid-asset-name-supplied-null/">iOS开发——Debug CUICatalog: Invalid asset name supplied: (null)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>今天看到了一个Xcode log出了一个错误 <code>CUICatalog:Invalid asset name supplied: (null)</code>, Google了一下在StackOverflow上各位大神说应该是<code>[UIImage imageNamed:]</code>调用的时候, name为nil. 虽然在运行的时候界面一切正常, 但是看到这个log还是想干掉它，或许每个程序猿都是一个重度强迫症患者。</p>
<p>&lt;!--more--&gt;</p>
<p>需要解决的问题是查找所有<code>[UIImage imageNamed:]</code>调用的时候, 找到name是nil的地方, 但是整个项目一搜 <code>imageNamed</code> 显示 <code>267 results in 117 files</code>, 人工查找就算了吧,麻烦不说还显得蠢.</p>
<p>一开始想到的是用Method Swizzle来修改<code>[UIImage imageNamed:]</code>的实现, 在name为nil的时候用断言, 查看调用栈. 但是想想写了debug之后还得删掉, 比较麻烦.</p>
<p>于是机智的我想到了用<code>Symbolic Breakpoint</code>.</p>
<ul>
<li>
<p>在Xcode的<code>Breakpoint Navigator</code>点击加号, 选择<code>Add Symbolic Breakpoint.</code></p>
</li>
<li>
<p>右键选择<code>Breakpoint</code>选择 <code>Edit Breakpoint</code> , 在Symbol填入<code>[UIImage imageNamed:]</code> , 在Condition填入 <code>[(NSString *)$arg3 length] == 0</code>或者<code>$arg3 == nil</code>. 可以自己尝试<code>po $arg1</code>, <code>po $arg2</code>试试看.</p>
</li>
</ul>
<p><img src="http://i.stack.imgur.com/ATz38.png" alt=""></p>
<ul>
<li>运行程序, 直到程序进入断点. 打开<code>Debug Navigator</code>观察调用栈, 最顶部的一定是<code>[UIImage imageNamed:]</code>, 点击调用栈下一条, 能够看到有调用到<code>imageNamed</code>的代码, 就是<code>name</code>为<code>nil</code>的地方.</li>
</ul>
<p><img src="http://philcai.com/img/Debug2.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/13/iOS开发——Debug-CUICatalog-Invalid-asset-name-supplied-null/" data-id="cjptr3x4o001wlyz9n75gbsna" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Debug/">Debug</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——UINavigationBar中踩过的坑" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/08/iOS开发——UINavigationBar中踩过的坑/" class="article-date">
  <time datetime="2016-10-08T07:09:44.000Z" itemprop="datePublished">2016-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/08/iOS开发——UINavigationBar中踩过的坑/">iOS开发——UINavigationBar中踩过的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这段时间的一直在忙于编码，加上国庆假期等等时间，又有很长时间没有写过博客了。</p>
<p>自从升级了Xcode8，以及在做iOS10的适配工作中，我发现在NavigationBar这个控件中，有了一个小小的坑。</p>
<p>因为在iOS7之后，NavigationBar之后，默认有一条1px的细线，这条细线怎么去，我在这里就不赘述了，因为谷歌上以及StackOverflow上有太多的方法去除这条细线。但是我这次发现，在我升级到iOS10之后，iOS10的设备中虽然使用了以前的方法，但是还是出现了这个细线，但是iOS10以下的设备这条细线还是不存在的。</p>
<p>&lt;!--more--&gt;</p>
<p>于是我自己得出了这么个结论，之前去除NavigationBar的这条细线的方法失效了（这里并不是说所有方法失效，至少我使用的方法是失效的），那么在发现自己有这个问题的时候，不妨可以来换一种方法实现隐藏NavigationBar底下的这条细线。</p>
<p>我把我的新方法，写成了Category，这里直接贴代码出来吧。</p>
<p>头文件中的方法声明</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NavigationBar底部隐藏1px的线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)lix_hideBottomHairline;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NavigationBar底部显示1px的线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)lix_showBottomHairline;</span><br></pre></td></tr></table></figure></p>
<p>方法的实现</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lix_hideBottomHairline &#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *navBarHairlineImageView = [<span class="keyword">self</span> findHairlineImageViewUnder:<span class="keyword">self</span>];</span><br><span class="line">    navBarHairlineImageView.hidden = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lix_showBottomHairline &#123;</span><br><span class="line">    <span class="comment">// Show 1px hairline of translucent nav bar</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *navBarHairlineImageView = [<span class="keyword">self</span> findHairlineImageViewUnder:<span class="keyword">self</span>];</span><br><span class="line">    navBarHairlineImageView.hidden = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)findHairlineImageViewUnder:(<span class="built_in">UIView</span> *)view &#123;</span><br><span class="line">    <span class="keyword">if</span> ([view isKindOfClass:<span class="built_in">UIImageView</span>.class] &amp;&amp; view.bounds.size.height &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">UIImageView</span> *)view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = [<span class="keyword">self</span> findHairlineImageViewUnder:subview];</span><br><span class="line">        <span class="keyword">if</span> (imageView) &#123;</span><br><span class="line">            <span class="keyword">return</span> imageView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简简单单，就可以随意切换NavigationBar底部线条的隐藏和显示，这样的代码可扩展性更好。</p>
<p>既然讲到这里了，那就干脆把NavigationBar如何变成透明的这点也讲完好了。</p>
<p>有时候，我们希望形成一个透明的NavigationBar，而不是像系统一样存在一个毛玻璃的效果，所以这时候我们应该如下设置NavigationBar</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lix_makeTransparent &#123;</span><br><span class="line">    [<span class="keyword">self</span> setTranslucent:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span> setBackgroundImage:[[<span class="built_in">UIImage</span> alloc] init] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">    <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="keyword">self</span>.shadowImage = [<span class="built_in">UIImage</span> new];    <span class="comment">// Hides the hairline</span></span><br><span class="line">    [<span class="keyword">self</span> lix_hideBottomHairline];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要恢复默认，则如下设置</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)lix_makeDefault &#123;</span><br><span class="line">    [self setTranslucent:YES];</span><br><span class="line">    [self setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault];</span><br><span class="line">    self.backgroundColor = nil;</span><br><span class="line">    self.shadowImage = nil;    // Hides the hairline</span><br><span class="line">    [self lix_showBottomHairline];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就组成了整个NavigationBar的category，希望大家能在自己的项目中灵活运用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/08/iOS开发——UINavigationBar中踩过的坑/" data-id="cjptr3x4t0026lyz9wf2lfuq0" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UINavigationBar/">UINavigationBar</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——Carthage安装和使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/22/iOS开发——Carthage安装和使用教程/" class="article-date">
  <time datetime="2016-09-22T01:53:26.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/iOS开发——Carthage安装和使用教程/">iOS开发——Carthage安装和使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1>Carthage是什么？</h1>
<p>Carthage 使用于 Swift 语言编写，只支持动态框架，只支持 iOS8+的Cocoa依赖管理工具。</p>
<p>与现在流行的 CocoaPods 不同，Carthage编译你的依赖，并提供框架的二进制.framework文件，但你仍然保留对项目的结构和设置的完整控制，Carthage不会自动的修改你的项目文件或编译设置。是一个去中心化的Cocoa依赖管理工具</p>
<p>&lt;!--more--&gt;</p>
<h1>如何下载和安装Carthage？</h1>
<h2>使用Brew安装(建议)</h2>
<ol>
<li>安装Mac OSX流行的的软件包管理工具Homebrew之前要检查Mac中是否有Ruby环境,目前的版本基本都内置了Ruby,终端输入</li>
</ol>
<p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure></p>
<p>显示类似 ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15]</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew -v</span><br></pre></td></tr></table></figure></p>
<p>显示类似文本 Homebrew 0.9.9 (git revision 2f20; last commit 2016-05-15) 说明已经安装brew不需要再次安装</p>
<ol start="2">
<li>如果电脑中没有Homebrew,终端执行脚本安装即可</li>
</ol>
<p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>每次使用 Homebrew 进行安装Carthage 或者其他软件之前,习惯性的先对Homebrew进行更新一下, 不然可能会安装到比较老版本的Carthage等软件</li>
</ol>
<p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure></p>
<p>提示 Already up-to-date.......  更新到最新啦!!</p>
<ol start="4">
<li>假如你在本地已经安装好Homebrew环境，那么下载和安装carthage将十分简单，只需要一行命令。</li>
</ol>
<p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install carthage</span><br></pre></td></tr></table></figure></p>
<h2>PKG文件安装</h2>
<p>直接下载pkg文件：<a href="https://github.com/Carthage/Carthage/releases" target="_blank" rel="noopener">https://github.com/Carthage/Carthage/releases</a> 进行安装即可</p>
<h1>如何使用Carthage？</h1>
<p>包管理工具,不管是CocoaPods,还是Node 的NPM,配置依赖管理都是在工程目录,建立相应的配置文件,Carthage的配置文件即 Cartfile文件</p>
<h2>添加 Cartfile 文件 (需要提交到 Git)</h2>
<p>建立添加Cartfile（配置文件）文件在</p>
<p>通过终端或者文本编辑器 进入到项目所在的文件夹建立一个 空的Cartfile文件</p>
<p>现在只支持GitHub库(GitHub.com和GitHub企业),指定GitHub的关键字:</p>
<p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github <span class="string">"ReactiveCocoa/ReactiveCocoa"</span> <span class="comment"># GitHub.com</span></span><br><span class="line">github <span class="string">"https://enterprise.local/ghe/desktop/git-error-translations"</span> <span class="comment"># GitHub Enterprise</span></span><br></pre></td></tr></table></figure></p>
<p>或者是其他git源,指定git关键词:</p>
<p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="string">"https://enterprise.local/desktop/git-error-translations2.git"</span></span><br></pre></td></tr></table></figure></p>
<p>其他可能的源在未来也会会被添加</p>
<h2>版本指定</h2>
<p>Carthage 支持以下几种版本指定方法:</p>
<ol>
<li><code>&gt;= 1.0</code> 代表 “最低 1.0版本”</li>
<li><code>~&gt; 1.0</code> 代表 “表示使用版本1.0以上但是低于2.0的最新版本，如1.5, 1.9”</li>
<li><code>== 1.0</code> 代表 “必须是 1.0 版本”</li>
<li><code>&quot;some-branch-or-tag-or-commit&quot;</code>指定一个 Git 对象 (任何被 <code>git rev-parse</code> 允许的)</li>
</ol>
<p>如果没有版本要求,任何版本的依赖是允许的。</p>
<p>版本好的兼容性是根据语语义化版本控制决定的。这意味着任何大于或等于1.5.1版本,但小于2.0,将认为与1.5.1“兼容”。</p>
<h2>Cartfile示例</h2>
<p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Require <span class="keyword">version</span> <span class="number">2.3</span>.<span class="number">1</span> <span class="built_in">or</span> <span class="keyword">later</span> 最低<span class="number">2.3</span>.<span class="number">1</span>版本</span><br><span class="line">github <span class="string">"ReactiveCocoa/ReactiveCocoa"</span> &gt;= <span class="number">2.3</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Require <span class="keyword">version</span> <span class="number">1</span>.<span class="keyword">x</span>   必须<span class="number">1</span>.<span class="keyword">x</span>版本</span><br><span class="line">github <span class="string">"Mantle/Mantle"</span> ~&gt; <span class="number">1.0</span>    # (大于或等于 <span class="number">1.0</span> ，小于 <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"># Require exactly <span class="keyword">version</span> <span class="number">0.4</span>.<span class="number">1</span> 必须<span class="number">0.4</span>.<span class="number">1</span>版本</span><br><span class="line">github <span class="string">"jspahrsummers/libextobjc"</span> == <span class="number">0.4</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Use the latest <span class="keyword">version</span>  使用最新版本</span><br><span class="line">github <span class="string">"jspahrsummers/xcconfigs"</span></span><br><span class="line"></span><br><span class="line"># Use the branch  使用git分支</span><br><span class="line">github <span class="string">"jspahrsummers/xcconfigs"</span> <span class="string">"branch"</span></span><br><span class="line"></span><br><span class="line"># Use <span class="keyword">a</span> project from GitHub Enterprise  使用一个企业项目，在 <span class="string">"development"</span> 分支</span><br><span class="line">github <span class="string">"https://enterprise.local/ghe/desktop/git-error-translations"</span></span><br><span class="line"></span><br><span class="line"># Use <span class="keyword">a</span> project from any arbitrary server, <span class="keyword">on</span> the <span class="string">"development"</span> branch  使用一个私有项目，在 <span class="string">"development"</span> 分支</span><br><span class="line">git <span class="string">"https://enterprise.local/desktop/git-error-translations2.git"</span> <span class="string">"development"</span></span><br><span class="line"></span><br><span class="line"># Use <span class="keyword">a</span> local project   使用一个本地的项目</span><br><span class="line">git <span class="string">"file:///directory/to/project"</span> <span class="string">"branch"</span></span><br></pre></td></tr></table></figure></p>
<h2>安装依赖 just do it</h2>
<p>执行以下命令 拉取指定版本代码并编译为 .Framework 文件</p>
<p>内部工作流程即  carthage update =&gt; carthage checkout =&gt; checkout build</p>
<p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">carthage <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<p>只编译iOS平台的类库</p>
<p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">carthage <span class="keyword">update</span> --platform iOS</span><br></pre></td></tr></table></figure></p>
<p>结果如下,(PS我只留了一个Mantle依赖)</p>
<p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Jakey-Pro:test jakey$ carthage <span class="keyword">update</span></span><br><span class="line">*** Fetching Mantle</span><br><span class="line">*** Checking out Mantle at <span class="string">"1.5.7"</span></span><br><span class="line">*** xcodebuild output can <span class="keyword">be</span> found in /var/folders/<span class="keyword">sm</span>/b5fssgjx147b722vsgx20mg00000gn/T/carthage-xcodebuild.b3IHTG.<span class="built_in">log</span></span><br><span class="line">*** Building scheme <span class="string">"Mantle Mac"</span> in Mantle.xcworkspace</span><br><span class="line"></span><br><span class="line">...balabala</span><br></pre></td></tr></table></figure></p>
<p>工程目录多了以下文件</p>
<p><img src="http://www.skyfox.org/wp-content/uploads/2016/05/C888B12C-6500-4B6F-B7BE-075379FD5E95.jpg" alt=""></p>
<h2>Cartfile.resolved (需要提交到 Git)</h2>
<p>在执行 carthage update 命令后会在根目录创建一个 Cartfile.resolved 文件，这个文件是生成后的依赖关系，不能修改。</p>
<p>Cartfile.resolved 文件确保提交的项目可以使用完全相同的配置与方式运行启用。 跟踪项目当前所用的依赖版本号，保持多端开发一致,出于这个原因,强烈建议提交这个文件到版本控制中。</p>
<h2>自动生成的Carthage目录 (不需要提交到 Git)</h2>
<p>Carthage文件夹用来存放:</p>
<p>carthage checkout 从git拉取的依赖库源文件(Checkouts)</p>
<p>carthage build编译后的文件(Build),包含Mac 与 iOS对应的.framework</p>
<h2>引入 .Framework 动态库的方法</h2>
<p>1 . 手动拖拽Build中的所有依赖.framework到你的工程,本人的建议当然是在工程根目录建立&quot;Vendor&quot;类似文件夹,创建&quot;Vendor&quot; folder/group到工程,所有第三方 .Framework都拷贝到此目录下,然后继续以下操作</p>
<p><img src="http://www.skyfox.org/wp-content/uploads/2016/05/A5A69D07-3A4F-49EC-A1BB-8BF087C669D6.jpg" alt=""></p>
<ul>
<li>打开项目，点击project，选择target, 再选择上方的General，将需要的framework文件拖到 Embedded  Binaries(动态库)内</li>
</ul>
<p>注意:动态库拷贝到Embedded  Binarie会同时自动加入到Linked Frameworks and Libraries,但是错误的拖入到Linked Frameworks and Libraries是不会自动增加到Embedded  Binarie中的,会导致动态库加载失败</p>
<p>2 . 在对应 Target 中的 Build Setting 中的 Framework Search Path 项加入以下路径，Xcode 便会自动搜索目录下的 Framework：</p>
<p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(PROJECT_DIR)/Carthage/Build/iOS</span><br></pre></td></tr></table></figure></p>
<h1>Git 中忽略不需要提交到版本库的文件与文件夹</h1>
<p>则修改 .gitignore 文件，增加忽略 Carthage 文件夹就行了：</p>
<p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Carthage</span><br><span class="line">Carthage</span><br></pre></td></tr></table></figure></p>
<h1>总结</h1>
<p>本人在实际项目中迟迟没有使用CocoaPods的原因就是,啰里啰嗦...对原有工程破坏性大(建立workspace,增加一堆乱七八糟的文件),侵入性太强,耦合太高,Carthage的出现的确是茉莉花香扑鼻而至!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/22/iOS开发——Carthage安装和使用教程/" data-id="cjptr3x4n001tlyz9hzaboofh" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Carthage/">Carthage</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-AES加密——Java与iOS的解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/AES加密——Java与iOS的解决方案/" class="article-date">
  <time datetime="2016-09-21T09:16:48.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/AES加密——Java与iOS的解决方案/">AES加密——Java与iOS的解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>维基百科中对AES加密的解释是这样的：</p>
<blockquote>
<p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
</blockquote>
<p>&lt;!--more--&gt;</p>
<p>该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijndael为名投稿高级加密标准的甄选流程。（Rijndael的发音近于&quot;Rhine doll&quot;）</p>
<p>严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中两者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128 比特，密钥长度则可以是128，192或256比特；而Rijndael使用的密钥和区块长度可以是32位的整数倍，以128位为下限，256比特为上限。加密过程中使用的密钥是由Rijndael密钥生成方案产生。</p>
<p>大多数AES计算是在一个特别的有限域完成的。</p>
<p>AES加密过程是在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。（Rijndael加密法因支持更大的区块，其矩阵行数可视情况增加）加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤：</p>
<ol>
<li>
<p>AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。</p>
</li>
<li>
<p>SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。</p>
</li>
<li>
<p>ShiftRows—将矩阵中的每个横列进行循环式移位。</p>
</li>
<li>
<p>MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey替换。</p>
</li>
</ol>
<p><strong>而如今，移动端在和后端约定使用AES加密方式加密后，总会碰到一些问题，今天我就用iOS端和Java端为例子，讲解移动端和后端的AES加密方法。</strong></p>
<p>首先，我们选用AES加密方式时，要先确定<strong>mode加密模式</strong>以及<strong>pad填充方式</strong>，而在这个项目中我选择了<strong>CBC加密模式</strong>以及<strong>PKCS5填充方式</strong>,并且使用了<strong>AES+Base64</strong>数据混合加密与解密。</p>
<p>这些模式以及填充方式的选择，在我们的代码中会有体现。</p>
<h2>iOS平台的AES加密</h2>
<p>首先我们先创建一个<strong>NSData类</strong>的<strong>category</strong>。并且引用头文件</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;CommonCrypto/CommonCryptor.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>单纯使用AES加密解密的代码如下</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(key和iv向量这里是16位的) 这里是CBC加密模式，安全性更高</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSData</span> *)AES128EncryptWithKey:(<span class="built_in">NSString</span> *)key gIv:(<span class="built_in">NSString</span> *)Iv&#123;<span class="comment">//加密</span></span><br><span class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128+<span class="number">1</span>];</span><br><span class="line">    bzero(keyPtr, <span class="keyword">sizeof</span>(keyPtr));</span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> ivPtr[kCCKeySizeAES128+<span class="number">1</span>];</span><br><span class="line">    memset(ivPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ivPtr));</span><br><span class="line">    [Iv getCString:ivPtr maxLength:<span class="keyword">sizeof</span>(ivPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = [<span class="keyword">self</span> length];</span><br><span class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    size_t numBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES128,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          keyPtr,</span><br><span class="line">                                          kCCBlockSizeAES128,</span><br><span class="line">                                          ivPtr,</span><br><span class="line">                                          [<span class="keyword">self</span> bytes],</span><br><span class="line">                                          dataLength,</span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize,</span><br><span class="line">                                          &amp;numBytesEncrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesEncrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    free(buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AES解密</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)AES128DecryptWithKey:(<span class="built_in">NSString</span> *)key gIv:(<span class="built_in">NSString</span> *)Iv &#123;</span><br><span class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128+<span class="number">1</span>];</span><br><span class="line">    bzero(keyPtr, <span class="keyword">sizeof</span>(keyPtr));</span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> ivPtr[kCCKeySizeAES128+<span class="number">1</span>];</span><br><span class="line">    memset(ivPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ivPtr));</span><br><span class="line">    [Iv getCString:ivPtr maxLength:<span class="keyword">sizeof</span>(ivPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = [<span class="keyword">self</span> length];</span><br><span class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    size_t numBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES128,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          keyPtr,</span><br><span class="line">                                          kCCBlockSizeAES128,</span><br><span class="line">                                          ivPtr,</span><br><span class="line">                                          [<span class="keyword">self</span> bytes],</span><br><span class="line">                                          dataLength,</span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize,</span><br><span class="line">                                          &amp;numBytesDecrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesDecrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    free(buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而我们之前说了，这里是需要用<strong>AES+Base64</strong>数据混合加密与解密。</p>
<p>那么之后一个完整详细的加密过程是怎么样的呢。</p>
<p>来看接下来的代码</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - AES加密</span></span><br><span class="line"><span class="comment">//将string转成带密码的data</span></span><br><span class="line">+(<span class="built_in">NSString</span>*)neu_encryptAESData:(<span class="built_in">NSString</span>*)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将nsstring转化为nsdata</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">//使用密码对nsdata进行加密</span></span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = [data AES128EncryptWithKey:KEY gIv:Iv];</span><br><span class="line">    <span class="comment">//返回进行base64进行转码的加密字符串</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> encodeBase64Data:encryptedData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是我们使用的加密方法，注释很详细，当然了 <code>- encodeBase64Data:</code> 方法是我已经封装好了的，到时候下载的时候拿出来用就好了。</p>
<p>所以在我们加密解密时，只要去调用<code>+(NSString*)neu_encryptAESData:(NSString*)string</code> 这个方法就可以了，是不是其实非常简洁方便呢。 解密的代码我也贴一下，是一样简单的。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#pragma mark - AES解密</span></span><br><span class="line"><span class="comment">//将带密码的data转成string</span></span><br><span class="line">+(<span class="built_in">NSString</span>*)neu_decryptAESData:(<span class="built_in">NSString</span> *)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//base64解密</span></span><br><span class="line">    <span class="built_in">NSData</span> *decodeBase64Data=[NEUBase64 decodeString:string];</span><br><span class="line">    <span class="comment">//使用密码对data进行解密</span></span><br><span class="line">    <span class="built_in">NSData</span> *decryData = [decodeBase64Data AES128DecryptWithKey:KEY gIv:Iv];</span><br><span class="line">    <span class="comment">//将解了密码的nsdata转化为nsstring</span></span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithData:decryData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>iOS平台的AES加密到这里就结束了。</p>
<h2>Java平台的AES加密</h2>
<p>Java平台的加密解密，所有的配置和原理和iOS端都是一样的，所以我就偷懒了，直接把Java端的代码贴上来了。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Lix on 16/9/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 加密用的Key 可以用26个字母和数字组成 此处使用AES-128-CBC加密模式，key需要为16位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sKey = <span class="string">"ed16b1f8a9e648d4"</span>;</span><br><span class="line">    <span class="keyword">private</span> String ivParameter = <span class="string">"ed16b1f8a9e648d4"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AESOperator instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AESOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AESOperator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> AESOperator();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Encrypt</span><span class="params">(String encData ,String secretKey,String vector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(secretKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(secretKey.length() != <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] raw = secretKey.getBytes();</span><br><span class="line">        SecretKeySpec skeySpec = <span class="keyword">new</span> SecretKeySpec(raw, <span class="string">"AES"</span>);</span><br><span class="line">        IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(vector.getBytes());<span class="comment">// 使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = cipher.doFinal(encData.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BASE64Encoder().encode(encrypted);<span class="comment">// 此处使用BASE64做转码。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String sSrc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] raw = sKey.getBytes();</span><br><span class="line">        SecretKeySpec skeySpec = <span class="keyword">new</span> SecretKeySpec(raw, <span class="string">"AES"</span>);</span><br><span class="line">        IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(ivParameter.getBytes());<span class="comment">// 使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = cipher.doFinal(sSrc.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BASE64Encoder().encode(encrypted);<span class="comment">// 此处使用BASE64做转码。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String sSrc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] raw = sKey.getBytes(<span class="string">"ASCII"</span>);</span><br><span class="line">            SecretKeySpec skeySpec = <span class="keyword">new</span> SecretKeySpec(raw, <span class="string">"AES"</span>);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">            IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(ivParameter.getBytes());</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);</span><br><span class="line">            <span class="keyword">byte</span>[] encrypted1 = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(sSrc);<span class="comment">// 先用base64解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] original = cipher.doFinal(encrypted1);</span><br><span class="line">            String originalString = <span class="keyword">new</span> String(original, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="keyword">return</span> originalString;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String sSrc,String key,String ivs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] raw = key.getBytes(<span class="string">"ASCII"</span>);</span><br><span class="line">            SecretKeySpec skeySpec = <span class="keyword">new</span> SecretKeySpec(raw, <span class="string">"AES"</span>);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">            IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(ivs.getBytes());</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);</span><br><span class="line">            <span class="keyword">byte</span>[] encrypted1 = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(sSrc);<span class="comment">// 先用base64解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] original = cipher.doFinal(encrypted1);</span><br><span class="line">            String originalString = <span class="keyword">new</span> String(original, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="keyword">return</span> originalString;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeBytes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        StringBuffer strBuf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            strBuf.append((<span class="keyword">char</span>) (((bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>) + ((<span class="keyword">int</span>) <span class="string">'a'</span>)));</span><br><span class="line">            strBuf.append((<span class="keyword">char</span>) (((bytes[i]) &amp; <span class="number">0xF</span>) + ((<span class="keyword">int</span>) <span class="string">'a'</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strBuf.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 需要加密的字串</span></span><br><span class="line">        String cSrc = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">long</span> lStart = System.currentTimeMillis();</span><br><span class="line">        String enString = AESOperator.getInstance().encrypt(cSrc);</span><br><span class="line">        System.out.println(<span class="string">"加密后的字串是："</span> + enString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lUseTime = System.currentTimeMillis() - lStart;</span><br><span class="line">        System.out.println(<span class="string">"加密耗时："</span> + lUseTime + <span class="string">"毫秒"</span>);</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        lStart = System.currentTimeMillis();</span><br><span class="line">        String DeString = AESOperator.getInstance().decrypt(enString);</span><br><span class="line">        System.out.println(<span class="string">"解密后的字串是："</span> + DeString);</span><br><span class="line">        lUseTime = System.currentTimeMillis() - lStart;</span><br><span class="line">        System.out.println(<span class="string">"解密耗时："</span> + lUseTime + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java端和iOS端的代码,<a href="https://github.com/originalix/iOS-and-Java-AES-Cryptor.git" target="_blank" rel="noopener">都在这里</a>，希望对您有帮助的可以Star一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/AES加密——Java与iOS的解决方案/" data-id="cjptr3x8f00drlyz9p6itwajp" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AES加密/">AES加密</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发-——-ReactiveCocoa详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/11/iOS开发-——-ReactiveCocoa详解/" class="article-date">
  <time datetime="2016-09-11T05:41:53.000Z" itemprop="datePublished">2016-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/11/iOS开发-——-ReactiveCocoa详解/">iOS开发 —— ReactiveCocoa详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近一直在研究<strong>ReactiveCocoa</strong>，现在也来讲讲<strong>ReactiveCocoa</strong>中一些基础类的作用。</p>
<h1>ReactiveCocoa作用</h1>
<p>在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。比如按钮的点击使用<code>action</code>，<code>ScrollView</code>滚动使用<code>delegate</code>，属性值改变使用<strong>KVO</strong>等系统提供的方式。其实这些事件，都可以通过<strong>RAC</strong>处理。</p>
<p>&lt;!--more--&gt;</p>
<h1><strong>RACSiganl</strong></h1>
<p><strong>RACSiganl:</strong> 信号类,只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</p>
<p><strong>RACSubscriber:</strong> 表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过<strong>create</strong>创建的信号，都有一个订阅者，帮助他发送数据</p>
<p><strong>RACDisposable:</strong> 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line">   RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       <span class="comment">//block调用时刻：每当有订阅者订阅信号，就会调用block</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.发送信号</span></span><br><span class="line">       [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//如果不再发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅</span></span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">           <span class="comment">//block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block，取消订阅</span></span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"信号被销毁"</span>);</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.订阅信号</span></span><br><span class="line">   [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">       <span class="comment">//block调用时刻：每当有信号发送数据，就会调用该方法</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"接收到的数据：%@"</span>,x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></p>
<h1>RACSubject与RACReplaySubject</h1>
<p><strong>RACSubject:<strong>信号提供者，自己可以充当信号，又能发送信号。<strong>subject</strong>可以想成是</strong>signal</strong>的变体，就像<strong>NSMutableArray</strong>相对于<strong>NSArray</strong>一样。它们是非<strong>RAC</strong>的代码和<strong>RAC</strong>代码之间的桥梁。</p>
<p>**RACReplaySubject:**重复提供信号类，<strong>RACSubject</strong>的子类。</p>
<p><strong>RACReplaySubject</strong>与<strong>RACSubject</strong>区别:</p>
<ul>
<li>
<p><strong>RACReplaySubject</strong>可以先发送信号，再订阅信号，<strong>RACSubject</strong>就不可以。</p>
</li>
<li>
<p><strong>RACReplaySubject</strong>可以设置<strong>capacity</strong>数量来限制缓存的<strong>value</strong>的数量,即只缓充最新的几个值。</p>
</li>
<li>
<p>如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，就需要使用<strong>RACReplaySubject</strong></p>
</li>
</ul>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line"> RACSubject *subject = [RACSubject subject];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//2.订阅信号</span></span><br><span class="line"> [subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     <span class="comment">//block调用时刻：当信号发出新值，就会调用</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</span><br><span class="line"> &#125;];</span><br><span class="line"> [subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     <span class="comment">//block调用时刻：当信号发出新值，就会调用</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//3.发送信号</span></span><br><span class="line"> [subject sendNext:<span class="string">@"1"</span>];</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//1.创建信号</span></span><br><span class="line"> RACReplaySubject *replaySubject = [RACReplaySubject subject];</span><br><span class="line"><span class="comment">// RACReplaySubject *replaySubject = [RACReplaySubject replaySubjectWithCapacity:0];</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//2.发送信号</span></span><br><span class="line"> [replaySubject sendNext:@<span class="number">1</span>];</span><br><span class="line"> [replaySubject sendNext:@<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//3.订阅信号</span></span><br><span class="line"> [replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</span><br><span class="line"> &#125;];</span><br><span class="line"> [replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure></p>
<h2><strong>RACSubject</strong>替代代理</h2>
<p>情景：跳转到另一个ViewController，TwoViewController发送通知，ViewController收到回调的通知</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//ViewController里</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)click:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line"></span><br><span class="line">    TwoViewController *twoVC = [[TwoViewController alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置代理信号</span></span><br><span class="line">    twoVC.delegateSubject = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅代理信号</span></span><br><span class="line">    [twoVC.delegateSubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"点击了通知按钮，%@"</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跳转</span></span><br><span class="line">    [<span class="keyword">self</span> presentViewController:twoVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TwoViewConrroller里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegateSubject) &#123;</span><br><span class="line">        <span class="comment">//发送信号</span></span><br><span class="line">        [<span class="keyword">self</span>.delegateSubject sendNext:<span class="string">@"已跳转到TwoVC"</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1>遍历数组字典、字典转模型</h1>
<p><strong>RACTuple:<strong>元组类,类似</strong>NSArray</strong>,用来包装值.</p>
<p><strong>RACSequence:</strong> RAC中的集合类，用于代替<strong>NSArray</strong>,<strong>NSDictionary</strong>,可以使用它来快速遍历数组和字典。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//第一步: 把数组转换成集合RACSequence             numbers.rac_sequence</span></span><br><span class="line"><span class="comment">// 第二步: 把集合RACSequence转换RACSignal信号类    numbers.rac_sequence.signal</span></span><br><span class="line"><span class="comment">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。    </span></span><br><span class="line"><span class="comment">// 1.遍历数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *numbers = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>];</span><br><span class="line">[numbers.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"name"</span>:<span class="string">@"xiaoming"</span>,<span class="string">@"age"</span>:@<span class="number">18</span>&#125;;    </span><br><span class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></span><br><span class="line"><span class="comment">// 相当于以下写法</span></span><br><span class="line"><span class="comment">//        NSString *key = x[0];</span></span><br><span class="line"><span class="comment">//        NSString *value = x[1];</span></span><br><span class="line">[dict.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *name,<span class="built_in">NSString</span> *age) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,name,age);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<ul>
<li>字典转模型</li>
</ul>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.OC写法</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict1 = @&#123;<span class="string">@"name"</span>:<span class="string">@"xiaoming"</span>,<span class="string">@"age"</span>:@<span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">NSDictionary</span> *dict2 = @&#123;<span class="string">@"name"</span>:<span class="string">@"xiaohua"</span>,<span class="string">@"age"</span>:@<span class="number">20</span>&#125;;</span><br><span class="line"><span class="built_in">NSArray</span> *arrs = @[dict1,dict2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> arrs) &#123;</span><br><span class="line">    FlagItem *item = [FlagItem flagWithDict:dict];</span><br><span class="line">    [items addObject:item];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.RAC写法</span></span><br><span class="line">[arrs.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">//遍历RAC字典</span></span><br><span class="line">    FlagItem *item = [FlagItem flagWithDict:x];</span><br><span class="line">    [items addObject:item];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.高级RAC写法</span></span><br><span class="line"><span class="comment">// map:映射的意思，目的：把原始值value映射成一个新值</span></span><br><span class="line"><span class="comment">// array: 把集合转换成数组</span></span><br><span class="line"><span class="comment">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</span></span><br><span class="line"><span class="built_in">NSArray</span> *flags = [[arrs.rac_sequence map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [FlagItem flagWithDict:value];</span><br><span class="line"></span><br><span class="line">&#125;] array];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,flags);</span><br></pre></td></tr></table></figure></p>
<h1>RACCommand</h1>
<p>创建并订阅响应<strong>action</strong>的信号。 通常<strong>command</strong>是由<strong>UI</strong>触发的，像一个按钮被点击时。当<strong>command</strong>被触发时，控件会⾃自动被禁⽤。</p>
<p>有数据改变使用<strong>RACSignal</strong> 有事件处理需要<strong>RACCommand</strong></p>
<p><strong>RACCommand</strong>设计思想：内部<strong>signalBlock</strong>为什么要返回一个信号，这个信号有什么用。</p>
<ul>
<li>
<p>在RAC开发中，通常会把网络请求封装到<strong>RACCommand</strong>，直接执行某个<strong>RACCommand</strong>就能发送请求。</p>
</li>
<li>
<p>当<strong>RACCommand</strong>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过<strong>signalBlock</strong>返回的信号传递了。</p>
</li>
</ul>
<p>使用场景,监听按钮点击，网络请求</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.创建命令</span></span><br><span class="line"> RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"执行命令"</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// signalBlock必须要返回一个信号，不能传nil，如果不想要传递信号，直接创建空的信号。</span></span><br><span class="line">     <span class="comment">//return [RACSignal empty];</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//2.创建信号,用来传递数据</span></span><br><span class="line">     <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">         </span><br><span class="line">         [subscriber sendNext:<span class="string">@"请求数据"</span>];</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</span></span><br><span class="line">         [subscriber sendCompleted];</span><br><span class="line">     </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">     &#125;];</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</span></span><br><span class="line"> _command = command;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//3.订阅信号</span></span><br><span class="line"> [command.executionSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     </span><br><span class="line">     [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">     &#125;];</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//RAC高级用法：</span></span><br><span class="line"> <span class="comment">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号,不需要订阅信号</span></span><br><span class="line"> [command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//监听命令是否执行完毕，默认会来一次，可以直接跳过,skip表示跳过第一次命令</span></span><br><span class="line"> [[command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"正在执行"</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"执行完成"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//4.执行命令</span></span><br><span class="line"> [<span class="keyword">self</span>.command execute:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<h1>RACMulticastConnection</h1>
<p>用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的<strong>block</strong>，造成副作用，可以使用这个类处理。例如：当有2个<strong>RACSignal</strong>订阅信心的时候，就需要发送两次<strong>RACSiagnal</strong>的信号，执行两次<strong>block</strong>操作。而使用<strong>RACMulticastConnection</strong>连接，对<strong>signal pulish</strong>处理就不会多次创建。</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.创建信号a</span></span><br><span class="line">   RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2，创建连接</span></span><br><span class="line">   RACMulticastConnection *connect = [signal publish];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.订阅信号。即使订阅了，还没激活信号</span></span><br><span class="line">   [connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"订阅者第一信号"</span>);</span><br><span class="line">   &#125;];</span><br><span class="line">   [connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"订阅者第二信号"</span>);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//4.连接，激活信号</span></span><br><span class="line">   [connect connect];</span><br></pre></td></tr></table></figure></p>
<h1>ReactiveCocoa的其他用法</h1>
<ul>
<li>
<p>代替代理:<code>rac_signalForSelector:</code>用于替代代理。</p>
</li>
<li>
<p>代替KVO :<code>rac_valuesAndChangesForKeyPath:</code>用于监听某个对象的属性改变。</p>
</li>
<li>
<p>监听事件:<code>rac_signalForControlEvents:</code>用于监听某个事件。</p>
</li>
<li>
<p>代替通知:<code>rac_addObserverForName:</code>用于监听某个通知。</p>
</li>
<li>
<p>监听文本框文字改变:<code>rac_textSignal:</code>只要文本框发出改变就会发出这个信号。</p>
</li>
<li>
<p>处理当界面有多次请求时，需要都获取到数据时，才能展示界面</p>
</li>
<li>
<p><code>rac_liftSelector:withSignalsFromArray:Signals:</code>当传入的<strong>Signals</strong>(信号数组)，每一个<strong>signal</strong>都至少<strong>sendNext</strong>过一次，就会去触发第一个<strong>selector</strong>参数的方法。使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</p>
</li>
</ul>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1.代替代理</span></span><br><span class="line"><span class="comment">// 需求：自定义redView,监听红色view中按钮点击</span></span><br><span class="line"><span class="comment">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</span></span><br><span class="line"><span class="comment">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</span></span><br><span class="line"><span class="comment">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</span></span><br><span class="line">[[redV rac_signalForSelector:<span class="keyword">@selector</span>(btnClick:)] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击红色按钮"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 2.KVO</span></span><br><span class="line"><span class="comment">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</span></span><br><span class="line"><span class="comment">// observer:可以传入nil</span></span><br><span class="line">[[redV rac_valuesAndChangesForKeyPath:<span class="string">@"center"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">     </span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 3.监听事件</span></span><br><span class="line"><span class="comment">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</span></span><br><span class="line">[[<span class="keyword">self</span>.btn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"按钮被点击了"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 4.代替通知</span></span><br><span class="line"><span class="comment">// 把监听到的通知转换信号</span></span><br><span class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="built_in">UIKeyboardWillShowNotification</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"键盘弹出"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 5.监听文本框的文字改变</span></span><br><span class="line">[_textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文字改变了%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 6.处理多个请求，都返回结果的时候，统一做处理.</span></span><br><span class="line">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 发送请求1</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送请求1"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="comment">// 发送请求2</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送请求2"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</span></span><br><span class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新UI</span></span><br><span class="line">- (<span class="keyword">void</span>)updateUIWithR1:(<span class="keyword">id</span>)data r2:(<span class="keyword">id</span>)data1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"更新UI%@  %@"</span>,data,data1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/11/iOS开发-——-ReactiveCocoa详解/" data-id="cjptr3x8k00dxlyz9yiof9zze" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactiveCocoa/">ReactiveCocoa</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-iOS开发——全机型适配思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/25/iOS开发——全机型适配思路/" class="article-date">
  <time datetime="2016-08-25T07:57:47.000Z" itemprop="datePublished">2016-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/25/iOS开发——全机型适配思路/">iOS开发——全机型适配思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近一直在研究学习ReactiveCocoa，并且在给项目转型到MVVM模式打基础，所以博客也很久没有更新了。</p>
<p>今天打算跟大家聊聊最近研究的全机型适配思路。</p>
<p>&lt;!--more--&gt;</p>
<p>当前我们需要适配的iPhone机型有4s、5s、6s、6Plus四种机型。它们的尺寸分别是</p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iphone4s &#123;<span class="number">320</span>, <span class="number">480</span>&#125;     <span class="number">960</span>*<span class="number">640</span></span><br><span class="line">iphone5 <span class="number">5</span>s &#123;<span class="number">320</span>, <span class="number">568</span>&#125;     <span class="number">1136</span>*<span class="number">640</span></span><br><span class="line">iphone6 <span class="number">6</span>s   &#123;<span class="number">375</span>, <span class="number">667</span>&#125;    <span class="number">1334</span>*<span class="number">750</span></span><br><span class="line">iphone6Plus <span class="number">6</span>sPlus &#123;<span class="number">414</span>, <span class="number">736</span>&#125;  <span class="number">1920</span>*<span class="number">1080</span></span><br></pre></td></tr></table></figure></p>
<p>而一般我习惯在实际的项目开发中，使用<strong>Masonary</strong>来搭建<strong>UI</strong>界面，虽然在<strong>Masonary</strong>中我们能很方便的设置各个控件之间的约束，但是对于类似<strong>4s</strong>机型和<strong>6s Plus</strong>机型的很大的高度差，有时候仅仅靠一次性成型的约束还是搭建不出很合理的界面。</p>
<p>于是在这次搭建<strong>UI</strong>的过程中，我的一个思路就是按照比例，针对各个机型进行微调。思路如下:</p>
<ul>
<li>
<p>美工提供的效果图是基于<strong>iPhone6</strong>的效果图</p>
</li>
<li>
<p>而我只需要将标注上的每个尺寸去对比<strong>iPhone6</strong>换算出比例，这样一些间距就能按照不同机型尺寸的比例变得不一样。</p>
</li>
</ul>
<ul>
<li>针对考虑交互体验的控件，在保持尺寸不变的基础上，做细节微调。</li>
</ul>
<p>在具体的代码中，我封装出了一个类，定义了两个类方法专门去适配所有机型的高度和宽度。思路就是上述按不同机型针对于iPhone6的比例而适配。</p>
<p>代码我也贴一部分出来。</p>
<p><strong>头文件的定义</strong></p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, IPhoneType) &#123;</span><br><span class="line">    iPhone4Type = <span class="number">0</span>,</span><br><span class="line">    iPhone5Type,</span><br><span class="line">    iPhone6Type,</span><br><span class="line">    iPhone6PlusType</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CalculateLayout</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  基于UI设计的iPhone6设计图的全机型高度适配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param height View高度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return  CGFloat 适配后的高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)neu_layoutForAlliPhoneHeight:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  基于UI设计的iPhone6设计图的全机型宽度适配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param width 宽度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 适配后的宽度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)neu_layoutForAlliPhoneWidth:(<span class="built_in">CGFloat</span>)width;</span><br></pre></td></tr></table></figure></p>
<p><strong><code>.m</code>文件的部分如下:</strong></p>
<p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#define iPhone4Height (480.f)</span></span><br><span class="line"><span class="meta">#define iPhone4Width  (320.f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define iPhone5Height (568.f)</span></span><br><span class="line"><span class="meta">#define iPhone5Width  (320.f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define iPhone6Height (667.f)</span></span><br><span class="line"><span class="meta">#define iPhone6Width  (375.f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define iPhone6PlusHeight (736.f)</span></span><br><span class="line"><span class="meta">#define iPhone6PlusWidth  (414.f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 适配所有机型高度</span></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)neu_layoutForAlliPhoneHeight:(<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> layoutHeight = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="keyword">if</span> (iPhone4) &#123;</span><br><span class="line">        layoutHeight = ( height / iPhone6Height ) * iPhone4Height;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iPhone5) &#123;</span><br><span class="line">        layoutHeight = ( height / iPhone6Height ) * iPhone5Height;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iPhone6) &#123;</span><br><span class="line">        layoutHeight = ( height / iPhone6Height ) * iPhone6Height;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iPhone6P) &#123;</span><br><span class="line">        layoutHeight = ( height / iPhone6Height ) * iPhone6PlusHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layoutHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)neu_layoutForAlliPhoneWidth:(<span class="built_in">CGFloat</span>)width &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> layoutWidth = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="keyword">if</span> (iPhone4) &#123;</span><br><span class="line">        layoutWidth = ( width / iPhone6Width ) * iPhone4Width;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iPhone5) &#123;</span><br><span class="line">        layoutWidth = ( width / iPhone6Width ) * iPhone5Width;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iPhone6) &#123;</span><br><span class="line">        layoutWidth = ( width / iPhone6Width ) * iPhone6Width;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iPhone6P) &#123;</span><br><span class="line">        layoutWidth = ( width / iPhone6Width ) * iPhone6PlusWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layoutWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码我也已经放在了<a href="https://github.com/originalix/Layou-For-All-iPhone" target="_blank" rel="noopener">Github</a>上，如果这些对你有帮助，在clone代码之余能否给个star。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/25/iOS开发——全机型适配思路/" data-id="cjptr3x4t0028lyz9ic5p9avu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AutoLayout/">AutoLayout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/全机型适配/">全机型适配</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-CocoaPods导入的库其头文件导入的方法以及Pch预编译文件配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/CocoaPods导入的库其头文件导入的方法以及Pch预编译文件配置/" class="article-date">
  <time datetime="2016-08-02T02:09:13.000Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/CocoaPods导入的库其头文件导入的方法以及Pch预编译文件配置/">CocoaPods导入的库其头文件导入的方法以及Pch预编译文件配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1>CocoaPods 导入头文件</h1>
<p>尽管CocoaPods使用十分方便,但其导入的第三方框架还是要经过几步操作,才能供项目使用</p>
<p>&lt;!--more--&gt;</p>
<blockquote>
<p>第一步:导入库</p>
</blockquote>
<p>这里要讲的配置CocoaPods以及安装第三方库，之前的文章已经讲过，这里就不再赘述。</p>
<blockquote>
<p>第二步: 添加文件路径</p>
</blockquote>
<ul>
<li>选择工程的 Target -&gt; Build Settings 菜单-&gt;搜索header,找到&quot;User Header Search Paths&quot;;</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/105827-cc5c5d4a7c590039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>新增一个值&quot;$(PODS_ROOT)&quot;,并且选择”recursive”，这样Xcode就会在项目目录中递归搜索文件且会自动找到Pods文件,头文件自动补齐功能马上就好使了.</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/105827-ecb9f73eb55e5f32.png?imageMogr2/auto-orient/strip" alt=""></p>
<h1>Pch预编译文件配置</h1>
<p>[该步骤相当于在项目自动&quot;import&quot;头文件,是不是很方便.(该步骤可不用,但使用相当方便,建议使用)].</p>
<p>首先说一下pch的作用：</p>
<p>1.存放一些全局的宏(整个项目中都用得上的宏)</p>
<p>2.用来包含一些全部的头文件(整个项目中都用得上的头文件)</p>
<p>3.能自动打开或者关闭日志输出功能</p>
<ul>
<li>在工程的 TARGETS 里边 Building Setting 中搜索 Prefix Header，然后把 Precompile Prefix Header 右边的 NO 改为 Yes， 预编译后的pch文件会被缓存起来，可以提高编译速度</li>
</ul>
<ul>
<li>然后在 Precompile Prefix Header 下边的 Prefix Header 右边双击，添加刚刚创建的pch文件的工程路径，添加格式：<code>$(SRCROOT)/项目名称/pch文件名</code>  ，<code>$(SRCROOT)</code> 的意思就是工程根目录的意思。如果还不太清楚的话可以右键 pch 文件，然后show in finder</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150428202907251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ3JhenlaaGFuZzE5OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>上图中黄色圈出来的就是 <code>$(SRCROOT)</code>，也就是工程的根目录，然后后边还有一个 PchText 和 pch 两个文件夹，所以完整的 pch 文件的路径就是：<code>$(SRCROOT)/PchText/pch</code></p>
<p>添加完成后，点击Enter，他会自动帮你变成你工程所在的路径</p>
<p>可以了，编译一下程序，如果有错误检查一下添加的路径是否正确</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/02/CocoaPods导入的库其头文件导入的方法以及Pch预编译文件配置/" data-id="cjptr3x3l0006lyz91oyt2vwk" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pch预编译文件/">Pch预编译文件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-30DaysOfSwift-Day1-计时器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/01/30DaysOfSwift-Day1-计时器/" class="article-date">
  <time datetime="2016-08-01T09:17:49.000Z" itemprop="datePublished">2016-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/01/30DaysOfSwift-Day1-计时器/">30DaysOfSwift - Day1 计时器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>前几天逛Github，偶然看到一个<strong>Swift</strong>的项目 —— <strong>30DaysOfSwift</strong>,作者一共用30个小项目，来熟悉<strong>Swift</strong>语言，而我正好也学习了一段时间的<strong>Swift</strong>语言，准备仿照这样的模式，来更加深入的了解UI部分</p>
<p>今天做的是一个计时器项目，大概效果如下 :</p>
<p><img src="https://raw.githubusercontent.com/originalix/Lix30DaysOfSwift/master/Project-01/Simple%20Stop%20Watch.gif" alt=""></p>
<p>&lt;!--more--&gt;</p>
<p>作者在这个项目中，使用<strong>AutoLayout</strong>来完成自动布局，使用<strong>StoryBoard</strong>完成UI创建。</p>
<p>而我一直都是喜欢用纯代码布局，UI的搭建也是使用代码完成。所以我在写这个小Demo之前在我的项目里集成了<strong>SnapKit</strong>，使用类似<strong>Objective-C</strong>中常用的<strong>masonry</strong>框架来完成自动布局。</p>
<p>这里我还发现一个<strong>Swift</strong>中的小问题，使用<strong>cocoadPods</strong>集成第三方库，引用不到头文件的解决方法和<strong>Objective-C</strong>不一样。</p>
<p>这是第一个<strong>Swift</strong>小Demo，很简单，也很好的帮助熟悉UI.</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SnapKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">SCREEN_WIDTH</span> = <span class="type">UIScreen</span>.mainScreen().bounds.size.width</span><br><span class="line"><span class="keyword">let</span> <span class="type">SCREEN_HEIGHT</span> = <span class="type">UIScreen</span>.mainScreen().bounds.size.height</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kTopViewHeight = <span class="type">SCREEN_HEIGHT</span> * <span class="number">0.4</span> <span class="comment">//倒计时试图高度</span></span><br><span class="line"><span class="keyword">let</span> kButtonHeight = <span class="type">SCREEN_HEIGHT</span> * <span class="number">0.6</span>  <span class="comment">//开始暂停按钮高度</span></span><br><span class="line"><span class="keyword">let</span> kPauseButtonWidth = <span class="type">SCREEN_WIDTH</span> * <span class="number">0.4</span> <span class="comment">//暂停按钮宽度</span></span><br><span class="line"><span class="keyword">let</span> kStartButtonWidth = <span class="type">SCREEN_WIDTH</span> * <span class="number">0.6</span> <span class="comment">//开始按钮高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="type">NSTimer</span>()</span><br><span class="line"><span class="keyword">var</span> isPlaying = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MARK: - 懒加载</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒计时Label</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> showLabel: <span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>.zero)</span><br><span class="line">        label.text = <span class="type">String</span>(counter)</span><br><span class="line">        label.textColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">100</span>)</span><br><span class="line">        label.textAlignment = <span class="type">NSTextAlignment</span>.<span class="type">Center</span></span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//顶部背景试图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> topBackgroundView: <span class="type">UIView</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">SCREEN_WIDTH</span>, height: kTopViewHeight))</span><br><span class="line">        view.backgroundColor = <span class="type">UIColor</span>.blackColor()</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Reset按钮</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> resetButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: (<span class="type">UIButtonType</span>.<span class="type">Custom</span>))</span><br><span class="line">        button.frame = <span class="type">CGRectZero</span></span><br><span class="line">        button.setTitle(<span class="string">"Reset"</span>, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">        button.setTitleColor(<span class="type">UIColor</span>.whiteColor(), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">        button.setTitleColor(<span class="type">UIColor</span>.blackColor(), forState: <span class="type">UIControlState</span>.<span class="type">Highlighted</span>)</span><br><span class="line">        button.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">15</span>)</span><br><span class="line">        button.backgroundColor = <span class="type">UIColor</span>.clearColor()</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="string">"buttonDidClick:"</span>, forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</span><br><span class="line">        button.tag = <span class="number">101</span></span><br><span class="line">        <span class="keyword">return</span> button</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停按钮</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> pauseButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: (<span class="type">UIButtonType</span>.<span class="type">Custom</span>))</span><br><span class="line">        button.frame = <span class="type">CGRectZero</span></span><br><span class="line">        button.setImage(<span class="type">UIImage</span>(named: <span class="string">"pause"</span>), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">        button.backgroundColor = <span class="type">UIColor</span>.greenColor()</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="string">"buttonDidClick:"</span>, forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</span><br><span class="line">        button.tag = <span class="number">102</span></span><br><span class="line">        <span class="keyword">return</span> button</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始按钮</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> startButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: (<span class="type">UIButtonType</span>.<span class="type">Custom</span>))</span><br><span class="line">        button.frame = <span class="type">CGRectZero</span></span><br><span class="line">        button.setImage(<span class="type">UIImage</span>(named: <span class="string">"play"</span>), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br><span class="line">        button.backgroundColor = <span class="type">UIColor</span>.blueColor()</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="string">"buttonDidClick:"</span>, forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</span><br><span class="line">        button.tag = <span class="number">103</span></span><br><span class="line">        <span class="keyword">return</span> button</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK: - 创建UI界面</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//顶部的背景试图</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.topBackgroundView)</span><br><span class="line">        <span class="comment">// 显示倒计时的Label</span></span><br><span class="line">        <span class="keyword">self</span>.topBackgroundView.addSubview(<span class="keyword">self</span>.showLabel)</span><br><span class="line">        <span class="keyword">self</span>.showLabel.snp_makeConstraints &#123; make <span class="keyword">in</span></span><br><span class="line">            make.width.equalTo(<span class="type">SCREEN_WIDTH</span>)</span><br><span class="line">            make.height.equalTo(<span class="number">137</span>)</span><br><span class="line">            make.centerX.equalTo(<span class="keyword">self</span>.topBackgroundView.snp_centerX)</span><br><span class="line">            make.centerY.equalTo(<span class="keyword">self</span>.topBackgroundView.snp_centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Reset按钮</span></span><br><span class="line">        <span class="keyword">self</span>.topBackgroundView.addSubview(<span class="keyword">self</span>.resetButton)</span><br><span class="line">        <span class="keyword">self</span>.resetButton.snp_makeConstraints &#123; make <span class="keyword">in</span></span><br><span class="line">            make.top.equalTo(<span class="keyword">self</span>.topBackgroundView.snp_top).offset(<span class="number">20</span>)</span><br><span class="line">            make.<span class="keyword">right</span>.equalTo(<span class="keyword">self</span>.topBackgroundView.snp_right).offset(-<span class="number">20</span>)</span><br><span class="line">            make.height.equalTo(<span class="number">20</span>)</span><br><span class="line">            make.width.equalTo(<span class="number">60</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂停按钮</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.pauseButton)</span><br><span class="line">        <span class="keyword">self</span>.pauseButton.snp_makeConstraints &#123; make <span class="keyword">in</span></span><br><span class="line">            make.top.equalTo(<span class="keyword">self</span>.topBackgroundView.snp_bottom).offset(<span class="number">0</span>)</span><br><span class="line">            make.<span class="keyword">left</span>.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">0</span>)</span><br><span class="line">            make.height.equalTo(kButtonHeight)</span><br><span class="line">            make.width.equalTo(kPauseButtonWidth)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始按钮</span></span><br><span class="line">        <span class="keyword">self</span>.view .addSubview(<span class="keyword">self</span>.startButton)</span><br><span class="line">        <span class="keyword">self</span>.startButton.snp_makeConstraints &#123; make <span class="keyword">in</span></span><br><span class="line">            make.top.equalTo(<span class="keyword">self</span>.topBackgroundView.snp_bottom).offset(<span class="number">0</span>)</span><br><span class="line">            make.<span class="keyword">left</span>.equalTo(<span class="keyword">self</span>.pauseButton.snp_right).offset(<span class="number">0</span>)</span><br><span class="line">            make.height.equalTo(kButtonHeight)</span><br><span class="line">            make.width.equalTo(kStartButtonWidth)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MARK: - 设置状态栏</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">preferredStatusBarStyle</span><span class="params">()</span></span> -&gt; <span class="type">UIStatusBarStyle</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIStatusBarStyle</span>.<span class="type">LightContent</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK: - ButtonClick</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buttonDidClick</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> sender.tag &#123;</span><br><span class="line">            <span class="comment">//reset</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span> :</span><br><span class="line">            timer.invalidate()</span><br><span class="line">            isPlaying = <span class="literal">false</span></span><br><span class="line">            counter = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">self</span>.showLabel.text = <span class="type">String</span>(counter)</span><br><span class="line">            <span class="keyword">self</span>.startButton.enabled = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">self</span>.pauseButton.enabled = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//暂停</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">102</span> :</span><br><span class="line">            <span class="keyword">self</span>.startButton.enabled = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">self</span>.pauseButton.enabled = <span class="literal">false</span></span><br><span class="line">            isPlaying = <span class="literal">false</span></span><br><span class="line">            timer.invalidate()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//开始</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">103</span> :</span><br><span class="line">            <span class="keyword">if</span> (isPlaying) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.startButton.enabled = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">self</span>.pauseButton.enabled = <span class="literal">true</span></span><br><span class="line">            timer = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">0.1</span>, target: <span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"updateTimer"</span>), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">            isPlaying = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK: - 计时器方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        counter = counter + <span class="number">0.1</span></span><br><span class="line">        <span class="keyword">self</span>.showLabel.text = <span class="type">String</span>(format: <span class="string">"%.1f"</span>, counter)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = <span class="type">UIColor</span>.whiteColor()</span><br><span class="line">        setupUI()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/originalix/Lix30DaysOfSwift/tree/master/Project-01" target="_blank" rel="noopener">代码已经上传到GitHub上</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/01/30DaysOfSwift-Day1-计时器/" data-id="cjptr3x3a0001lyz923u2uvax" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/30DaysOfSwift/">30DaysOfSwift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Swift-宏定义与代码标记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/01/Swift-宏定义与代码标记/" class="article-date">
  <time datetime="2016-08-01T08:14:10.000Z" itemprop="datePublished">2016-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/01/Swift-宏定义与代码标记/">Swift 宏定义与代码标记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1>Swift中的”宏”</h1>
<p>写<strong>Objective-C</strong>的时候常常会用到各种宏定义,但是<strong>Swift</strong>中貌似没有宏的这种定义,更多的是通过全局常量或者全局函数来实现这一效果.我们只需要建立一个文件(假设为Const.swift),把想用的定义在里面,无须导入头文件什么的,就可以在全局用啦.</p>
<p><strong>举几个简单的例子：</strong></p>
<p>&lt;!--more--&gt;</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   替代oc中的#define,列举一些常用宏</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕宽度</span></span><br><span class="line"><span class="keyword">let</span> kScreenWidth = <span class="type">UIScreen</span>.mainScreen().bounds.size.width</span><br><span class="line"><span class="comment">// 屏幕高度</span></span><br><span class="line"><span class="keyword">let</span> kScreenHeight = <span class="type">UIScreen</span>.mainScreen().bounds.size.height</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   除了一些简单的属性直接用常量表达,更推荐用全局函数来定义替代宏</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 判断系统版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kIS_IOS7</span><span class="params">()</span></span> -&gt;<span class="type">Bool</span> &#123; <span class="keyword">return</span> (<span class="type">UIDevice</span>.currentDevice().systemVersion <span class="keyword">as</span> <span class="type">NSString</span>).doubleValue &gt;= <span class="number">7.0</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kIS_IOS8</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> (<span class="type">UIDevice</span>.currentDevice().systemVersion <span class="keyword">as</span> <span class="type">NSString</span>).doubleValue &gt;= <span class="number">8.0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RGBA的颜色设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kRGBA</span> <span class="params">(r:CGFloat, g:CGFloat, b:CGFloat, a:CGFloat)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIColor</span>(red: r/<span class="number">255.0</span>, green: g/<span class="number">255.0</span>, blue: b/<span class="number">255.0</span>, alpha: a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App沙盒路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kAppPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span>! &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSHomeDirectory</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Documents路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kBundleDocumentPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span>! &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSSearchPathForDirectoriesInDomains</span>(.<span class="type">DocumentDirectory</span>, .<span class="type">UserDomainMask</span>, <span class="literal">true</span>).first <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caches路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KCachesPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span>! &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSSearchPathForDirectoriesInDomains</span>(.<span class="type">CachesDirectory</span>, .<span class="type">UserDomainMask</span>, <span class="literal">true</span>).first <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1>Swift中的”#pragma mark”</h1>
<p>在今天初用<strong>Swift</strong>编码时，我发现平时很习惯的 <code>#pragma mark</code> 不见了，去查了资料才发现<strong>Swift</strong>中这个也改了,现在<strong>Swift</strong>中的用法如下</p>
<p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - XXXXXX    相当于#pragma mark - XXXXXX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> XXXXXX      相当于#pragma mark XXXXXX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> XXXXXX     相当于额....随意了</span></span><br><span class="line"></span><br><span class="line">如果<span class="type">MARK</span>后不加 - ，那么就不会有分割线效果</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/01/Swift-宏定义与代码标记/" data-id="cjptr3x47000zlyz9t1hacgpg" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift宏定义/">Swift宏定义</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift常用知识/">Swift常用知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/18/Nodejs中编写异步的单元测试代码/">Nodejs中编写异步的单元测试代码</a>
          </li>
        
          <li>
            <a href="/2018/11/30/理解JavaScript中的浮点数/">理解JavaScript中的浮点数</a>
          </li>
        
          <li>
            <a href="/2018/11/21/理解prototype、getPrototypeOf和-proto-之间的不同/">理解prototype、getPrototypeOf和 _proto _之间的不同</a>
          </li>
        
          <li>
            <a href="/2018/11/14/javascript——为自己的库编写更健壮的API函数/">javascript——为自己的库编写更健壮的API函数</a>
          </li>
        
          <li>
            <a href="/2018/10/09/服务器的Mysql初始化设置/">服务器的Mysql初始化设置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 李晓&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;xiao.liunit@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>