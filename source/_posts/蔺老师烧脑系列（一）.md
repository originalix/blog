---
title: 蔺老师烧脑系列（一）
date: 2016-03-21 17:37:10
tags: ["蔺老师烧脑系列","线性表","算法"]

---

在一个月之前，蔺老师给我出了一道题目，据说是可以吹一年的题目，所以我当时压根就没觉得我这么蠢的人能答得出来蔺老师给我出的题目，也就一直没回答，拖了将近一个月，才终于被老师想起来。先把题目放出来，具体的题目是这样的：

<!--more-->

![图1](https://raw.githubusercontent.com/originalix/ListSequentialDemo/master/IMG_4525.JPG)

![图2](https://raw.githubusercontent.com/originalix/ListSequentialDemo/master/IMG_4526.JPG)

![图3](https://raw.githubusercontent.com/originalix/ListSequentialDemo/master/IMG_4527.JPG)

我来大致整理一下图片内的题目内容：外星人侵略地球，要毁灭地球，抓走了10个地球人，告诉这10个地球人，你们每个人代表6亿地球人，你们每个人头顶上戴着一顶帽子。有的人是红色，有的人时绿色，你们站成一列，每个人可以看到排在他前面所有人的颜色，但是不能提醒，如果你回答对了你自己头顶帽子的颜色，你就拯救了6亿人，如果错了，你和那6亿人都得死（蔺老师果然脑洞大，一死死6亿，任重而道远，宝宝当天智商直接吓瘫痪，难怪回答不出来）。外星人给这10个人一晚上的商量时间，第二天就要回答这个问题，问最多有几个人活下来，要采取怎样的回答方式，才能让更多人活下来。

还是得感叹下蔺老师的脑洞够大，然后感谢我在昨天完整的看完了线性表的顺序结构，分析得出，这10个人刚好构成一个线性表，而第十个人的回答刚好是1/2的概率，但是第十个人必须要做出贡献，让我们假定他们商量好第十个人提供的答案，就是前面9个人中颜色为基数的颜色。那么第九个人在回答时，只需要判断他之前的8个人头顶颜色的数量就可以回答出自己的。而之前的人，只需要牢牢记住后面的回答，并把后面的答案带入自己观察前面的人的颜色的数量中即可。最后10个人里能活下来9个人，人品好的话，第十个人也是能够侥幸活下来的。由此可见，蔺老师虽然脑洞大，但是心地还是善良的，一死死60亿，活该找不到男朋友。

从线性表的性质来分析，这10个人排成一列正好构成线性表的基本结构，有最大的存储容量为10，数据元素是每一个人，或者说每顶帽子是一个数据元素，每个人的前后都对应一个数据元素，且位置不做改变。

所以我就尝试是否能用算法来实现这个线性表。

首先因为我使用的是Objective-C语言，所以我可以直接用一个一维数组来定义这张线性表，不需要像昨天的C语言一样来定义。

即：

```objc
/**
     *  定义一个数组，里面有十个对象，类比为十个人，R代表该对象头上戴着red帽子，G代表该对象头上戴着Green帽子，颜色随机。
     */
    NSArray * array = [NSArray arrayWithObjects:@"R",@"G",@"R",@"R",@"G",@"R",@"R",@"G",@"G",@"R",nil];
    

```

这里我们就不直接定义人了，直接用帽子来表示数据元素，里面的帽子颜色也是我随机输入的，没有什么规律性。R为红色的帽子red，G为绿色的帽子green。

接下来我们遍历这个线性表，并定义两个  **NSInteger**  的数据类型来充当计数器，分别为r和g，r统计红帽子的数量，g统计绿帽子的数量。这里我们就假设我们就是第十个人，站在队列的最后面，统计帽子颜色数量。

```objc
    NSInteger r = 0;
    NSInteger g = 0;
    
    for (int i = 0 ; i < 9; i++) {
        
        if ([array[i] isEqualToString:@"R"]) {
            r++;
        }else if ([array[i]isEqualToString:@"G"]){
            g++;
        }
    }

```

接下来我们判断之前的九个数据元素中，帽子的颜色的奇偶性，最后系统输出的结构为，第10个人回答帽子的颜色是红色的。这项输出也是正确的，因为我们虚构的线性表中前九个数据元素，有5个红帽子，4个绿帽子。而第10个人又碰巧被我定义成了红帽子，很幸运的第10个人也活了下来。

```

#define Green NSLog(@"第10个人的帽子是绿色的")
#define Red   NSLog(@"第10个人的帽子是红色的")
    g % 2 == 0 ? Red : Green;    //这是第十个人的回答

```

接下来我们来看这道题目的核心算法部分，即在输出了第十个人的回答之后，怎么让前9个人依次判断他们的帽子，我的想法是定义两对计数器，分别为beforeG和beforeR，用来记录之前还剩余的红帽子数和绿帽子数。另一组是deleteG和deleteR，用来记录已经退出队列的红帽子数和绿帽子数。

用一个嵌套循环，来完整的遍历数组。讲简单一点，里面的for循环，可以理解为当前这个人，在轮到他回答问题时，他对排在他之前的人认真的数了帽子的个数，毕竟一次死6亿，蔺老师玩的有点大。而外层的循环，可以理解为，每个人依次回答问题，第九个回答完，会轮到第八个回答，以此类推。

```objc

   //定义deleteR和deleteG分别为排除掉的人的帽子数量 R为红色 G为绿色
    
    NSInteger deleteR = 0;
    NSInteger deleteG = 0;
  
    /**
     *  n为在第九个人之前的八个人，因为第十个人已经回答完，从第九个人开始观察之前的8个人。
     */
    for (int n = 8; n >= 0 ; n--) {
        
        //计数器，记录排在前面的人的红帽子和绿帽子的数量
        NSInteger beforeR = 0;
        NSInteger beforeG = 0;
        
        //每一个人在回答前，都统计遍历一遍自己之前的数据，完成计数
        for (int i = 0; i < n; i++) {
            
            if ([array[i] isEqualToString:@"R"]) {
                beforeR++;
            }else if ([array[i]isEqualToString:@"G"]){
                beforeG++;
            }
        }


 //判断自己到底是什么颜色的帽子 条件很简单 就是判断奇偶性
        if ( (beforeG + deleteG) % 2 != 0 ) {
            NSLog(@"第%d个人的帽子是绿色的",n+1);
            ++deleteG;
        } else if ((beforeR + deleteR) % 2 == 0)
        {
            NSLog(@"第%d个人的帽子是红色的",n+1);
            ++deleteR;
        }
       
    }

```

最后让我们来运行这段代码，看看运行结果

```objc

2016-03-21 17:30:45.229 外星人入侵地球[21432:3513416] 第10个人的帽子是红色的
2016-03-21 17:30:45.230 外星人入侵地球[21432:3513416] 第9个人的帽子是绿色的
2016-03-21 17:30:45.230 外星人入侵地球[21432:3513416] 第8个人的帽子是绿色的
2016-03-21 17:30:45.230 外星人入侵地球[21432:3513416] 第7个人的帽子是红色的
2016-03-21 17:30:45.231 外星人入侵地球[21432:3513416] 第6个人的帽子是红色的
2016-03-21 17:30:45.231 外星人入侵地球[21432:3513416] 第5个人的帽子是绿色的
2016-03-21 17:30:45.231 外星人入侵地球[21432:3513416] 第4个人的帽子是红色的
2016-03-21 17:30:45.231 外星人入侵地球[21432:3513416] 第3个人的帽子是红色的
2016-03-21 17:30:45.232 外星人入侵地球[21432:3513416] 第2个人的帽子是绿色的
2016-03-21 17:30:45.232 外星人入侵地球[21432:3513416] 第1个人的帽子是红色的

```

我们可以把这里的红绿对照之前一位数组中的R和G来看，输出结果完全正确。当然这并不是最优算法，按照这个方法写的算法，时间复杂度为O(n2)，是一个平方阶的复杂度，所以有更优化的方案还会继续更新。 代码上传到了Github上，有需要的可以下载。

[蔺老师烧脑系列（一）Demo](https://github.com/originalix/-)