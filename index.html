<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Originalee的博客</title><meta name="description" content="服务于足球的爱打篮球的程序员，移动端爬坑中。"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/casual.css"><link rel="stylesheet" href="/css/semantic.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Originalee的博客"></head><body><div class="sidebar"><div class="ui vertical inverted menu"><div class="h100"></div><h3 class="ui inverted aligned icon header"><div class="content"><a href="/" class="title-link">ORIGINALEE的博客</a></div></h3><div class="h50"></div><div class="side-nav"><a href="/" target="_self" class="item">HOME<i class="icon home"></i></a><a href="/archives" target="_self" class="item">ARCHIVE<i class="icon archive"></i></a><a href="/about" target="_self" class="item">INFO<i class="icon info"></i></a><a href="/atom.xml" target="_self" class="item">RSS<i class="icon rss"></i></a></div><div class="item"><div class="ui inverted transparent icon input"><input type="text" placeholder="Search..." class="st-default-search-input"><i class="search icon"></i></div></div><div class="h50"></div></div><div class="h50 mq"><a class="ui teal big label"><i class="content icon"></i></a></div><div class="author-info"><a href="/" class="img-link"><img src="/avatar.png" class="author-photo ui tiny circular image"></a><h4 class="ui aligned icon header"><div class="content">Originalee</div></h4><p class="author-desc">爱打篮球的程序员|目前移动端爬坑中</p><div class="social-outer"><div class="social-inner"><a href="https://github.com/originalix" target="_blank" class="social-link"><i class="icon github"></i></a><a href="mailto:xiao.liunit@gmail.com" target="_self" class="social-link"><i class="icon mail"></i></a></div></div></div></div><div class="main"><div class="wrap"><section class="container"><ul class="home post-list"><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/08/18/数据结构——优先队列-C-和Java实现/" class="post-title-link">数据结构——优先队列(C++和Java实现)</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Aug 18, 2017</div></h6></div></div><div class="post-content"><p>十几天没有更新自己的博客了，因为目前在算法和数据结构的学习中，碰到了一些问题，例如之前就在优先队列，堆这个数据结构面前，感觉到有点吃不透概念，而使用的那本书上写的实在太抽象了，所以又查找了很多资料，最终对优先队列这个数据结构有了一定的了解。花了点时间才啃下来的知识，当然要把它记录下来了，所以今天就来回顾一下优先队列。</p></div><div class="post-tags"><a href="/tags/优先队列/" class="ui black label">优先队列</a><a href="/tags/数据结构/" class="ui green label">数据结构</a></div><a href="/2017/08/18/数据结构——优先队列-C-和Java实现/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/08/06/数据结构——AVL树/" class="post-title-link">数据结构——AVL树(C语言)</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Aug 6, 2017</div></h6></div></div><div class="post-content"><p>AVL(Adelson-Velskii 和 Landis)树是带有平衡条件的二叉查找树。在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(lngn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或-1的结点被认为是平衡的。带有平衡因子-2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p></div><div class="post-tags"><a href="/tags/数据结构/" class="ui black label">数据结构</a><a href="/tags/AVL树/" class="ui blue label">AVL树</a></div><a href="/2017/08/06/数据结构——AVL树/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/07/29/数据结构——二叉查找树(C语言)/" class="post-title-link">数据结构——二叉查找树(C语言)</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jul 29, 2017</div></h6></div></div><div class="post-content"><p>二叉查找树，也称作二叉搜索树，有序二叉树，排序二叉树，而当一棵空树或者具有下列性质的二叉树，就可以被定义为二叉查找树：</p>
<ul>
<li><p>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值。</p>
</li>
<li><p>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值。</p>
</li>
<li><p>任意节点的左、右子树也分别为二叉查找树。</p>
</li>
<li><p>没有键值相等的节点。</p>
</li>
</ul>
<p>二叉查找树相比于其他数据结构的优势在查找、插入的时间复杂度较低，为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构,如集合、multiset、关联数组等。对于大量的输入数据，链表的线性访问时间太慢，不宜使用。</p></div><div class="post-tags"><a href="/tags/数据结构/" class="ui purple label">数据结构</a><a href="/tags/二叉查找树/" class="ui teal label">二叉查找树</a></div><a href="/2017/07/29/数据结构——二叉查找树(C语言)/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/07/20/数据结构——链表的游标实现-C语言/" class="post-title-link">数据结构——链表的游标实现(C语言)</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jul 20, 2017</div></h6></div></div><div class="post-content"><p>上一篇博文我们用指针实现了链表，但是诸如BASIC和FORTRAN等许多语言都不支持指针。如果需要链表而又不能使用指针，这时我们可以使用游标（cursor）实现法来实现链表。</p>
<p>在链表的实现中有两个重要的特点：</p>
<ul>
<li><p>数据存储在一组结构体中。每一个结构体包含有数据以及指向下一个结构体的指针。</p>
</li>
<li><p>一个新的结构体可以通过调用malloc而从系统全局内存（global memory）得到，并可以通过free而被释放。</p>
</li>
</ul>
<p>游标法必须能够模仿实现这两条特性 。 下面给出实现代码:</p></div><div class="post-tags"><a href="/tags/数据结构/" class="ui teal label">数据结构</a><a href="/tags/链表/" class="ui grey label">链表</a></div><a href="/2017/07/20/数据结构——链表的游标实现-C语言/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/07/16/数据结构——链表(C语言实现)/" class="post-title-link">数据结构——链表(C语言实现)</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jul 16, 2017</div></h6></div></div><div class="post-content"><p>提起链表，我们每个人都不会陌生，不管对数据结构的掌握如何，都或多或少的听过与用过链表这样的常见的数据结构。链表是线性表的一种，最基础的线性表，在插入与删除数据时，我们需要对表的整体或部分做移动，为了允许表可以不按照线性的顺序存储数据结构，于是链表就应运而生。链表最大的特点就是在每个节点里存储了到下一个节点的指针。由于不必按照顺序存储，链表在插入的时候可以达到O(1)的复杂度，比我们学习的最基本的线性表要快得多。但是在查找一个节点，或者访问特定编号的结点则需要O(N)的时间。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的有点，同时由于增加了指针域，空间开销较大。不过这在算法与数据结构领域是很常见的，用空间换时间，毕竟鱼和熊掌不可兼得。</p>
<p>我的链表数据结构是使用C语言来实现的，那么下面来看一下链表的头文件定义了哪些操作。</p></div><div class="post-tags"><a href="/tags/数据结构/" class="ui brown label">数据结构</a><a href="/tags/链表/" class="ui grey label">链表</a></div><a href="/2017/07/16/数据结构——链表(C语言实现)/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/07/07/iOS开发——十六进制字符串与NSData的转化/" class="post-title-link">iOS开发——十六进制字符串与NSData的转化</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jul 7, 2017</div></h6></div></div><div class="post-content"><p>最近在完成一个需求时，遇到了<code>NSData</code>类型转换为十六进制的字符串这个需求的函数，在<code>stackoverflow</code>中翻找的时候，给出的答案基本上是如下的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span>* newStr = [[<span class="built_in">NSString</span> alloc] initWithData:theData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"></div><div class="line"><span class="comment">// If the data is null-terminated, you should instead use -stringWithUTF8String: to avoid the extra \0 at the end.</span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span>* newStr = [<span class="built_in">NSString</span> stringWithUTF8String:[theData bytes]];</div><div class="line"></div><div class="line"><span class="comment">// (Note that if the input is not properly UTF-8-encoded, you will get nil.)</span></div></pre></td></tr></table></figure></div><div class="post-tags"><a href="/tags/iOS开发/" class="ui red label">iOS开发</a><a href="/tags/Objective-C/" class="ui purple label">Objective-C</a></div><a href="/2017/07/07/iOS开发——十六进制字符串与NSData的转化/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/06/28/iOS开发——自主设计日志系统/" class="post-title-link">iOS开发——自主设计日志系统</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jun 28, 2017</div></h6></div></div><div class="post-content"><p>好像很久没有写有关iOS的文章了，其实iOS的开发一直都是在进行的，但是最近有需求拓宽知识的宽度，所以一直在接触别的知识，当然啦，移动端开发并不能丢下。</p>
<p>我平时开发的项目监测bug和崩溃的模块都是集成了鹅厂的<code>Bugly</code>系统，毕竟是谁用谁说好的第三方系统。而<code>Bugly</code>主要还是返回的还是崩溃之后的日志，所以如果想在平时的运行中，就能拿到客户手机中的日志怎么办呢。在这个需求的驱使下，便开始着手设计一个日志系统。</p>
<p>需求还是不难的，记录手机操作的内容，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">时间|日志级别|类名_函数名_行数|分类|Log内容</div></pre></td></tr></table></figure>
<p>这样的一种日志形式。</p>
<p>因为不希望频繁的读写，所以希望每十条Log生成之后，读写一次。而未写入硬盘的Log保存在内存中。按照天数，每天都有一份日志，并且在客户的手机异常之后，可以将所有日志压缩上传到服务器。需求介绍完了，并不难对不对。</p></div><div class="post-tags"><a href="/tags/iOS开发/" class="ui olive label">iOS开发</a><a href="/tags/Cute-Logger/" class="ui brown label">Cute-Logger</a><a href="/tags/日志系统/" class="ui yellow label">日志系统</a></div><a href="/2017/06/28/iOS开发——自主设计日志系统/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li><li class="post-list-item"><div class="ui raised padded text container segment"><h2 class="ui header"><a href="/2017/06/21/Linux的用户管理(二)/" class="post-title-link">Linux的用户管理(二)</a></h2><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Jun 21, 2017</div></h6></div></div><div class="post-content"><p>上次的博客我们讲了关于Linux的用户管理的内容，现在我们来讲第二部分——系统用户组的管理。</p>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于它同名的用户组，这个用户组在创建用户的同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p>
<h3 id="增加用户组"><a href="#增加用户组" class="headerlink" title="增加用户组"></a>增加用户组</h3><p>添加一个新的用户组，使用<code>groupadd</code>命令。 格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">groupadd [options] [group]</div><div class="line"></div><div class="line">可以使用的选项有： </div><div class="line">-g GID 指定新用户组的组标识号（GID）。</div><div class="line">-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</div></pre></td></tr></table></figure></div><div class="post-tags"><a href="/tags/Linux/" class="ui yellow label">Linux</a></div><a href="/2017/06/21/Linux的用户管理(二)/" class="read-more ui label">更多 &nbsp&nbsp<i class="ellipsis horizontal icon"></i></a></div></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="next"><button class="ui button teal">NEXT</button></a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Originalee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and theme by <a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">casual</a></p></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/jquery.goup.min.js"></script><script src="/js/semantic.min.js"></script><script src="/js/casual.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>$(document).ready(function(){$.goup({trigger:100,bottomOffset:100,locationOffset:5,title:'',titleAsText:true});});</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','TvAnFS4AVxjiJUvrZJRB','2.0.0');</script></div></body></html>